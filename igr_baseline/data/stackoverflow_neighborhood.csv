"_id","_labels","accepted_answer_id","answer_count","body_markdown","creation_date","display_name","injected","is_accepted","link","name","score","synthlabel","title","updated","uuid","view_count","_start","_end","_type","deleted","updated"
"268",":Question","","0","For a given neo4j server at work, we have multiple database using the same schema. I would like to be able to quickly change the queried database of my neo4j neodash dashboard, by right now, the only way of changing DB that I see is via the edit menu of each card, meaning I need to edit each ones every time I want to change DB.

Is there a way in the interface to quickly change between DB for a given neodash?","1707325046","","true","","https://stackoverflow.com/q/77956604","","","Answer","How to change database for all cards in a neodash dashboard","false","77956604","6",,,,,
"269",":User","","","","","user2482876","true","","","","","Answer","","false","2482876","",,,,,
"270",":Question","","3","I am trying to create a node and add a new relationship setting a value but I keep on getting the same error every time:

    Invalid input &#39;&quot;&#39;: expected whitespace, comment, an identifier, UnsignedDecimalInteger, a property key name or &#39;}&#39; (line 6, column 3 (offset: 263))
    &quot;  &quot;Value&quot;: &quot;2024-02-06T11:16:02.09Z&quot;&quot;


This is my query, can anyone please tell me what am I doing wrong? If I send this query in code, then it runs successfully, I can&#39;t determined what is wrong with this.

Many thanks.

   

    MATCH (n:Node),(additionalDate:AdditionalDate)
    WHERE (n.Id = &quot;xxxx1111xxxx11&quot;)
    AND (additionalDate.DateType = &quot;1&quot;)
    CREATE (additionalDate)-[additionalDateOf:AdditionalDateOf]-&gt;(n)
    SET additionalDateOf = {
      &quot;Value&quot;: &quot;2024-02-06T11:16:02.09Z&quot;
    }

","1707320711","","true","","https://stackoverflow.com/q/77956127","","","Comment","Create Node and Set a value in a relationship Neo4j","false","77956127","16",,,,,
"271",":User","","","","","cacharry","true","","","","","Comment","","false","1786078","",,,,,
"272",":Question","","0","I am using LangChain&#39;s [Neo4j Vector Index](https://python.langchain.com/docs/integrations/vectorstores/neo4jvector), and its `Neo4jVector.from_existing_index` function.

This is an example I found for the structure:

```
movie_plot_vector = Neo4jVector.from_existing_index(
    embedding_provider,
    url=&quot;url&quot;,
    username=&quot;neo4j&quot;,
    password=&quot;pasword&quot;,
    index_name=&quot;customerIndex&quot;,
    embedding_node_property=&quot;embedding_customer_name&quot;,
    text_node_property=&quot;customer_name&quot;,
)

plot_retriever = RetrievalQA.from_llm(
    llm=llm,
    retriever=movie_plot_vector.as_retriever(),
    verbose=True,
    return_source_documents=True
)
```

I want to know if there is a way to search on multiple indexes, what I would imagine this would look like:

```
movie_plot_vector = Neo4jVector.from_existing_index(
    embedding_provider,
    url=&quot;url&quot;,
    username=&quot;neo4j&quot;,
    password=&quot;pasword&quot;,
    index_name=[&quot;customerIndex&quot;,&quot;problemIndex&quot;]
    embedding_node_property=[&quot;embedding_customer_name&quot;,&quot;embedding_problem&quot;]
    text_node_property=[&quot;customer_name&quot;,&quot;problem_description&quot;]
)

plot_retriever = RetrievalQA.from_llm(
    llm=llm,
    retriever=movie_plot_vector.as_retriever(),
    verbose=True,
    return_source_documents=True
)
```





Or is there another function from Neo4jVector which does what I need? Can anyone guide me to find a solution please?","1707297322","","true","","https://stackoverflow.com/q/77953473","","","Tag","Neo4jVector retrieval from multiple indexes","false","77953473","25",,,,,
"273",":User","","","","","Stetco Oana","true","","","","","Answer","","false","23189309","",,,,,
"274",":Question","","0","I have a query like I wrote below. I couldn&#39;t solve the error I gave below even after a lot of effort. I encounter this error when I do any sorting operation. But not always, in specific cases. I think sometimes my query doesn&#39;t return Double(NaN) values most of the time, so I rarely encounter this error.


```
MATCH (news:News {newsId: &quot;/infografik/jurnalist/turkiye-sma-hastaligi-icin-yeni-adimlar-atiyor-26685&quot;})
WITH news
WHERE news.cleanTitle IS NOT NULL

MATCH (otherNews:News {category: news.category})
WHERE news &lt;&gt; otherNews AND otherNews.cleanTitle IS NOT NULL

WITH otherNews,
     apoc.text.sorensenDiceSimilarity(news.cleanTitle, otherNews.cleanTitle) AS sorensen
ORDER BY sorensen DESC
LIMIT 10
RETURN otherNews.title, sorensen, otherNews.category;
```

Error:

```
Neo.ClientError.Statement.TypeError Wrong argument type: Can&#39;t coerce Double(NaN) to String
```



I want to see results sorted correctly. When I don&#39;t sort, I can see the results without any problems. But I need the sorted version.
I tried converting the Sorensen value to string, eliminating Null or NaN values. But I was not successful.

Edit:

I saw that the error was resolved when I placed the &quot;LIMIT 10&quot; line above the &quot;RETURN&quot; line. But this time the results were very inconsistent. If I don&#39;t set any limits, I still encounter the same error. I can increase my limit amount up to a certain number depending on the data I use. As I get closer to the limit I can reach, the accuracy of my returned data increases. How can I overcome this problem?

Fix:

Change to this piece of code solved my problem. Thanks to @Finbar Good.

    apoc.text.sorensenDiceSimilarity(toString(news.cleanTitle), toString(otherNews.cleanTitle))","1707205669","","","","https://stackoverflow.com/q/77946019","","","Question","Neo4j cypher query Double(NaN) issue","false","77946019","48",,,,,
"275",":User","","","","","Alp Buğra Aker","","","","","","User","","false","20343725","",,,,,
"276",":Question","77944207","1","I need to fetch two related collections from a Neo4j database.

The first one is to get some things that satisfy a list of conditions, something like this:

```sql
MATCH (n:Thing)
WHERE [complicated list of conditions]
RETURN n
ORDER BY n.label
LIMIT 25
```

the second one is to get nodes related to the nodes that satisfy the conditions, something like this:

```sql
MATCH (m:RelatedThing) -[:Relationship]-(n:Thing)
WHERE [same complicated conditions about n]
RETURN m
ORDER BY m.label 
LIMIT 25
```

Crucially, the m&#39;s don&#39;t have to be related to the first 25 n&#39;s that were returned by query 1.

It seems like there is a lot of repetition between these two queries. Is there a way to run them both in a single query?

Obviously this can be done in two queries, but reading around I haven&#39;t found a good way to run both queries together. It seems like maybe COLLECT could be useful, but it doesn&#39;t quite fit the use case.

EDIT: I am looking for a solution that works in version 3.5.12","1707168326","","","","https://stackoverflow.com/q/77944096","","","Question","Running two partially related cypher queries together","false","77944096","46",,,,,
"277",":User","","","","","da_ny","","","","","","User","","false","23351570","",,,,,
"278",":Question","","0","I tried all day how to query a neo4j Aura DB from a Python Flask application. 
When I run the following code  locally, without starting the server flask, it works:

    import dotenv
    import os
    from neo4j import GraphDatabase
    import pandas as pd 
    import time
    import numpy as np
    
    
    load_status = dotenv.load_dotenv(&quot;secrets/Neo4j.txt&quot;)
    if load_status is False:
        raise RuntimeError(&#39;Environment variables not loaded.&#39;)
    
    class Neo4jConnection:
        def __init__(self, uri, auth):
            self._uri = uri
            self._user = auth[&quot;user&quot;]
            self._password = auth[&quot;password&quot;]
            self._driver = None
    
        def close(self):
            if self._driver is not None:
                self._driver.close()
    
        def connect(self):
            self._driver = GraphDatabase.driver(self._uri, auth=(self._user, self._password))
    
        def run_query(self, query, parameters=None):
            with self._driver.session() as session:
                result = session.run(query, parameters)
                return result.data()
    
    def get_user_by_proximity(distance, user_position, processed_ids):
        # Configura la tua connessione
        URI = os.getenv(&quot;NEO4J_URI&quot;)
        AUTH = {&quot;user&quot;:os.getenv(&quot;NEO4J_USERNAME&quot;),&quot;password&quot;: os.getenv(&quot;NEO4J_PASSWORD&quot;)}
    
        # Crea una connessione
        neo4j_connection = Neo4jConnection(URI, AUTH)
        neo4j_connection.connect()
        latitude =  user_position[&#39;latitude&#39;]
        longitude = user_position[&#39;longitude&#39;]
        query = f&quot;&quot;&quot;
                   MATCH (n:User)
                   WHERE point.distance(n.location, point({{latitude: {latitude}, longitude:{longitude}}}))/1000 &lt;= {distance}
                   AND NOT n.`_id` IN {processed_ids}
                   RETURN n&quot;&quot;&quot;
        result =  neo4j_connection.run_query(query)
        neo4j_connection.close()
        return result

    def get_score():
       &lt;other stuff&gt;

But when I launch the flask server, calling that piece of code, it gives me this error:

    from flask import Flask
    from match import *
    
    app = Flask(__name__)
    
    
    user = {&lt;MANY INFO&gt;}
    
    @app.route(&#39;/&#39;)
    def index(userInfo=None):
      group = get_score(user)
      return group

    if __name__ == &#39;__main__&#39;:
        app.run(debug=True)
    
    &gt;&gt;&gt;ServiceUnavailable
        neo4j.exceptions.ServiceUnavailable: Unable to retrieve routing information


The connection URI begins with the &quot;neo4j+s://...&quot; protocol and I am using a free instance of Aura DB, maybe that is the problem. Is there a way to solve this? 
Thank you ","1707061298","","","","https://stackoverflow.com/q/77936432","","","Question","Neo4j Aura DB connection doesn&#39;t work when a use flask","false","77936432","26",,,,,
"279",":User","","","","","Salvatore Pennisi","","","","","","User","","false","16796768","",,,,,
"280",":Question","77943636","1","I have a query that I&#39;ve been working on. Basically I have two sets of class type nodes, one called Genes and the other n4sch__Class, the Genes have a parameter &#39;GO ID&#39; that links them to the class category name. After getting all matching class nodes I want to create a relationship that is also based on the Gene nodes parameter &#39;Qualifier&#39;, and this parameter is dynamic so I need to use apoc.create.relationship. The query is also rather large so it needs to be batched. This is what I have so far but it is returning an error:


`call apoc.periodic.iterate(
&quot;MATCH (n:Genes),(c:n4sch__Class)
WHERE n.`GO ID` = c.n4sch__name
RETURN n,c&quot;,
&quot;WITH n, c, 
CALL apoc.create.relationship(n, n.Qualifier, {}, c) YIELD rel RETURN rel&quot;,{batchMode: &quot;BATCH_SINGLE&quot;, BatchSize:100})`

&quot;Invalid input &#39;apoc&#39;: expected ...(line 2, column 6 (offset: 17))\r\n&quot;CALL apoc.create.relationship(n, n.Qualifier, {}, c) YIELD rel RETURN rel&quot;\r\n      ^&quot;: 17","1707016280","","","","https://stackoverflow.com/q/77934488","","","Question","Neo4j complex dynamic relationship creation with batch iteration","false","77934488","46",,,,,
"281",":User","","","","","Yoyo458 A","","","","","","User","","false","17400510","",,,,,
"282",":Question","77928553","1","I have created a transport route of station nodes connected by a :CONNECTION type session, if it is a transfer, I have a :EXCHANGE session type.
I&#39;m looking for a route using a query

```sql
MATCH path = (from:Station {id: 61})-[:IN]-&gt;(sec_from:Section),
              (to:Station {id: 131})&lt;-[:OUT]-(sec_to:Section),
              route=(sec_from)-[:CONNECTION|EXCHANGE*]-&gt;(sec_to)
RETURN route;
```

If I want to search for direct connections only, I use:
`route=(sec_from)-[:CONNECTION*]-&gt;(sec_to)` , it works. If I want to limit the number of connections to 5-10, I use: `route=(sec_from)-[:CONNECTION*5..10]-&gt;(sec_to)` also works. But if I want to have a connection of type :CONNECTION 1-100 and at the same time type :EXCHANGE 0-3, the query doesn&#39;t work:

```sql
MATCH path = (from:Station {id: 61})-[:IN]-&gt;(sec_from:Section),
              (to:Station {id: 131})&lt;-[:OUT]-(sec_to:Section),
              route=(sec_from)-[:CONNECTION*1..100|EXCHANGE*0..3]-&gt;(sec_to)
RETURN route;
```

What is the correct syntax?

Thanks","1706889004","","","","https://stackoverflow.com/q/77928264","","","Question","How to set number of relations between nodes?","false","77928264","35",,,,,
"283",":User","","","","","Ondra","","","","","","User","","false","5158491","",,,,,
"284",":Question","","0","I am currently working on a project that involves integrating OpenStreetMap (OSM) data into a Neo4j database. I&#39;m wondering if there is a recommended or defined structure for storing OSM data in Neo4j. I want to ensure that the data is organized efficiently and can be easily queried for spatial analysis and retrieve useful information.

At the moment, I&#39;m only working with the library OSMX in Python to retrive information from OpenStreetmap, but the idea is to put spatial information retrived with Python in a Neo4j Database.

I&#39;ve done some research, but I couldn&#39;t find a comprehensive guide or recommendation for structuring OSM data in Neo4j. Any guidance or insights from experienced Neo4j users who have worked with OSM data would be immensely helpful. Thanks in advance!","1706773774","","","","https://stackoverflow.com/q/77918453","","","Question","Storing OpenStreetMap data in Neo4j - Need advice on defined structure","false","77918453","43",,,,,
"285",":User","","","","","Santiago Galiano Segura","","","","","","User","","false","18700741","",,,,,
"286",":Question","","0","We&#39;ve used the vanilla Neo4j Enterprise Edition cloud formation template on AWS.

This installed APOC and GDS for us - great.

However, it didn&#39;t install the jars that some functions need. We are getting this error:

&gt; Neo4jError: Failed to invoke procedure `apoc.import.json`: Caused by: apoc.util.MissingDependencyException: Cannot find the S3 jars in the plugins folder. 
&gt; Please put these files into the plugins folder :
&gt; 
&gt; aws-java-sdk-core-x.y.z.jar
&gt; aws-java-sdk-s3-x.y.z.jar
&gt; httpclient-x.y.z.jar
&gt; httpcore-x.y.z.jar
&gt; joda-time-x.y.z.jar
&gt; 
&gt; See the documentation: https://neo4j.com/docs/apoc/current/import/web-apis/#_using_google_cloud_storage

What is the cleanest way to install these jars across all nodes in the cluster? For now we only have one node, but that may not always be the case.

Thanks!



I expected there to be an easy way to get these plugins installed without needed to ssh into each node and manually install","1706762109","","","","https://stackoverflow.com/q/77917743","","","Question","What is the recommended way to install plugin jars on AWS Neo4j Enterprise Edition","false","77917743","17",,,,,
"287",":User","","","","","Jonah Turnquist","","","","","","User","","false","20883169","",,,,,
"288",":Question","","0","I am in the process creating vector index for an existing graph db.

I created a vector index following this : [Vector search indexes - Cypher Manual][1]

Next using python SDK , I traverse the nodes and get the vector-embeddings for the target attribute (by calling VertexAI vector-embeddings API)

Now I want to set the retrieved vector into the node using : [Vector search indexes - Cypher Manual][2]

My question is, how can I do this using the Python SDK ?


  [1]: https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/vector-indexes/?_ga=2.14191475.572054530.1706656777-1759812782.1706656777#indexes-vector-create
  [2]: https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/vector-indexes/?_ga=2.14191475.572054530.1706656777-1759812782.1706656777#indexes-vector-set","1706656885","","","","https://stackoverflow.com/q/77909966","","","Question","neo4j : Setting vector embedding to the node using the python SDK","false","77909966","19",,,,,
"289",":User","","","","","Ashika Umanga Umagiliya","","","","","","User","","false","180904","",,,,,
"290",":Question","","0","I  tried everything, switching keyboards, using virtual keyboard, copy and paste, but the shell won&#39;t in any way, on windows 10, display or recognize curly bracket. I don&#39;t know why. I tried to see if there were shortcuts that could interfere but nothing. Other symbols seem to work!","1706629310","","","","https://stackoverflow.com/q/77907579","","","Question","Neo4J Cypher Shell won&#39;t use curly brackets in any way","false","77907579","20",,,,,
"291",":User","","","","","Idkwhatywantmed","","","","","","User","","false","18542427","",,,,,
"292",":Question","","2","I have a Neo4j schema with a 1-n relation:

```haskhell
// a concept might have multiple accessions
(:Concept{name}) - [:hasAccession] -&gt; (:Accession{code, source})
```

I&#39;d like to create a &#39;nameOrAccession&#39; full-text index (ie, to support both speed and Lucene syntax like &quot;&#39;Computer Science&#39; OR &#39;CS00*&#39;&quot;), which should find nodes based on the `name` property or `Accession.code` property.

I know I could achieve this by creating two full-text indexes, one for `Concept.name` and the other for `Accession.code`, and then I could combine the two in a single `UNION` query.

But is it possible to simplify the query side by creating one index only? Ie, one that is about a &#39;top&#39; (or &#39;central&#39;, or alike) node and would include properties from related nodes?

My understanding is it isn&#39;t possible, but I&#39;d like to check if I&#39;m missing something.

**EDIT**: I also know I could include multiple node labels in the same index (`CREATE FULLTEXT INDEX ... FOR (n:Concept|Accession)...`), but that&#39;s not what I want, since this kind of index would find both concepts and accessions, while I want a query that finds concepts only, possibly based on their accession codes).","1706628406","","","","https://stackoverflow.com/q/77907493","","","Question","Neo4j Full text Index that includes properties from a 1-n node","false","77907493","29",,,,,
"293",":User","","","","","zakmck","","","","","","User","","false","529286","",,,,,
"294",":Question","","0","I am using neo4j C# driver version 5.14.0 and I am getting a Method Not Found exception when executing the following code



    await session.ExecuteWriteAsync(async tx =&gt;
    {
        var updateCypher = @&quot;
            unwind $itemsArr as war
            merge (w:NodeA {uuid:war.Uuid})
            on match set w.durationmins=war.DurationMins,w.lastseen=0,w.new=null
            on create set w.durationmins=war.DurationMins,w.subtype=war.SubType,w.mtype=war.Type,w.new=&#39;Y&#39;,w.lastseen=0
            return count(w) as cnt
        &quot;;
    
        await tx.RunAsync(updateCypher, new { itemsArr = myItems });
        
        var uniqueIdCursor = await tx.RunAsync(&quot;match (w:NodeA) where not  (w)-[]-(:NodeB) and w.new = &#39;Y&#39; return w.uuid&quot;);  
    
        var uniqueIdList = await uniqueIdCursor.ToListAsync();
        var uniqueIds = uniqueIdList.Select(x =&gt; x[&quot;w.uuid&quot;].As&lt;string&gt;()).ToList();
        return uniqueIds
    }

&gt; Exception: System.MissingMethodException: Method not found:
&gt; &#39;System.Threading.Tasks.Task`1&lt;System.Collections.Generic.List`1&lt;Neo4j.Driver.IRecord&gt;&gt;
&gt; Neo4j.Driver.ResultCursorExtensions.ToListAsync(Neo4j.Driver.IResultCursor)&#39;.

However, if I replace the last three lines of code with this I get no error:

    List&lt;string&gt; uniqueIds = [];
    
    while (await uniqueIdCursor.FetchAsync())
    {
        var uniqueId = uniqueIdCursor.Current[0].ToString();
        uniqueIds.Add(uniqueId);
    }
    
    return uniqueIds;

I do not understand why in this scenario ToListAsync() is not available to IResultCursor","1706626400","","","","https://stackoverflow.com/q/77907255","","","Question","Neo4j C# Driver: Method Not Found when calling ToListAsync()","false","77907255","20",,,,,
"295",":User","","","","","paddingtonMike","","","","","","User","","false","472603","",,,,,
"296",":Question","77912146","1","I would to store the following structure in a Neo4J database which has the embedded object oweMe and soldFor are of class Payment.

```
{
  &quot;id&quot;:&quot;id23&quot;,
  &quot;oweMe&quot;: {
    &quot;cost&quot;: 23
    &quot;currency&quot;:&quot;USD&quot;
  }
  &quot;soldFor&quot;: {
    &quot;cost&quot;: 34
    &quot;currency&quot;:&quot;EUR&quot;
  }
}
```

In spring boot, I can use the @embedded and @Embeddable annotations with the JPArespository on an H2 database and it works perfectly.

I want to repeat this structure but store it in a Neo4J database. As the Neo4j does not support the JPARepositry I cannot use those annotations however I see that it uses the @NodeEntity and @Property/@Properties to achieve the same result according to the reference material. 

The reference documentation shows an example that looks like the following where the address is prefixed to the embedded object properties.
```
address.street=Downing Street
address.number=10
```


Thanks everyone for your help,

However when I run the app, I get an error saying `&quot;Required identifier property not found for class ... Payment&quot;` and refers to the embedded object. While that is true that there is no @Id for the embedded object, as the embedded object is not a List&lt;&gt; and there is no @Node/@NodeEntity definition, I expected that should not be needing an id. 

While I can overcome this by writing custom getters and setters to serialise the embedded object so that it can be stored as a JSON string, that has become overwhelming.

As I expect that this sort of embedding is done all the time, can someone please point me to an example that I can use?","1706587190","","","","https://stackoverflow.com/q/77903829","","","Question","How to define in spring model to embed an object using Neo4j","false","77903829","26",,,,,
"297",":User","","","","","PeterNz","","","","","","User","","false","12787705","",,,,,
"298",":Question","77903083","1","I stumbled on the following syntax for setting labels during a `LOAD CSV` operation in Neo4j with Cypher.  It works but I don&#39;t understand *why*, and all of the following modifications break it:
- Removing any of the `YIELD` statements
- Changing `YIELD node` to `YIELD node2` or any other name on the 2nd and 3rd `YIELD` statements
- Removing any of the repeated `WITH n,row` statements between the `YIELD` statements
- Adding `UNION` between the calls (at least, I couldn&#39;t get it to work)

Can anyone enlighten me?  I&#39;m a relative newcomer to Cypher and APOC and I&#39;d love to understand how to make repeated APOC calls properly. 
 
```cypher
LOAD CSV WITH HEADERS FROM &#39;file:///myfile.csv&#39; AS row
MERGE (n:Person{id:row.ID,name:row.Name}) 
WITH n,row
CALL apoc.create.addLabels(id(n), [row.Title,row.Position] YIELD node
WITH n,row
CALL apoc.create.addLabels(id(n), split(row.Roles, &#39;,&#39;)) YIELD node 
WITH n,row
CALL apoc.create.addLabels(id(n), split(row.Aliases, &#39;,&#39;)) YIELD node
```


","1706565665","","","","https://stackoverflow.com/q/77902863","","","Question","How to stack consecutive APOC statements in Neo4j Cypher","false","77902863","26",,,,,
"299",":User","","","","","John","","","","","","User","","false","3091286","",,,,,
"300",":Question","","2","please help me build the cypher:

I have a NODES label :Station and they are connected using a directional relation :Line, where the Line property is e.g. the line number. NODES are multiple connected by different lines (with Line_ID property). I need a query about the route from Station A (e.g. id=1) to Station B (id=25), via the :Line session, but in such a way that multiple variants are offered, but each variant must have the same Line_ID in the session.
My query loops or &quot;skips&quot; during the search to a session with a different LINE_ID than the previous one. Thanks for advice!","1706547907","","","","https://stackoverflow.com/q/77901438","","","Question","Search route in NEO4J","false","77901438","41",,,,,
"301",":Question","","0","his isn&#39;t working after I press the confirm button. I installed Java JDK and set the correct path in the environment variables, but it keeps showing this error repeatedly. I&#39;ve tried my best to resolve this issue, but unfortunately, I wasn&#39;t able to fix it. I&#39;m attempting to provide the path for Neo4j, but unfortunately, it&#39;s not running after doing so","1706542132","","","","https://stackoverflow.com/q/77900793","","","Question","Neo4j is not running after putting the right path","false","77900793","13",,,,,
"302",":User","","","","","Ubair Noor","","","","","","User","","false","23315781","",,,,,
"303",":Question","77900287","1","I am trying to write a Cypher statement, which manages the creation and relationships of tag nodes according to a given list of tag names for an item.

Example calling parameters:
```json
{
  itemId: &quot;foo&quot;,
  tagNames: [&quot;Tag1&quot;, &quot;Tag2&quot;, &quot;Tag3&quot;]
}
```

This is the Cypher statement:
```Cypher
MATCH (i:Item {id: $itemId})

OPTIONAL MATCH (i)-[previousRelations:hasTag]-&gt;(:Tag)
DELETE previousRelations
	
WITH *
CALL {
	UNWIND $tagNames as tagName

	MERGE (tag:Tag {name: tagName})
	ON CREATE SET tag.id = randomUUID(), tag.createdAt = datetime()

	RETURN tag
}

MERGE (i)-[:hasTag]-&gt;(tag)

RETURN i
```

The tag node creation and assignment works all fine!

My problem lies in the `RETURN i` statement if my `$tagNames` list is empty (`[]`). In this case the statement returns *NULL* instead of `i` but I need it to always return `i`.

I also tried the &quot;FOREACH-Trick&quot; as suggested here: https://stackoverflow.com/a/27578798/5106474

```
    FOREACH(ignoreMe IN CASE WHEN tag IS NOT NULL THEN [1] ELSE [] END |
		MERGE (i)-[:hasTag]-&gt;(tag)
    )
```

But still, same behaviour.

Thanks in advance for any suggestions!","1706533471","","","","https://stackoverflow.com/q/77899930","","","Question","UNWIND an empty list negatively affects outer RETURN statement","false","77899930","47",,,,,
"304",":User","","","","","PhilJay","","","","","","User","","false","5106474","",,,,,
"305",":Question","","0","Hello fellow programmers,

I&#39;m new to graph databases and I was wondering whether my approach was optimal or there is room for improvement.

I have a tree-like structure that changes a lot and I need to store it in my graph database.

For example:

![this image][1]

I receive updates in this form:

```
{
   path=&quot;2/5/9/4&quot; 
   value=&quot;example&quot;
}
```

Currently, the leaves hold the values as they change over time, and ancestor nodes store the path:

```
merge (a:A {label: 2})-[:NEXT]-&gt;(b:B {label:5})
merge (b)-[:NEXT]-&gt;(c:C {label:9})
merge (c)-[:NEXT]-&gt;(d:D {label:4})

on create set d.values = [&quot;example&quot;]
on match set d.values = d.values + &quot;example&quot;
```

Is there a more sophisticated/efficient solution?


  [1]: https://i.stack.imgur.com/WG1Dx.png","1706523352","","","","https://stackoverflow.com/q/77898928","","","Question","Query speed optimalization (neo4j)","false","77898928","33",,,,,
"306",":User","","","","","Peter Vecera","","","","","","User","","false","23007772","",,,,,
"307",":Question","","0","I&#180;m trying to figure out how to create a `Node.js` app that fetches data from a `Neo4j` database (currently, I will need only the relationships between nodes), and from a `MongoDB` (all the properties). A property in the `MongoDB` takes the Id-number of the nodes in the `Neo4J` database.


","1706522581","","","","https://stackoverflow.com/q/77898854","","","Question","Retrieve data from a Neo4J and a MongoDB","false","77898854","21",,,,,
"308",":User","","","","","Artur","","","","","","User","","false","15265346","",,,,,
"309",":Question","77897011","1","I use the following code in order to automatically introspect the existent Neo4j schema:

    import { toGraphQLTypeDefs } from &quot;@neo4j/introspector&quot;;
    import fs from &quot;fs&quot;;
    import neo4j from &quot;neo4j-driver&quot;;
    
    const driver = neo4j.driver(
        &quot;neo4j://localhost:7687&quot;,
        neo4j.auth.basic(&quot;neo4j&quot;, &quot;neo4j&quot;)
    );
    
    const sessionFactory = () =&gt; driver.session({ defaultAccessMode: neo4j.session.READ })
    
    async function main() {
        const typeDefs = await toGraphQLTypeDefs(sessionFactory)
        fs.writeFileSync(&#39;schema.graphql&#39;, typeDefs)
        await driver.close();
    }
    main()


On the existent Neo4j database it produces the following:

    type BaseEntity10 @node(labels: [&quot;BaseEntity&quot;, &quot;CompanyType&quot;, &quot;CompositeEntity&quot;, &quot;Requirable&quot;]) {
    	baseEntity16SCompanyTypeOf: [BaseEntity16!]! @relationship(type: &quot;COMPANY_TYPE_OF&quot;, direction: IN)
    	createdAt: BigInt!
    	createdByBaseEntity4S: [BaseEntity4!]! @relationship(type: &quot;CREATED_BY&quot;, direction: OUT)
    	id: BigInt!
    	lowerName: String!
    	name: String!
    	nameSlug: String!
    	properties.lowerNameMonolithic: String!
    	properties.lowerNameWhitespace: String!
    	status: String!
    	system: Boolean!
    	updatedAt: BigInt!
    	uuid: String!
    }

The issue is with the following definitions:

	properties.lowerNameMonolithic: String!
	properties.lowerNameWhitespace: String!

In the https://graphql-toolbox.neo4j.io/ when I try to build this schema, I receive the error:

    Syntax Error: Unexpected character: &quot;.&quot;.
    Locations: [{&quot;line&quot;:24,&quot;column&quot;:12}]

How to properly introspect existing properties with names separated by a dot?","1706440447","","","","https://stackoverflow.com/q/77894562","","","Question","Neo4j GraphQL library schema instrospector wtih property names separated by a dot","false","77894562","25",,,,,
"310",":User","","","","","alexanoid","","","","","","User","","false","1219755","",,,,,
"311",":Question","77894062","1","I need to get JSON-tree of the hierarchy (or some hierarchies, if there is different roots for this pattern - as ```ps``` in my example is list of paths) that I could achieve by:
```
MATCH p=(parent)-[:metaClassOf*]-&gt;(child)
WHERE NOT (parent)&lt;-[:metaClassOf]-()
WITH COLLECT(p) AS ps
CALL apoc.convert.toTree(ps) yield value
RETURN value;
```
If I need to query only part of the hierarchy, I could specify the desired leaf to act as a root in my query:
```
MATCH (root {name: &quot;The Root Name&quot;})
MATCH p=(root)-[:metaClassOf*]-&gt;(child)
WHERE NOT (root)&lt;-[:metaClassOf]-()
WITH COLLECT(p) AS ps
CALL apoc.convert.toTree(ps) yield value
RETURN value;
```
But how do I exclude the ```root``` node itself from the last query, as I don&#39;t want it to be in final JSON-tree? I will repeat, I need the list of paths that are coming from the root node, but without this root node and then convert them to JSON-tree.

I can&#39;t achieve that by filtering nodes after ```UNWIND``` the paths, as I don&#39;t know how to combine them back to list of paths to be able to use ```apoc.convert.toTree(ps)``` then:
```
MATCH (root {name: &quot;The Root Name&quot;})
MATCH p=(root)-[:metaClassOf*]-&gt;(C_Child)
WHERE NOT (root)&lt;-[:metaClassOf]-()
UNWIND nodes(p) as ns
WITH ns as nss
WHERE NOT nss.name= The Root Name&quot;
return nss
```","1706427237","","","","https://stackoverflow.com/q/77893974","","","Question","How to query hierarchy paths without the root node (as list of paths)","false","77893974","27",,,,,
"312",":User","","","","","Roman March","","","","","","User","","false","10578649","",,,,,
"313",":Question","77893238","1","I&#39;m considering using the Neo4j GraphQL library and have the following question - am I correct in understanding that I can use Neo4j GraphQL Type definitions to automatically generate not only the Neo4j GraphQL API but also the schema for my Neo4j database itself?

I&#39;d like to use Neo4j GraphQL Type definitions as my entry point to both - DB schema and GraphQL API automatic creation.

In the documentation for the Neo4j GraphQL library, I see the ability to declare @Id, indexes, and constraints. But how about initial data - for example, if I need to declare a `Movie` type using Type definitions, can I also immediately add (CREATE) 10 movies with specific predefined names? Can I create such initial data, such as nodes, relationships, and properties, directly in Neo4j GraphQL Type definitions? If so, please guide me on how to do it.","1706367211","","","","https://stackoverflow.com/q/77891598","","","Question","Neo4j GraphQL library First Development approach","false","77891598","23",,,,,
"314",":Question","77889580","1","Neo4j 5.15
java 17.09
My neo4j (community server) was running on EC2 without an Issue. Last week we have a java update, but it was still fine afterward. Today when I imported a small data, all went well and when I tried to import the full data which is around 1.5G my process broke and neo4j became un-available. I removed it, reinstalled the same version and the recent version. Nothing is working. Any idea what is happening?
error: 
```
JIT compiler: HotSpot 64-Bit Tiered Compilers
VM Arguments: [-Xmx128m, -Dapp.name=neo4j, -Dapp.pid=8597, -Dapp.repo=/usr/share/neo4j/repo, -Dapp.home=/usr/share/neo4j, -Dbasedir=/usr/share/neo4j]
Configuration files used (ordered by priority):
/etc/neo4j/neo4j.conf
--------------------
org.neo4j.cli.CommandFailedException: Neo4j is not running.
	at org.neo4j.server.startup.Bootloader$Dbms.status(Bootloader.java:529)
	at org.neo4j.server.startup.StatusCommand.execute(StatusCommand.java:37)
	at org.neo4j.cli.AbstractCommand.call(AbstractCommand.java:92)
	at org.neo4j.cli.AbstractCommand.call(AbstractCommand.java:37)
	at picocli.CommandLine.executeUserObject(CommandLine.java:2041)
	at picocli.CommandLine.access$1500(CommandLine.java:148)
	at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461)
	at picocli.CommandLine$RunLast.handle(CommandLine.java:2453)
	at picocli.CommandLine$RunLast.handle(CommandLine.java:2415)
	at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273)
	at picocli.CommandLine$RunLast.execute(CommandLine.java:2417)
	at picocli.CommandLine.execute(CommandLine.java:2170)
	at org.neo4j.server.startup.Neo4jAdminCommand.call(Neo4jAdminCommand.java:123)
	at org.neo4j.server.startup.Neo4jAdminCommand.call(Neo4jAdminCommand.java:42)
	at picocli.CommandLine.executeUserObject(CommandLine.java:2041)
	at picocli.CommandLine.access$1500(CommandLine.java:148)
	at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461)
	at picocli.CommandLine$RunLast.handle(CommandLine.java:2453)
	at picocli.CommandLine$RunLast.handle(CommandLine.java:2415)
	at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273)
	at picocli.CommandLine$RunLast.execute(CommandLine.java:2417)
	at picocli.CommandLine.execute(CommandLine.java:2170)
	at org.neo4j.server.startup.Neo4jCommand.main(Neo4jCommand.java:41)
	at org.neo4j.server.startup.Neo4jBoot.main(Neo4jBoot.java:30)```","1706296758","","","","https://stackoverflow.com/q/77888556","","","Question","Neo4j fails to start","false","77888556","26",,,,,
"315",":User","","","","","Raha","","","","","","User","","false","19281880","",,,,,
"316",":Question","","0","I&#39;m just trying from such a CSV file

    &quot;metaphor&quot;,&quot;entailmentDescription&quot;,&quot;example&quot;,&quot;sourceFrame&quot;,&quot;targetFrame&quot;,&quot;isASourceSubcaseOf&quot;
    metaphor1,escription,example,sf,tf,sbsbs


To map it to a graph database with this command I&#39;m seeing from the tutorial

    LOAD CSV FROM &#39;file:///Query(8).csv&#39; AS row
    WITH row[0] AS metaphor, row[1] AS entailmentDescription, row[2] AS example, row[3] AS sourceFrame, row[4] AS targetFrame
    MERGE (p:Metaphor {metaphor: metaphor})
      SET p.entailmentDescription= entailmentDescription, p.example= example, p.sourceFrame= sourceFrame, p.targetFrame= targetFrame
    RETURN count(p);

I&#39;m not really understanding the error
","1706282559","","","","https://stackoverflow.com/q/77887260","","","Question","Invalid input : expected &quot;)&quot;, &quot;WHERE&quot;, &quot;{&quot; or a parameter (line 3, column 19 (offset: 184))... I&#39;m following the guide so what is happening?","false","77887260","20",,,,,
"317",":Question","77885643","2","I have this query:
```
MATCH (a:Label_A)-[r]-(b:Label_B)
RETURN type(r) AS Relationship_Type, COUNT(*) AS Count
```

Which yields a table with headers *Relationship_Type* and *Count* and the count for each type of relationship. &lt;br /&gt;
I would like to  expand this table to have the counts for each type of label, so not just between `Label_A` and `Label_B`, but also `Label_A` and `Label_C`, `Label_B` and `Label_C`, etc. With corresponding columns such as `Count_Label_B_Label_C` for each possible combination. &lt;br /&gt;
How could that be achieved?","1706260364","","","","https://stackoverflow.com/q/77885164","","","Question","Get number of relationships for each relationship type and label in Neo4j","false","77885164","38",,,,,
"318",":User","","","","","luanpo1234","","","","","","User","","false","2351983","",,,,,
"319",":Question","","0","we are fighting with a strange issue trying to install Neo4j Desktop version 1.5.9 on a Windows 11 client (local installation). 

The software started once and asked for a data directory to store the database in. We used a network drive for this (Neo4j Desktop on the local Windows Program Folder for all users and the database location on a network drive). After that we got a &quot;Project failed to create error&quot; similar to this screen (here you see a different version but it is exactly the same error).

[![enter image description here][1]][1]


From that on it wasn&#39;t possible to start up Neo4j Desktop again

We deinstalled Neo4j Desktop completely. A new installation (even after cleaning up all the program fragments manually) did not solve the issue - Neo4j Desktop refuses to start up.

We checked the log files and it appears that Neo4j is still looking for the network drive set during the first installation. Even after we deleted the local neo4j files, cleaned the Windows registry of neo4j entries and ran a fresh installation the following message shows up in the log file:

    App initialization error Error: EISDIR: illegal operation on a directory, symlink &#39;G:&lt;network drive path&gt;\projects\project-3a8d9382-0884-4fc0-8489-44e182a17445&#39; -&gt; &#39;G:&lt;network drive path&gt;Neo4j\relate-data\projects\project-d577cc4b-8aae-4d57-8115-3c5d323cf956&#39;

Even after a fresh installation Neo4j Desktop picks up this network path somehow. Does anybody have an idea which internal entries (beside from the program files) needs to be cleared to be able to start a fresh installation on the local machine?

As mentioned we have deinstalled the Neo4j Desktop, cleaned remaining files manually and even cleaned the Windows registry where we could. Unfortunately with no luck. A new installation of Neo4j Desktop on the same machine leaves us with the same situation. No startup of the Client possible anymore.

And within the log there is always an error pointing to the network drive. 



  [1]: https://i.stack.imgur.com/9ikCu.png","1706199631","","","","https://stackoverflow.com/q/77881458","","","Question","Neo4j Desktop installation error &quot;App initialization error Error: EISDIR&quot;","false","77881458","29",,,,,
"320",":User","","","","","Krid","","","","","","User","","false","5095832","",,,,,
"321",":Question","","0","We are considering building knowlede-graph based Data Catalog solution to register meta-data of data-sources,tables (and other data assets) in our systems. Our goal is to build a Graph based RAG (Retrieval-Augmented Generation) on top of this knowledge-graph.

Ultimate goal is to provide an interface for data consumer to get comprehensive answers for the data-source/sets related queries.

 
For the POC, I came up with  following simplified meta-data model :
[![enter image description here][1]][1]

 
Then I modeled a knowledge-graph using Neo4J for the following sample table model:
[![enter image description here][2]][2]

 

Resulting graph look like this:
[![enter image description here][3]][3]

 

 Vector-index is also created for the nodes.
 

Now I want to build a Graph based RAG, which can refer this knowledge-graph and provide comprehensive answer to the users.Queries can be like:

**&quot;How can I find the top 5 shipping methods by user count&quot;**


For this query we can get the vector embedding and do a vector-search against the graph.This will  probably give &quot;shipping&quot; table and &quot;user&quot; table info from the graph-db.

But to construct the correct answer, we need to provide the complete relationship between *user*,*order* and *shipment* tables to the LLM.That is, depend on the query, we need to transverse the graph and build the connectivity sub-graph between tables/columns.

My questions are:

 1. How can I build this connectivity sub-graph depend on the query?
 2. Can I use [ReAct][4] (Reason and Action) based template to instruct LLM to use an Agent to query till it can find relationships ?
 3. Does frameworks like LangChain or LLamaIndex provide this kind of functionality?

 


  [1]: https://i.stack.imgur.com/BAn97.png
  [2]: https://i.stack.imgur.com/wFcy7.png
  [3]: https://i.stack.imgur.com/DI7IG.png
  [4]: https://arxiv.org/abs/2210.03629","1706168941","","","","https://stackoverflow.com/q/77878254","","","Question","Graph RAGs , LLMs and building connectivity sub-graph","false","77878254","28",,,,,
"322",":Question","77878372","1","Using neo4j (with APOC 5.7), I&#39;m trying to find the shortest path on a topological graph (no location on the nodes), where the weight of each step is 1 by default. I don&#39;t want to limit the number of steps for the path, only the relationship type. 

The [documentation](https://neo4j.com/labs/apoc/4.4/algorithms/path-finding-procedures/) is very flat:

`apoc.algo.dijkstra` requires a weight on the relationship

`apoc.algo.dijkstraWithDefaultWeight` throws: `There is no procedure with the name apoc.algo.dijkstraWithDefaultWeight`

`apoc.algo.aStar` and `apoc.algo.aStarWithPoint` require points location or `lat` and `long` 

`apoc.algo.allSimplePaths` requires `maxNodes` and is a full graph search...

For example, for the graph:
```
CREATE (b:City {name:&#39;Berlin&#39;})
CREATE (m:City {name:&#39;M&#252;nchen&#39;})
CREATE (f:City {name:&#39;Frankfurt&#39;})
CREATE (h:City {name:&#39;Hamburg&#39;})
MERGE (b)-[:DIRECT]-(h)
MERGE (b)-[:DIRECT]-(m)
MERGE (b)-[:DIRECT]-(f)
MERGE (f)-[:DIRECT]-(m)
MERGE (f)-[:DIRECT]-(h)
```
I would like the get something like:
```
╒════════╤══════════════════════════════════════════════════════════════════════╕
│weight  │path                                                                  │
╞════════╪══════════════════════════════════════════════════════════════════════╡
│2.0     │(:City {name: &quot;M&#252;nchen&quot;})&lt;-[:DIRECT]-(:City {name: &quot;Frankfurt&quot;})-     |
│        │[:DIRECT]-&gt;(:City {name: &quot;Hamburg&quot;})                                  │       
└────────┴──────────────────────────────────────────────────────────────────────┘
```
Currently, the simplest option I see is to use `apoc.algo.dijkstra` and add a `weight` property with a value `1` on each relationship - which is absurd.

Any advice?","1706168403","","","","https://stackoverflow.com/q/77878217","","","Question","Shortest path on a topological graph with default weight","false","77878217","18",,,,,
"323",":User","","","","","nimrod serok","","","","","","User","","false","18482310","",,,,,
"324",":Question","77869514","2","I am trying to write a query that will find recipes I can make based on 2 criteria. I need to have all the ingredients and I need to have a sufficient quantity of each ingredient.

I have a graph structure like this: ![][1]

I have recipe nodes with relationships to ingredients that specify the quantity of the ingredient I need. And I have Pantry node with relationships to ingredients that specify the quantity of the ingredient I actually have.

I am trying to use the following query, but it is not handling quantities correctly, so it is returning recipes even if I don&#39;t have enough of all the ingredients.

```
MATCH (p:Pantry)-[has:HAS]-&gt;(i:Ingredient)
WITH COLLECT(i) AS pantry_ingredients, COLLECT(has) AS pantry_quantity
MATCH (r:Recipe)-[requires:REQUIRED]-&gt;(i:Ingredient)

WITH pantry_ingredients, pantry_quantity, r, COLLECT(i) AS recipe_ingredients
WHERE ALL(x IN recipe_ingredients WHERE x IN pantry_ingredients AND EXISTS{
    MATCH (:Pantry)-[has:HAS]-&gt;(:Ingredient {name: x.name})&lt;-[requires:REQUIRED]-(:Recipe)      
    WHERE has.quantity &gt;= requires.quantity})
    
RETURN r
```

How can I modify this to correctly filter out recipes based on having the needed quantity?


  [1]: https://i.stack.imgur.com/lfM59.png","1706042154","","","","https://stackoverflow.com/q/77869128","","","Question","Neo4j Cypher Query to find recipes where I have all the ingredients and a sufficient quantity","false","77869128","44",,,,,
"325",":User","","","","","mr_mars","","","","","","User","","false","23288805","",,,,,
"326",":Question","","1","I have a query that matches few nodes each time it runs.This query runs around 50,000 times in my program.After which I have designed a loop to delete the nodes that i have matched in a separate query .Each match and delete query is within a block of code that runs around 50,000 times.Considering I have created indexes for all the nodeLabels on the property that i am using to query the nodes,how will the presence of a query affect performance.
After testing it for myself I have observed that time taken for the program to run is more after index creation when compared to running it before the creation of index.
Is this possible?
Shouldn&#39;t indexes improve the performance.

I have read that range indexed work internally using a BTree.Does the BTree get modified after each delete?
Is that the reason for time increase?","1706008299","","","","https://stackoverflow.com/q/77865854","","","Question","How Does the Neo4j Range Index BTREE work after deletion of nodes","false","77865854","22",,,,,
"327",":User","","","","","Sharon ","","","","","","User","","false","22289882","",,,,,
"328",":Question","","0","I have this error when trying to establish a connection between the database and the project in Android Studio. I added the following line in the build.gradle.kts: implementation(&quot;org.neo4j.driver:neo4j-java-driver:5.12.0&quot;).
How can i resolved this?

Execution failed for task &#39;:app:mergeExtDexDebug&#39;.
&gt; Could not resolve all files for configuration &#39;:app:debugRuntimeClasspath&#39;.
   &gt; Failed to transform neo4j-java-driver-5.12.0.jar (org.neo4j.driver:neo4j-java-driver:5.12.0) to match attributes {artifactType=android-dex, asm-transformed-variant=NONE, dexing-enable-desugaring=true, dexing-enable-jacoco-instrumentation=false, dexing-is-debuggable=true, dexing-min-sdk=24, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      &gt; Execution failed for DexingNoClasspathTransform: C:\Users\nicol\.gradle\caches\modules-2\files-2.1\org.neo4j.driver\neo4j-java-driver\5.12.0\80cf488db020ca5cf8edadb384c1a652e80d33a\neo4j-java-driver-5.12.0.jar.
         &gt; Error while dexing.

I try to add

android {
    defaultConfig {
        multiDexEnabled true
    }
}

but did&#39;t work","1705856782","","","","https://stackoverflow.com/q/77855812","","","Question","Execution failed for task &#39;:app:mergeExtDexDebug&#39;. Failed to transform neo4j-java-driver-5.12.0.jar","false","77855812","17",,,,,
"329",":User","","","","","Nicolae Dirva","","","","","","User","","false","23277731","",,,,,
"330",":Question","77855696","1","I have the following graph structure in neo4j.

[![enter image description here][1]][1]

As you can see, there are two components in this graph. I want to retrieve the blue nodes (nodes of type `NodeA` in the example) with their respective component. For the example, `4, 3, 2, 1` and `6, 5`.

I tried `gcc` and `wcc` of neo4j, however it failed, maybe I could not use it properly. Besides, I tried writing custom queries using cypher, however, my results were not even close to the result that I wanted.

You can simulate the graph with the following commands.
```
CREATE (a:NodeA {name: &quot;1&quot;});
CREATE (a:NodeA {name: &quot;2&quot;});
CREATE (a:NodeA {name: &quot;3&quot;});
CREATE (a:NodeA {name: &quot;4&quot;});
CREATE (a:NodeA {name: &quot;5&quot;});
CREATE (a:NodeA {name: &quot;6&quot;});
CREATE (b:NodeB {anotherName: &quot;11&quot;});
CREATE (b:NodeB {anotherName: &quot;12&quot;});
CREATE (b:NodeB {anotherName: &quot;13&quot;});
CREATE (b:NodeB {anotherName: &quot;14&quot;});
MATCH (a:NodeA {name: &quot;1&quot;})
MATCH(b:NodeB {anotherName: &quot;11&quot;})
CREATE (a) - [:CONTAINS] -&gt; (b);
MATCH (a:NodeA {name: &quot;2&quot;})
MATCH(b:NodeB {anotherName: &quot;11&quot;})
CREATE (a) - [:CONTAINS] -&gt; (b);
MATCH (a:NodeA {name: &quot;3&quot;})
MATCH(b:NodeB {anotherName: &quot;11&quot;})
CREATE (a) - [:CONTAINS] -&gt; (b);
MATCH (a:NodeA {name: &quot;3&quot;})
MATCH(b:NodeB {anotherName: &quot;12&quot;})
CREATE (a) - [:CONTAINS] -&gt; (b);
MATCH (a:NodeA {name: &quot;4&quot;})
MATCH(b:NodeB {anotherName: &quot;12&quot;})
CREATE (a) - [:CONTAINS] -&gt; (b);
MATCH (a:NodeA {name: &quot;5&quot;})
MATCH(b:NodeB {anotherName: &quot;13&quot;})
CREATE (a) - [:CONTAINS] -&gt; (b);
MATCH (a:NodeA {name: &quot;5&quot;})
MATCH(b:NodeB {anotherName: &quot;14&quot;})
CREATE (a) - [:CONTAINS] -&gt; (b);
MATCH (a:NodeA {name: &quot;6&quot;})
MATCH(b:NodeB {anotherName: &quot;14&quot;})
CREATE (a) - [:CONTAINS] -&gt; (b);
```


  [1]: https://i.stack.imgur.com/lcZu8.png","1705851924","","","","https://stackoverflow.com/q/77855511","","","Question","Neo4j - Retrieve nodes of graph components","false","77855511","47",,,,,
"331",":User","","","","","Erdem Tuna","","","","","","User","","false","10755618","",,,,,
"332",":Question","","1","I am currently doing an open source project that is a social network and when I am setting up the docker-compose I find myself stuck in a problem.

I have my neo4j service and I have a python service that generates a fake graph for me.
Then i need the import folder of neo4j have the temp folder of fake_graph service in real time.

The service that generates the fake graph works as follows:
For each action block (create users, create friends, ...) first create the datasets in .csv files (in a folder called temp) and then import them into neo4j.

So my problem is how do I ensure that neo4j, in its import folder, receives the files that are being dynamically created in the temp folder of the fake_graph service.

this is my docker-compose code:

```
version: &quot;3.8&quot;
services:
  # Noe4j database config
  neo4j:
    container_name: neo4j_social_seed_db 
    image: neo4j:5.15.0-enterprise
    ports:
      - &quot;7474:7474&quot;
      - &quot;7687:7687&quot;
    restart: always
    environment:
      - NEO4J_AUTH=neo4j/neo4jSocial
      - NEO4J_ACCEPT_LICENSE_AGREEMENT=yes
      - NEO4J_server.memory.pagecache.size=1G
      - NEO4J_server.directories.import=import
    volumes:
      - ./neo4j/data:/data
      - ./neo4j/conf:/conf
      - ./neo4j/logs:/logs
      - ./neo4j/plugins:/plugins
      - ./fake-graph/app/temp:/import
    networks:
      - net
  # Social Seed Api in Java config
  social-seed-app:
    container_name: app_social_seed
    image: social-seed:0.0.1
    build: 
      context: ./backend
    ports:
      - &quot;8081:8081&quot;
    environment:
      - DATABASE_URI=bolt://neo4j:7687
      - DATABASE_USERNAME=neo4j
      - DATABASE_PASSWORD=neo4jSocial
    depends_on:
      - neo4j
    networks:
      - net
  # Fake Graph config
  fake-graph:
    container_name: fake_graph_service
    image: python:3.11.2-slim
    build: 
      context: ./fake_graph    
    volumes:
      - ./fake_graph:/app
    depends_on:
      - neo4j
    environment:
      - GENERATE_FAKE_GRAPH
      - DATABASE_URI=bolt://neo4j:7687
    command: &gt;
      sh -c &quot;if [ &#39;$GENERATE_FAKE_GRAPH&#39; = &#39;true&#39; ]; then python /app/generate.py; else sleep infinity; fi&quot;    
    networks:
      - net
networks:
  net:
```","1705774712","","","","https://stackoverflow.com/q/77852179","","","Question","Neo4j Import folder shared between services in docker","false","77852179","29",,,,,
"333",":User","","","","","Xermiz","","","","","","User","","false","17751139","",,,,,
"334",":Question","","0","I want to access my database (which is saved and runs in Neo4j Desktop) from a jupyterNotebook which is runing in jupyterLab. However I am getting this error:

```
ServiceUnavailable: Couldn&#39;t connect to 127.0.0.1:7687 (resolved to ()):
Failed to establish connection to ResolvedIPv4Address((&#39;127.0.0.1&#39;, 7687)) (reason [Errno 111] Connection refused)
```

**This is my code:
**
**Example how to connect with Neo4j
**
```
from neo4j import GraphDatabase
import pandas as pd

uri = &quot;bolt://127.0.0.1:7687&quot;
username = &quot;XXX&quot;
password = &quot;XXX&quot;
driver = GraphDatabase.driver(uri, auth=(username, password))

query = &quot;&quot;&quot;
MATCH (t:Task)-[:BELONGS_TO]-&gt;(g:GroundTruth)
RETURN t.name, g.id
LIMIT 5
&quot;&quot;&quot;

with driver.session() as session:
result = session.run(query)
data = pd.DataFrame(result.data())

print(data)
```

If i run that code in VSC, it works perfectly; but not from JupyterLab.

Does someone know a sloution?

I already did this changes in the Neo4j Settings:

```
dbms.connector.bolt.enabled=true
dbms.connector.bolt.listen_address=0.0.0.0:7687
```","1705674874","","","","https://stackoverflow.com/q/77846849","","","Question","How to connect a jupyterNotebook in jupyterLab with Neo4j","false","77846849","24",,,,,
"335",":User","","","","","Romeo","","","","","","User","","false","23269586","",,,,,
"336",":Question","77838141","1","Hello Stack Overflow community,

I am currently working in a Windows environment and looking to use Neo4j 3.4.12 community version for my project. However, I have encountered a challenge with Neo4j Desktop. I am using Neo4j Desktop version 1.5.8, and it seems to support only 4.x versions of Neo4j community edition. I am seeking advice on how to run the 3.x version, specifically 3.4.12, on this version of Neo4j Desktop.

Additionally, I have downloaded the Neo4j-community-3.4.12-windows.zip file separately. Is there a way to load this file directly into Neo4j Desktop? I would appreciate any guidance on integrating this specific version of Neo4j into my current setup.

I have not been able to find relevant documentation or previous questions addressing this specific scenario. Any insights or instructions would be greatly helpful.

Thank you in advance for your assistance!

After installing Neo4j Desktop 1.5.8 on my Windows machine, I expected to be able to use the Neo4j 3.4.12 community version with it. My first step was to search for the 3.4.12 version within the Neo4j Desktop interface, expecting it to be available for installation or integration. However, to my surprise, I found that Neo4j Desktop only listed versions 4.x and above in its dropdown menu for database versions, with no option for earlier versions like 3.4.12.

Subsequently, I downloaded the Neo4j-community-3.4.12-windows.zip file separately, thinking that I could manually add this version to Neo4j Desktop. I attempted to load this file into Neo4j Desktop, but there was no clear or straightforward option to integrate this external file. I was expecting an &#39;Import&#39; or &#39;Load&#39; feature within Neo4j Desktop that would allow me to use the downloaded 3.4.12 version, but I couldn&#39;t find such an option.

As a result, I&#39;m currently unable to use Neo4j 3.4.12 with Neo4j Desktop 1.5.8, which is a critical requirement for my project.","1705559481","","","","https://stackoverflow.com/q/77837312","","","Question","How to Use Neo4j 3.4.12 Community Version in Neo4j Desktop 1.5.8?","false","77837312","34",,,,,
"337",":User","","","","","GAIS","","","","","","User","","false","23262005","",,,,,
"338",":Question","77834509","1","When following the neo4j documentation - https://neo4j.com/developer/swift/

I get the following error on step two.

&gt; Cannot find type &#39;Client&#39; in scope.

```
import Foundation
import Theo

class Neo4jService {
    
    
let theo: Client = Client(baseURL: &quot;hostname.com&quot;, user: &quot;username&quot;, pass: &quot;password&quot;) 
//    With the instance hostname, username and password filled out.

}
```

I can confirm I have added Theo as a package dependency.


Tried removing and readding the package. tried cleaning and rebuilding the project. Xcode just doesnt seem to want to pick up the new module for some reason, unless im messing up adding the package dependency?","1705511532","","","","https://stackoverflow.com/q/77834309","","","Question","Cannot find type &#39;Client&#39; in scope","false","77834309","63",,,,,
"339",":User","","","","","XmalevolentX","","","","","","User","","false","10930591","",,,,,
"340",":Question","77835440","1","Example query:
```
WITH [&quot;sword&quot;, &quot;Sword&quot;, &quot;blade&quot;, &quot;Blade&quot;, &quot;katana&quot;, &quot;Katana&quot;] AS weapons
MATCH (s:Set)
WHERE s.name IN weapons
RETURN s
```
[Neo4j documentation mentions](https://neo4j.com/docs/cypher-manual/current/planning-and-tuning/query-tuning/indexes/) that both Range index and Text index should be used when we check for list membership. Which one is actually better in the example above where the list contains only strings?

I could not find information in Neo4j documentation about which index should I should choose to speed up these queries.

What about a more compliacted example which uses `any()` with `CONTAINS`?:
```
WITH [&quot;sword&quot;, &quot;blade&quot;, &quot;katana&quot;] AS weapons
MATCH (s:Set)
WHERE ANY(piece IN weapons WHERE toLower(s.name) CONTAINS piece)
RETURN s
```","1705508530","","","","https://stackoverflow.com/q/77833955","","","Question","Neo4j - Range index vs Text index when checking membership in list of only strings","false","77833955","40",,,,,
"341",":User","","","","","Arkadiusz G&#243;recki","","","","","","User","","false","16505995","",,,,,
"342",":Question","","2","Error using the FOREACH syntax.

    CASE WHEN i.IOType STARTS WITH &#39;D&#39; THEN [1] ELSE [] END AS isDigital,
        CASE WHEN i.IOType STARTS WITH &#39;A&#39; THEN [1] ELSE [] END AS isAnalog 
           FOREACH(_ IN isAnalog | 
            MERGE(aa:AnalogAlarm {tag: signalTag })
            WHERE i.signalTag CONTAINS aa.tag
            MERGE (i)-[:IS_ALARM]-&gt;(aa))
            FOREACH(_ IN isDigital | 
            MERGE(dig:DigitalAlarm {tag: signalTag })
            WHERE i.signalTag CONTAINS dig.tag
            MERGE (i)-[:IS_ALARM]-&gt;(dig))

So I am unable to use the WHERE clause in FOREACH. What would be the appropriate syntax?","1705483465","","","","https://stackoverflow.com/q/77831258","","","Question","FOREACH syntax in NEO4J","false","77831258","49",,,,,
"343",":User","","","","","SIVASANKARI","","","","","","User","","false","7895932","",,,,,
"344",":Question","","1","I want to query neo4j database and get the results converted to natural language using LLM? 
Can it be done in neo4j desktop. I have installed APOC plugin ,but I  don&#39;t see any apoc.ml procedure in it.

Prompt example:
`#Are there any news regarding return to office policies?
CALL apoc.ml.openai.embedding([&quot;Are there any news regarding return to office policies?&quot;], 
   &quot;{openai_api_key}&quot;) YIELD embedding
MATCH (c:Chunk)
WITH c, gds.similarity.cosine(c.embedding, embedding) AS score
ORDER BY score DESC LIMIT 3
RETURN c.text, score`

I am getting this error when i try using the above query in neo4j desktop:
Neo.ClientError.Procedure.ProcedureNotFound
There is no procedure with the name `apoc.ml.openai.embedding` registered for this database instance. Please ensure you&#39;ve spelled the procedure name correctly and that the procedure is properly deployed.","1705472303","","","","https://stackoverflow.com/q/77830323","","","Question","Can we use apoc.ml.openai.embediing with Neo$j desktop?","false","77830323","41",,,,,
"345",":User","","","","","Amit Pawar","","","","","","User","","false","23256411","",,,,,
"346",":Question","77831248","1","In a Cypher query, I can insert `ORDER BY` in the middle of the query, for example

    MATCH (p:Product)
    WITH p
    ORDER BY p.id DESC 
    LIMIT 5
    MATCH (p)-[:CREATED_BY]-&gt;(u:User)
    RETURN p.id, u.name

On the `SLOTTED` or `PIPELINED` runtime, I will receive properly ordered results. For example:

    p.id | u.name
    ---------------
    5    | someName
    4    | someName
    3    | someName
    2    | someName
    1    | someName

Should I expect the same result (maintaining the proper order) when using the `PARALLEL` runtime, even if I have additional `MATCH` statements after the `ORDER BY` clause?","1705452297","","","","https://stackoverflow.com/q/77829427","","","Question","Neo4j Cypher ORDER BY in the middle of the query and expected behaviour on PARALLEL runtime","false","77829427","44",,,,,
"347",":Question","","0","I am using NeoVis.js to visualize Neo4j graph databases. The visualization works fine when connecting to a local Neo4j instance, but I encounter issues when trying to connect to a Neo4j AuraDB instance. Specifically, not all arrows/relationships are displayed in the visualization.


This is how I connect to the database using NeoVis.

```
const isAuraServer = import.meta.env.VITE_SERVER_URL === &#39;auradb&#39;

onMounted(async () =&gt; {
  let neoViz = null

  const config = {
    containerId: `viz${props.index}`,

    neo4j: {
      serverUrl: import.meta.env.VITE_SERVER_URL,
      serverUser: import.meta.env.VITE_SERVER_USER,
      serverPassword: import.meta.env.VITE_SERVER_PASSWORD,
      driverConfig: {
        encrypted: isAuraServer ? &#39;ENCRYPTION_ON&#39; : &#39;ENCRYPTION_OFF&#39;,
        trust: &#39;TRUST_SYSTEM_CA_SIGNED_CERTIFICATES&#39;
      }
    },
```

Local Neo4j:

[![Local Neo4j](https://i.stack.imgur.com/WQykA.png)](https://i.stack.imgur.com/WQykA.png)

Remote Neo4j Aura:

[![Remote Neo4j Aura](https://i.stack.imgur.com/9ANIp.png)](https://i.stack.imgur.com/9ANIp.png)

Here is the whole code

```
&lt;script setup lang=&quot;ts&quot;&gt;
import NeoVis from &#39;neovis.js/dist/neovis.js&#39;
import { onMounted } from &#39;vue&#39;

interface SelectedAnnotationInformation {
  createdAt: string
  shortcut: string
  firebaseUserUID: string
  name: string
  description: string
  id: string
}

const props = defineProps({
  index: Number,
  selectedAnnotation: {
    type: Array as () =&gt; SelectedAnnotationInformation[],
    default: () =&gt; []
  }
})

const isAuraServer = import.meta.env.VITE_SERVER_URL === &#39;auradb&#39;

onMounted(async () =&gt; {
  let neoViz = null

  const config = {
    containerId: `viz${props.index}`,

    neo4j: {
      serverUrl: import.meta.env.VITE_SERVER_URL,
      serverUser: import.meta.env.VITE_SERVER_USER,
      serverPassword: import.meta.env.VITE_SERVER_PASSWORD,
      driverConfig: {
        encrypted: isAuraServer ? &#39;ENCRYPTION_ON&#39; : &#39;ENCRYPTION_OFF&#39;,
        trust: &#39;TRUST_SYSTEM_CA_SIGNED_CERTIFICATES&#39;
      }
    },

    visConfig: {
      nodes: {
        shape: &#39;circle&#39;,
        size: 100,
        font: {
          color: &#39;black&#39;,
          size: 10
        },
        color: {
          border: &#39;#2B7CE9&#39;,
          background: &#39;#97C2FC&#39;,
          highlight: {
            border: &#39;#red&#39;,
            background: &#39;#D2E5FF&#39;
          },
          hover: {
            border: &#39;#2B7CE9&#39;,
            background: &#39;#D2E5FF&#39;
          }
        }
      },
      edges: {
        color: {
          color: &#39;#00ffff&#39;,
          highlight: &#39;#ff0000&#39;
        },
        selectionWidth: 2,
        length: 200,
        width: 1,
        arrows: {
          to: { enabled: true }
        }
      },
      physics: {
        hierarchicalRepulsion: { avoidOverlap: 1 },
        solver: &#39;repulsion&#39;,
        repulsion: {
          nodeDistance: 100
        }
      }
    },

    layout: {
      improvedLayout: true,
      randomSeed: 420,
      hierarchical: {
        enabled: true,
        direction: &#39;DU&#39;,
        sortMethod: &#39;directed&#39;,
        nodeSpacing: 1000,
        treeSpacing: 20,
        levelSeparation: 250
      }
    },

    labels: {
      Annotation: {
        label: &#39;name&#39;,
        value: &#39;id&#39;,

        [NeoVis.NEOVIS_ADVANCED_CONFIG]: {
          function: {
            title: (props: any) =&gt;
              NeoVis.objectToTitleHtml(props, [
                &#39;id&#39;,
                &#39;name&#39;,
                &#39;shortcut&#39;,
                &#39;description&#39;,
                &#39;createdAt&#39;,
                &#39;firebaseUserUID&#39;
              ]),
            color: (node: any) =&gt; {
              const selectedAnnotationIds = props.selectedAnnotation.map(
                (annotation: any) =&gt; annotation.id
              )
              if (selectedAnnotationIds.includes(node.properties.id)) {
                return &#39;#e74c3c&#39;
              } else {
                return &#39;#3498db&#39;
              }
            }
          }
        }
      }
    },

    relationships: {
      RELATED_TO: {
        value: &#39;weight&#39;,

        [NeoVis.NEOVIS_ADVANCED_CONFIG]: {
          static: {
            label: &#39;RELATED_TO&#39;,
            color: &#39;green&#39;,
            font: {
              background: &#39;none&#39;,
              strokeWidth: &#39;0&#39;,
              size: 10,
              color: &#39;Black&#39;
            }
          }
        }
      }
    },

    hierarchical_layout: true,
    hierarchical_sort_method: &#39;directed&#39;,

    initialCypher: `MATCH (start:Annotation {id: &#39;${props.selectedAnnotation[0].id}&#39;})
                    OPTIONAL MATCH (a:Annotation)-[r:RELATED_TO*]-(start)
                    RETURN a AS node, r AS relationship, start AS otherNode
                    UNION
                    MATCH (start:Annotation {id: &#39;${props.selectedAnnotation[0].id}&#39;})
                    OPTIONAL MATCH (start)-[r:RELATED_TO*]-(b:Annotation)
                    RETURN start AS node, r AS relationship, b AS otherNode`
  }

  neoViz = new NeoVis(config as any)
  neoViz.render()
})
&lt;/script&gt;

&lt;template&gt;
  &lt;div
    class=&quot;mx-auto h-full w-full flex justify-center border border-gray-300&quot;
    :id=&quot;`viz${props.index}`&quot;
  &gt;&lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;
```

I&#39;ve tried everything, but I have no idea where the problem might be. I&#39;m encountering a warning in the console, and I&#39;m unsure how to fix it. I&#39;m not certain if this is the root cause of the issue. The warning is as follows:

```
VisualizeAnnotationsComponent.vue:139 Neo4j driver is configured to use a secure WebSocket on an HTTP web page. WebSockets might not work in a mixed content environment. Please consider configuring the driver to not use encryption.
```

Any insights or suggestions on how to address this warning would be greatly appreciated.

When I switched to paid Aura proffesional it fixed the problem any idea why ? ","1705263664","","","","https://stackoverflow.com/q/77816577","","","Question","NeoVis.js not displaying all relationships when connecting to AuraDB Neo4j instance","false","77816577","28",,,,,
"348",":User","","","","","Peter Plevko","","","","","","User","","false","12235082","",,,,,
"349",":Question","","0","The documentation of Neo4j says, i can set embedding as node property. All works fine when the embedding text is &lt; 3k limit of as i can embed all text in one go and set as Neo4j node property. 

Not sure, how the same can be be done, If i have to split the embedding text(because of token limit) and then generate multiple list of embedded values? 

Any examples or pointers, will be of greathelp.

Thanks,
","1705243438","","","","https://stackoverflow.com/q/77815472","","","Question","Embedding Larger token text (&gt; 3k) with Neo4j apoc.ml.vertexai.embedding","false","77815472","12",,,,,
"350",":User","","","","","nanda kumar gowda","","","","","","User","","false","5406600","",,,,,
"351",":Question","","0","I am testing the new Neo4j PARALLEL runtime and am unable to pass my tests because my queries return different results (different element order) compared to SLOTTED or PIPELINED. 

For example, in the following query, the result is dancing all of the time:

```
CYPHER runtime = parallel
MATCH (dg:DecisionGroup {
  id: -2
})-[rdgd: CONTAINS ]-&gt; ( childD:Profile )
MATCH (childD)-[mhvo:HAS_VOTE_ON]-(mc:Criterion)
WHERE mc.id IN [9760, 9761, 9757, 9758, 9759] + []
WITH childD , collect(mhvo) AS mhvos
WHERE size(mhvos) &gt;= size([9760, 9761, 9757, 9758, 9759])
WITH childD
WHERE (childD.`active` = true )
WITH childD
WITH childD
MATCH (childDStat:JobableStatistic {
  jobableId: childD.id
})
WITH childD, childDStat
UNWIND [9760, 9761, 9757, 9758, 9759] AS dCId
WITH childD, childDStat, dCId + coalesce({}[toString(dCId)], []) AS cGroup
WHERE NOT AlL(x IN cGroup
WHERE x IN childDStat.zeroCriterionIds )
WITH childD, childDStat, collect(cGroup) AS cGroups
WHERE size(cGroups) &gt;= size([9760, 9761, 9757, 9758, 9759])
UNWIND cGroups AS cGroup
WITH childD, childDStat, cGroup
WHERE ANY(x IN cGroup
WHERE x IN childDStat.detailedCriterionIds)
WITH childD, childDStat, collect(cGroup) AS cGroups
WHERE size(cGroups) &gt;= size([9760, 9761, 9757, 9758, 9759])
WITH childD, childDStat, size(cGroups) AS cGroupsSize, cGroups
UNWIND cGroups AS cGroup
WITH childD, childDStat, cGroups, cGroupsSize, cGroup
UNWIND cGroup AS cId
WITH childD, childDStat, cGroups, cGroupsSize, cGroup, cId, cGroup[0] AS cG0
WITH childD, childDStat, cGroups, cGroupsSize, cGroup, cId, cG0, {
  `9759`:1.0, `9758`:1.0, `9760`:1.0, `9761`:1.0, `9757`:1.0
}[toString(cG0)] AS criterionAvgVoteWeight, {
  `9759`:0, `9758`:0, `9760`:0, `9761`:0, `9757`:0
}[toString(cG0)] AS criterionExperienceMonth
WHERE (criterionAvgVoteWeight = 0 OR criterionAvgVoteWeight &lt;= childDStat[&#39;criterionAvgVoteWeights.&#39; + cId]) AND (criterionExperienceMonth = 0 OR criterionExperienceMonth &lt;= childDStat[&#39;criterionExperienceMonths.&#39; + cId])
WITH childD, childDStat, cGroups, cGroupsSize, collect(cId) AS cIds
UNWIND cGroups AS cGroup
WITH childD, childDStat, cGroup, cGroupsSize, cIds
WHERE ANY(x IN cIds
WHERE x IN cGroup)
WITH childD, childDStat, cGroupsSize, collect(cGroup) AS cGroups
WHERE size(cGroups) &gt;= cGroupsSize
WITH childD, childDStat
UNWIND [9760, 9761, 9757, 9758, 9759] AS cId
WITH childD, childDStat, cId, {
  `9759`:1.0, `9758`:1.0, `9760`:1.0, `9761`:1.0, `9757`:1.0
}[toString(cId)] AS criterionCoefficient
WITH childD, sum(criterionCoefficient * childDStat[&#39;criterionAvgVoteWeights.&#39; + cId]) AS weight, sum(childDStat[&#39;criterionTotalVotes.&#39; + cId]) AS totalVotes, sum(criterionCoefficient) AS criterionCoefficientSum
WITH childD, weight, totalVotes, criterionCoefficientSum
WITH collect({`childD`:childD , `weight`:weight, `totalVotes`: totalVotes }) AS aggregate
WITH aggregate, size(aggregate) AS count
UNWIND aggregate AS item
WITH count, item.childD AS childD , item.weight AS weight, item.totalVotes AS totalVotes
MATCH (dg:DecisionGroup {
  id: -2
})-[rdgd: CONTAINS ]-&gt;(childD)
OPTIONAL MATCH (childD)-[ru:CREATED_BY]-&gt;(u:User)
OPTIONAL MATCH (jobable:Decision:Vacancy {
  id: 4928
})
RETURN count, childD AS decision, dg, rdgd , u, ru , jobable.id AS jobableId , weight, totalVotes, [ (jobable)-[vg1:HAS_VOTE_ON]-&gt;(c1:Criterion) | {
  criterion: c1, relationship: vg1
} ] AS jobableWeightedCriteria, [(jobable)-[:HAS_VOTE_ON]-&gt;(c1:Criterion)&lt;-[vg1:HAS_VOTE_ON]-(childD)
WHERE c1.id IN childD.detailedCriterionIds | {
  criterion: c1, relationship: vg1
} ] AS weightedCriteria , [ (c1t:Translation:BaseEntity)&lt;-[rc1t: CONTAINS ]-(c1:Criterion)&lt;-[vg1:HAS_VOTE_ON]-(childD)
WHERE EXISTS ((jobable)-[:HAS_VOTE_ON]-&gt;(c1)) AND c1t.iso6391 = &#39;uk&#39; AND c1.id IN childD.detailedCriterionIds | {
  entityId: toInteger(c1.id), translation: c1t
} ] AS weightedCriteriaTranslations , [ (jobable)-[:WORK_LOCATED_IN|EMPLOYMENT_TYPE_AS|READY_TO|EMPLOYMENT_AS|WORK_TIME_ZONE|BELONGS_TO|LOCATED_IN|COMPANY|WORK_PERMIT_IN|COMPANY_TYPE_OF]-&gt;(ce:CompositeEntity) | {
  entity: ce
} ] AS jobableCompositeEntities, [ (childD)-[:WORK_LOCATED_IN|EMPLOYMENT_TYPE_AS|READY_TO|EMPLOYMENT_AS|WORK_TIME_ZONE|BELONGS_TO|LOCATED_IN|COMPANY|WORK_PERMIT_IN|COMPANY_TYPE_OF]-&gt;(ce:CompositeEntity) | {
  entity: ce
} ] AS decisionCompositeEntities, [ (childD)-[:WORK_LOCATED_IN|EMPLOYMENT_TYPE_AS|READY_TO|EMPLOYMENT_AS|WORK_TIME_ZONE|BELONGS_TO|LOCATED_IN|COMPANY|WORK_PERMIT_IN|COMPANY_TYPE_OF]-&gt;(ce:CompositeEntity)-[: CONTAINS ]-&gt;(trans:Translation:BaseEntity)
WHERE trans.iso6391 = &#39;uk&#39; | {
  entityId: toInteger(id(ce)), translation: trans
} ] AS decisionCompositeEntitiesTranslations, [ (childD)-[: CONTAINS ]-&gt;(trans:Translation:BaseEntity)
WHERE trans.iso6391 = &#39;uk&#39; | {
  entityId: toInteger(childD.id), translation: trans
} ] AS decisionTranslations, [ (rc:Criterion)-[*0]-&gt;()
WHERE rc.id IN childD.replaceableCriterionIds | {
  entity: rc
} ] AS decisionReplaceableCriteria, [ (rc:Criterion)-[: CONTAINS ]-&gt;(trans:Translation:BaseEntity)
WHERE rc.id IN childD.replaceableCriterionIds AND trans.iso6391 = &#39;uk&#39; | {
  entityId: toInteger(id(rc)), translation: trans
} ] AS decisionReplaceableCriteriaTranslations, COUNT {
  (:Vacancy:Jobable:BaseEntity {status: &#39;APPROVED&#39;, active: true
})&lt;-[:POTENTIAL_PROFILE]-(childD) } AS potentialJobablesCount , COUNT {
  (:Vacancy:Jobable:BaseEntity {status: &#39;APPROVED&#39;, active: true
})&lt;-[:RELEVANT_PROFILE]-(childD) } AS relevantJobablesCount 

ORDER BY weight DESC, childD.createdAt DESC SKIP 0
LIMIT 100
```

When executed multiple times, this query returns records in arbitrary order with varying weights. One time weight=25 is on the first place.. another time - weight=10 on the first place. What could be the cause of this?

With `CYPHER runtime = pipelined` this query is working fine.

I may be wrong, but it looks like the pattern comprehensive or COUNT subquery somehow affects the query ordering, specifically this part:

```
, [ (jobable)-[vg1:HAS_VOTE_ON]-&gt;(c1:Criterion) | {
  criterion: c1, relationship: vg1
} ] AS jobableWeightedCriteria, [(jobable)-[:HAS_VOTE_ON]-&gt;(c1:Criterion)&lt;-[vg1:HAS_VOTE_ON]-(childD)
WHERE c1.id IN childD.detailedCriterionIds | {
  criterion: c1, relationship: vg1
} ] AS weightedCriteria , [ (c1t:Translation:BaseEntity)&lt;-[rc1t: CONTAINS ]-(c1:Criterion)&lt;-[vg1:HAS_VOTE_ON]-(childD)
WHERE EXISTS ((jobable)-[:HAS_VOTE_ON]-&gt;(c1)) AND c1t.iso6391 = &#39;uk&#39; AND c1.id IN childD.detailedCriterionIds | {
  entityId: toInteger(c1.id), translation: c1t
} ] AS weightedCriteriaTranslations , [ (jobable)-[:WORK_LOCATED_IN|EMPLOYMENT_TYPE_AS|READY_TO|EMPLOYMENT_AS|WORK_TIME_ZONE|BELONGS_TO|LOCATED_IN|COMPANY|WORK_PERMIT_IN|COMPANY_TYPE_OF]-&gt;(ce:CompositeEntity) | {
  entity: ce
} ] AS jobableCompositeEntities, [ (childD)-[:WORK_LOCATED_IN|EMPLOYMENT_TYPE_AS|READY_TO|EMPLOYMENT_AS|WORK_TIME_ZONE|BELONGS_TO|LOCATED_IN|COMPANY|WORK_PERMIT_IN|COMPANY_TYPE_OF]-&gt;(ce:CompositeEntity) | {
  entity: ce
} ] AS decisionCompositeEntities, [ (childD)-[:WORK_LOCATED_IN|EMPLOYMENT_TYPE_AS|READY_TO|EMPLOYMENT_AS|WORK_TIME_ZONE|BELONGS_TO|LOCATED_IN|COMPANY|WORK_PERMIT_IN|COMPANY_TYPE_OF]-&gt;(ce:CompositeEntity)-[: CONTAINS ]-&gt;(trans:Translation:BaseEntity)
WHERE trans.iso6391 = &#39;uk&#39; | {
  entityId: toInteger(id(ce)), translation: trans
} ] AS decisionCompositeEntitiesTranslations, [ (childD)-[: CONTAINS ]-&gt;(trans:Translation:BaseEntity)
WHERE trans.iso6391 = &#39;uk&#39; | {
  entityId: toInteger(childD.id), translation: trans
} ] AS decisionTranslations, [ (rc:Criterion)-[*0]-&gt;()
WHERE rc.id IN childD.replaceableCriterionIds | {
  entity: rc
} ] AS decisionReplaceableCriteria, [ (rc:Criterion)-[: CONTAINS ]-&gt;(trans:Translation:BaseEntity)
WHERE rc.id IN childD.replaceableCriterionIds AND trans.iso6391 = &#39;uk&#39; | {
  entityId: toInteger(id(rc)), translation: trans
} ] AS decisionReplaceableCriteriaTranslations, COUNT {
  (:Vacancy:Jobable:BaseEntity {status: &#39;APPROVED&#39;, active: true
})&lt;-[:POTENTIAL_PROFILE]-(childD) } AS potentialJobablesCount , COUNT {
  (:Vacancy:Jobable:BaseEntity {status: &#39;APPROVED&#39;, active: true
})&lt;-[:RELEVANT_PROFILE]-(childD) } AS relevantJobablesCount 
```

How to make the query working correctly on Neo4j PARALLEL runtime?","1705232676","","","","https://stackoverflow.com/q/77814894","","","Question","Neo4j on PARALLEL runtime returns different results (different elements order) compared to SLOTTED or PIPELINED","false","77814894","34",,,,,
"352",":Question","77813285","1","I&#39;m really excited to try out the new feature in Neo4j with the Block store format https://neo4j.com/developer-blog/neo4j-graph-native-store-format/

Currently, I have a question regarding my automated integration tests. I use Docker with the Docker Maven plugin. Is it possible to instruct Neo4j Docker to automatically create a database with a Block format (instead of the Record format)? If so, could you please provide guidance on how to achieve this? Thanks!","1705163317","","","","https://stackoverflow.com/q/77812198","","","Question","Try Neo4j’s Next-Gen Graph-Native Store Format and Docker initialization","false","77812198","38",,,,,
"353",":Question","","1","I changed my oracle db to neo4J and I want to use `JpaSpecificationExecutor`, but it&#39;s not working for neo4j. Which packet do I have to use for specification filters? 

![enter image description here](https://i.stack.imgur.com/sanZo.png)","1705106590","","","","https://stackoverflow.com/q/77809929","","","Question","is there any api for neo4j like JpaSpecificationExecutor api?","false","77809929","36",,,,,
"354",":User","","","","","Dilan Yilmaz","","","","","","User","","false","13482307","",,,,,
"355",":Question","77808186","3","I have one Bipartite Graph made of users and document storing which client has read which record. 
I ran the following query which creates a graph and shows common docs read by users. Now I want to use results in the GDS algorithm to create clusters. 

I am not getting how to project results from the below query to GDS algorithm. I know I need to use graph projection. 
In projection we pass nodes and relationships but how to pass the result of this query?
    
```sql
MATCH (n1:ClientInfo)-[:ACCESSED]-&gt;()&lt;-[:ACCESSED]-(n2:ClientInfo) 
WITH n1, n2, count(*) AS commonDocs
WITH n1, n2, commonDocs, count{(n1)-[:ACCESSED]-&gt;()} AS n1Docs,
  count{(n2)-[:ACCESSED]-&gt;()} AS n2Docs
WHERE commonDocs &gt;=2
RETURN n1, n2, 
  apoc.create.vRelationship(n1, &#39;HAS_COMMON_DOCS&#39;, {commonDocs:commonDocs}, n2)
```

Below query not working for me 

```sql
MATCH (n1:ClientInfo)-[:ACCESSED]-&gt;()&lt;-[:ACCESSED]-(n2:ClientInfo)
WITH n1, n2, count(*) AS commonDocs
WITH n1, n2, commonDocs, count{(n1)-[:ACCESSED]-&gt;()} AS n1Docs,
  count{(n2)-[:ACCESSED]-&gt;()} AS n2Docs
WHERE commonDocs &gt;= 5 AND n1.peopleCode &lt;&gt; 310962818
WITH n1, n2,
  apoc.create.vRelationship(n1,&#39;HAS_COMMON_DOCS&#39;, {commonDocs:commonDocs}, n2)
CALL gds.graph.project(
       &#39;users&#39;,
       [&#39;ClientInfo&#39;, &#39;DocInfo&#39;],
       [&#39;ACCESSED&#39;,&#39;HAS_COMMON_DOCS&#39;]
     )
YIELD graphName AS graph, nodeProjection, nodeCount AS nodes, 
  relationshipProjection, relationshipCount AS rels;

","1705072616","","","","https://stackoverflow.com/q/77807565","","","Question","How to use result of cypher query output in GDS algorithm","false","77807565","72",,,,,
"356",":User","","","","","pbh","","","","","","User","","false","8713442","",,,,,
"357",":Question","","0","I&#39;m using py2neo in wsl and trying to connect to neo4j instance on Windows.

 

    from py2neo import Graph
    
    graph = Graph(&#39;bolt://localhost:7687&#39;, user=&quot;neo4j&quot;, password=&quot;12345678&quot;)

 the terminal returns with the error

&gt; Traceback (most recent call last):   File
&gt; &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/client/__init__.py&quot;,
&gt; line 806, in acquire
&gt;     cx = self._free_list.popleft() IndexError: pop from an empty deque
&gt; 
&gt; During handling of the above exception, another exception occurred:
&gt; 
&gt; Traceback (most recent call last):   File
&gt; &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/wiring.py&quot;,
&gt; line 62, in open
&gt;     s.connect(address) ConnectionRefusedError: [Errno 111] Connection refused
&gt; 
&gt; The above exception was the direct cause of the following exception:
&gt; 
&gt; Traceback (most recent call last):   File
&gt; &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/client/bolt.py&quot;,
&gt; line 355, in open
&gt;     wire = cls._connect(profile, on_broken=on_broken)   File &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/client/bolt.py&quot;,
&gt; line 369, in _connect
&gt;     wire = Wire.open(profile.address, keep_alive=True, on_broken=on_broken)   File
&gt; &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/wiring.py&quot;,
&gt; line 64, in open
&gt;     raise_from(WireError(&quot;Cannot connect to %r&quot; % (address,)), error)   File &quot;&lt;string&gt;&quot;, line 3, in raise_from py2neo.wiring.WireError: Cannot
&gt; connect to IPv4Address((&#39;localhost&#39;, 7687))
&gt; 
&gt; The above exception was the direct cause of the following exception:
&gt; 
&gt; Traceback (most recent call last):   File &quot;graph.py&quot;, line 3, in
&gt; &lt;module&gt;
&gt;     graph = Graph(&#39;bolt://localhost:7687&#39;, user=&quot;neo4j&quot;, password=&quot;12345678&quot;)   File
&gt; &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/database.py&quot;,
&gt; line 288, in __init__
&gt;     self.service = GraphService(profile, **settings)   File &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/database.py&quot;,
&gt; line 119, in __init__
&gt;     self._connector = Connector(profile, **connector_settings)   File &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/client/__init__.py&quot;,
&gt; line 960, in __init__
&gt;     self._add_pools(*self._initial_routers)   File &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/client/__init__.py&quot;,
&gt; line 982, in _add_pools
&gt;     pool = ConnectionPool.open(   File &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/client/__init__.py&quot;,
&gt; line 649, in open
&gt;     seeds = [pool.acquire() for _ in range(init_size or cls.default_init_size)]   File
&gt; &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/client/__init__.py&quot;,
&gt; line 649, in &lt;listcomp&gt;
&gt;     seeds = [pool.acquire() for _ in range(init_size or cls.default_init_size)]   File
&gt; &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/client/__init__.py&quot;,
&gt; line 813, in acquire
&gt;     cx = self._connect()   File &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/client/__init__.py&quot;,
&gt; line 764, in _connect
&gt;     cx = Connection.open(self.profile, user_agent=self.user_agent,   File
&gt; &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/client/__init__.py&quot;,
&gt; line 174, in open
&gt;     return Bolt.open(profile, user_agent=user_agent,   File &quot;/home/tranminhq420/.local/lib/python3.8/site-packages/py2neo/client/bolt.py&quot;,
&gt; line 364, in open
&gt;     raise_from(ConnectionUnavailable(&quot;Cannot open connection to %r&quot; % profile), error)   File &quot;&lt;string&gt;&quot;, line 3, in raise_from
&gt; py2neo.errors.ConnectionUnavailable: Cannot open connection to
&gt; ConnectionProfile(&#39;bolt://localhost:7687&#39;)

I have suspected there&#39;s a problem with the conf of neo4j and have tried to uncomment the line

    server.default_listen_address=0.0.0.0

to no avail. I have also tried to add the line

    dbms.connector.bolt.address=0.0.0.0:7687

but still can&#39;t get it to connect, here&#39;s my [conf][1] file, what should I do here


  [1]: https://anotepad.com/notes/bn8dg9dg","1704894498","","","","https://stackoverflow.com/q/77793850","","","Question","Can&#39;t connect to neo4j via py2neo","false","77793850","50",,,,,
"358",":User","","","","","Tran Minh Quan","","","","","","User","","false","16174416","",,,,,
"359",":Question","77788459","1","I need a cypher query that will match all paths of a certain length n that contain the specified nodes and specified edges. I developed a query, but I am getting a syntax error and I am not sure why, as I am new to cypher
```
MATCH (a, b)
WITH a, b
MATCH path = (a)-[*..n]-(b)
WHERE ALL(relName IN [&#39;relname1&#39;, &#39;relname2&#39;] 
   WHERE ANY(rel IN relationships(path) WHERE rel.display_name = relName)
AND a.name = &#39;node1name&#39; and b.name = &#39;node2name&#39;
RETURN path
```

The syntax error is 
```
Invalid input &#39;a&#39;: expected &quot;(&quot;, &quot;ALL&quot;, &quot;ANY&quot; or &quot;SHORTEST&quot; (line 1, column 8 (offset: 7))
&quot;MATCH (a, b)&quot;
        ^
```","1704818022","","","","https://stackoverflow.com/q/77788323","","","Question","Neo4j Cypher query for all paths that contain certain nodes and relations","false","77788323","43",,,,,
"360",":User","","","","","LizzAlice","","","","","","User","","false","7253302","",,,,,
"361",":Question","77779757","2","Graph has two types of nodes:
- Rule (has name attribute)
- Variable (has name attributes)

Has following relationships:
- Rule-[:depends_on]-&gt; Variable
- Rule-[:targets]-&gt; Variable


### Cypher Query to create sample graph

```
CREATE
  (rule1:Rule {name:&#39;rule_1&#39;}),
  (rule2:Rule {name:&#39;rule_2&#39;}),
  (rule3:Rule {name:&#39;rule_3&#39;}),
  (rule4:Rule {name:&#39;rule_4&#39;}),
  (variable1:Variable {name:&#39;variable_1&#39;}),
  (variable2:Variable {name:&#39;variable_2&#39;}),
  (variable3:Variable {name:&#39;variable_3&#39;}),
  (variable4:Variable {name:&#39;variable_4&#39;}),
  (variable5:Variable {name:&#39;variable_5&#39;}),
  (variable6:Variable {name:&#39;variable_6&#39;}),
  (variable7:Variable {name:&#39;variable_7&#39;}),
  (rule1)-[:targets]-&gt;(variable2),
  (rule1)-[:targets]-&gt;(variable3),
  (rule2)-[:targets]-&gt;(variable4),
  (rule2)-[:targets]-&gt;(variable5),
  (rule3)-[:targets]-&gt;(variable6),
  (rule3)-[:targets]-&gt;(variable7),
  (rule4)-[:targets]-&gt;(variable3),
  (rule1)-[:depends_on]-&gt;(variable1),
  (rule2)-[:depends_on]-&gt;(variable2),
  (rule3)-[:depends_on]-&gt;(variable3),
  (rule4)-[:depends_on]-&gt;(variable4)
```

### Query Requirement
Given a rule name recursively fetch all possible rule chains that can be triggered by it using a cypher query. That is, if Rule 1 is triggered then it would trigger Rule 2 (variable 2 is targeted by rule 1 and is dependency for rule 2) &amp; Rule 3 (variable 3 is targeted by rule 1 and is dependency for rule 3) and Rule 2 would trigger Rule 4 (variable 4 is targeted by rule 2 and is dependency for rule 4), which again can trigger Rule 3 (variable 3 is targeted by rule 4 and is dependency for rule 3).

#### Possible rule chain
```
Rule 1 -&gt; Rule 2 -&gt; Rule 4 -&gt; Rule 3
Rule 1 -&gt; Rule 3
```","1704703867","","","","https://stackoverflow.com/q/77778088","","","Question","How to fetch all nodes in neo4j for relationship (Node A)-[Relation A]-&gt;(Node B)-[Relation B]-&gt;(Node C)","false","77778088","99",,,,,
"362",":User","","","","","Higsn","","","","","","User","","false","8980538","",,,,,
"363",":Question","","0","I want to do linear programming optimisation in graph data base like Neo4j. 

I have a supply chain network with multiple sources and destinations and their cost of movement of goods between them. I want to minimise the gap between supply and demand of each nodes, finally for overall network. I can’t find an optimization algorithm in graph theory, Neo4j. I want to minimise an objective function in graph. 

Please help me.","1704546975","","","","https://stackoverflow.com/q/77769536","","","Question","Question about linear programming optimisation in graph data base like Neo4j","false","77769536","66",,,,,
"364",":User","","","","","BrianLe","","","","","","User","","false","23204991","",,,,,
"365",":Question","","1","I am using Spring JDBCTemplate to get the result from the Neo4j. 
I want &quot;ID&quot; of the node as well as the &quot;Labels&quot; which is present in the node but I only got the &quot;Properties&quot;.

This is the sample sql:

    MATCH path = (n:NodeABC)-[]-(i:NodeXYZ)
    WHERE n.name = &#39;iqwe&#39; 
    RETURN n as instance, relationships(path)

I want ID and Labels as well in the resultset. How to get it?

The tech stack is:

 - Neo4j - 5 
   
 - Java - 17
 - SpringBoot - 3.2


Thanks,

Atul","1704519950","","","","https://stackoverflow.com/q/77768358","","","Question","Neo4j - get ID, Labels properties from the resultset","false","77768358","33",,,,,
"366",":User","","","","","Atul","","","","","","User","","false","3948697","",,,,,
"367",":Question","77769042","1","i occure the problem while use terraform to deploy neo4j Helm chart. This raise the error like this: 

    Kubernetes cluster unreachable: exec plugin: invalid api version : &quot;client.authentication.k8s.io/v1a1pha1

This is my terraform provider:

    terraform {
      required_providers {
        kubectl = {
          source  = &quot;gavinbunney/kubectl&quot;
          version = &quot;1.10.1&quot;
        }
        helm = {
          source  = &quot;hashicorp/helm&quot;
          version = &quot;2.11.0&quot;
        }
      }
    }

This is my neo4j config-Im using neo4j-4.1.3-1:

    resource &quot;helm_release&quot; &quot;neo4j&quot; {
      name             = var.neo4j_release_name
      version          = var.neo4j_chart_version
      namespace        = var.neo4j_release_namespace
      chart            = &quot;https://github.com/neo4j-contrib/neo4j-helm/releases/download/4.1.3-1/neo4j-4.1.3-1.tgz&quot;
      create_namespace = true
    
      values = [
        templatefile(&quot;./${path.module}/values/neo4j-values.yaml.tmpl&quot;, local.neo4j_vars)
      ]
    }

My local kubectl 1.2.1, helm 3.0.3, Terraform v1.6.6. THis is my command run:
terraform plan -var-file=dev.values.tfvars -target=module.helm.helm_release.neo4j

Please help me!

","1704510614","","","","https://stackoverflow.com/q/77768125","","","Question","Terraform- Helm: Kubernetes cluster unreachable:exec plugin: invalid apiVersion &quot;client.authentication.k8s.io/v1alpha1&quot; while deploy neo4jHelm","false","77768125","41",,,,,
"368",":User","","","","","Itachi Uchiha","","","","","","User","","false","3935749","",,,,,
"369",":Question","77767414","1","I&#39;m trying to filter connections where a GrossMargin is bigger than 8000000. For this I&#39;m importing data like this:

    LOAD CSV WITH HEADERS FROM &#39;file:///output.csv&#39; AS row
    
    MERGE (s:SalesOwner {name: row.Owner})
    MERGE (c:Company {name: row.Company})
    MERGE (l:Leader {name: row.Leader})
    WITH s, c, toFloat(row.`Estimated Revenue`) AS revenue, toFloat(row.`Gross Margin I`) AS grossMargin
    
    // Create relationships between SalesOwners and Companies, handling duplicates
    
    MERGE (c)&lt;-[d:DEAL_WITH]-(s)
    ON CREATE SET d.GrossMargin = grossMargin, d.Revenue = revenue
    ON MATCH SET d.GrossMargin = grossMargin, d.Revenue = revenue
    MERGE (c)-[:HAS_LEADERSHIP]-&gt;(l)

Then I&#39;m visualizing with:

    MATCH (s:SalesOwner)-[d:DEAL_WITH]-&gt;(c:Company)
    WHERE d.GrossMargin &gt; 8000000
    RETURN s, d, c

My CSV looks like this:

    Owner,Company,Topic,Estimated Revenue,Gross Margin I,Leader
    Name1,Company1,Topic1,6142488.51,6142488.51,Name2
    Name1,Company1,Topic1,6142488.51,6142488.51,Name3
    Name1,Company1,Topic1,6142488.51,6142488.51,Name4
    Name1,Company1,Topic1,6142488.51,6142488.51,Name5
    Name1,Company1,Topic1,6142488.51,6142488.51,Name6
    Name1,Company1,Topic1,6142488.51,6142488.51,Name7
    Name8,Company1,Company2,51600000.0,51600000.0,Name9
    Name10,Company1,Company2,51600000.0,51600000.0,Name11
    ... etc

Yet, multiple connections that are SMALLER than 8000000 are still in the graph viz. How come?



","1704490758","","","","https://stackoverflow.com/q/77767333","","","Question","Neo4J WHERE cause not strict?","false","77767333","31",,,,,
"370",":User","","","","","lte__","","","","","","User","","false","2897989","",,,,,
"371",":Question","","0","I am trying to get results from gds.louvain.stream() by running it within apoc.cypher.runMany().  I am doing this because I want to create the GDS graph, get results from Louvain, and then delete the GDS graph all in the same query.  The following attempt using apoc.cypher.run is successful and I receive the nodes and their corresponding communities as expected:

```
CALL apoc.cypher.run(&quot;CALL gds.louvain.stream(&#39;community_detection&#39;) YIELD nodeId, communityId, intermediateCommunityIds RETURN gds.util.asNode(nodeId).categoryName AS category_name, gds.util.asNode(nodeId).productName AS product_name, communityId ORDER BY communityId DESC;&quot;, {});
```

However, when I try to do the same thing with apoc.cypher.runMany, nothing is returned:

```
CALL apoc.cypher.runMany(&quot;CALL gds.louvain.stream(&#39;community_detection&#39;) YIELD nodeId, communityId, intermediateCommunityIds RETURN gds.util.asNode(nodeId).categoryName AS category_name, gds.util.asNode(nodeId).productName AS product_name, communityId ORDER BY communityId DESC;&quot;, {});
```

Any idea what I am missing here? ","1704402694","","","","https://stackoverflow.com/q/77761231","","","Question","Calling Neo4J GDS Louvain algorithm using apoc.cypher.run versus apoc.cypher.runMany","false","77761231","25",,,,,
"372",":User","","","","","Braxvan","","","","","","User","","false","8929477","",,,,,
"373",":Question","77757853","1","Consider I have to obtain all the nodes in the subgraph of `n:Customer` with `customer_id = 4`. Starting from this node i have to traverse each node in the path originating with `n` and break or stop traversing down the path when a relationship with `Action` property is set to `ODC`. Each relationship has the property `Action` with value either `ODC` or `ODSN`.

[![enter image description here][1]][1]

After breaking from one path I have to check the other paths originating from this node `n`. I have to repeat this process till all paths are traversed and return the relevant nodes.
In the image I have provided I have expanded two paths out of the 14 nodes connected to `n:Customer` (blue node). Each of the purple nodes connected to the blue can be further expanded similar to the other two paths.

I am required to store these nodes in a data structure in Java.
Any guidance on how to approach this would be very helpful. Thanks


  [1]: https://i.stack.imgur.com/dKllV.png","1704349255","","","","https://stackoverflow.com/q/77756246","","","Question","In Neo4j how do i iteratively traverse the nodes and relationships paths obtained from the startnode till particular relationship property is reached?","false","77756246","64",,,,,
"374",":Question","","0","I&#39;m trying to query an `igraph` graph in python as I would do in Neo4j to find all the sets of nodes that match a given pattern. I have read through the documentation, searched for answers here, and interrogated Google with no luck.

Assuming that I have the following:

    import pandas as pd
    from igraph import Graph

    df = pd.DataFrame({
        &quot;Person&quot;: [&quot;P1&quot;, &quot;P1&quot;, &quot;P1&quot;, &quot;P1&quot;, &quot;P2&quot;, &quot;P2&quot;, &quot;P2&quot;, &quot;P3&quot;, &quot;P3&quot;, &quot;P4&quot;],
        &quot;Object&quot;: [&quot;O1&quot;, &quot;O2&quot;, &quot;O3&quot;, &quot;O6&quot;, &quot;O2&quot;, &quot;O3&quot;, &quot;O4&quot;, &quot;O5&quot;, &quot;O6&quot;, &quot;O6&quot;],
        &quot;relation&quot;: [&quot;LIKES&quot;] * 10,
    })
    g = Graph.DataFrame(df, directed=False)

I&#39;d like to run a query against `g` to return all px:Person, py:Person, ox:Object, and oy:Object such that _&quot;px likes ox, which is also liked by py, which also likes oy AND px != py, ox != oy, (px, oy) not in df_.

Expected results would include:

    P1, O2, P2, O4
    P2, O2, P1, O1
    P2, O2, P1, O6
    P2, O3, P1, O1
    P2, O3, P1, O6
    P4, O6, P1, O1
    P4, O6, P1, O2
    P4, O6, P1, O3
    P4, O6, P3, O5

but not:

    P1, O2, P2, O3    because P1, O3 are already connected
    P2, O3, P1, O2    because P2, O2 are already connected


In Neo4j, I&#39;d have run something like:

    MATCH (p1:Person)-[:LIKES]-&gt;(o1:Object)&lt;-[:LIKES]-(p2:Person)-[:LIKES]-&gt;(o2:Object)
    WHERE p1 &lt;&gt; p2 AND o1 &lt;&gt; o2 AND NOT (p1)-[:LIKES]-(o2)
    RETURN p1, o1, p2, o2
    LIMIT 4 

    MATCH (p1:Person)-[:LIKES]-&gt;(o1:Object)&lt;-[:LIKES]-(p2:Person)-[:LIKES]-&gt;(o2:Object) WHERE NOT (p1)-[:LIKES]-&gt;(o2) RETURN ....

Notice that my input files are quite big (~75k rows) and I would like to find all the possible `(p1, o1, p2, o2)` and of course not `LIMIT 4`. I&#39;ve tried to join my dataframe twice to create a result dataframe to further filter, but it gets very slow or too big to fit in memory.

I was wondering if there is a way to run such a query in `igraph`, or if I have to break it down into parts and combine the results myself. Thanks in advance for any help!","1704304571","","","","https://stackoverflow.com/q/77753801","","","Question","Query Python&#39;s iGraph as if it would be a Neo4j DB","false","77753801","33",,,,,
"375",":User","","","","","Stefano Bragaglia","","","","","","User","","false","1786165","",,,,,
"376",":Question","","1","I am doing a project in which I am required to return the path or nodes in a path from a particular start node. I pass the start node to the query, and need to continue down the path until the value of the relationship property `Action` between two consecutive nodes is &quot;ODC&quot;. Or, if the `Action` value is &quot;ODSN&quot;, I have to break from the particular path and return the next node alone separately. I am required to process all the paths from a particular start node in this manner.

I tried using the `apoc.path.subgraphAll` procedure but did not get the desired result:

    MATCH (c:Customer {customer_id: 4})
    CALL apoc.path.subgraphAll(c, {
    relationshipFilter: &quot;&gt;&quot;,
    minLevel: 1
    })
    YIELD nodes, relationships
    UNWIND relationships as rel
    WITH nodes, rel
    WHERE rel.Action = &#39;ODC&#39;
    RETURN DISTINCT nodes

Is there another method to approach this or should I be using another APOC procedure?
","1704184763","","","","https://stackoverflow.com/q/77744940","","","Question","How to use apoc.path.subgraphAll procedure in Neo4j","false","77744940","47",,,,,
"377",":Question","","0","Initial situation
-----------------
We are currently facing the challenge of migrating our applications to Spring Boot 3.x across the entire enterprise. Due to the intensive use of Spring Data Neo4j (SDN), a migration to SDN 7.2.1 must be carried out implicitly beforehand, in which the Object Graph Mapper (OGM) is omitted in favor of a renewed Spring Data Neo4j. See https://docs.spring.io/spring-data/neo4j/reference/appendix/migrating.html

Problem
-------
The equally intensively used Spring Batch Framework (spring-boot-starter-batch, 2.7.18) still requires a `SessionFactory` of the Neo4j Object Graph Mapper for the `Neo4jItemReader` and `Neo4jItemWriter`, which, however, no longer exists as intended. 

A manually created `CustomNeo4jItemReader` and `CustomNeo4jItemWriter`, in which the previous OGM session (`org.neo4j.ogm.session.Session`) is replaced by direct access to the Neo4j driver, does not work either, as this new driver session (`org.neo4j.driver.Session`) lacks many of the methods used by Spring Batch.

Target situation
----------------
How can we use Spring Batch and Neo4j with **Spring Data Neo4j 7.2.1 and higher** and thus follow the Spring Release Train?

Versions
--------
 - Spring Boot from version 2.7.18
 - [Spring Data Neo4j (SDN) from version 7.2.1](https://docs.spring.io/spring-data/neo4j/reference/appendix/migrating.html)
 - Spring Batch 2.7.18 (bundled version of Spring Boot)
 - [Spring Batch Extensions](https://github.com/spring-projects/spring-batch-extensions/tree/main/spring-batch-neo4j)
","1704166552","","","","https://stackoverflow.com/q/77744069","","","Question","Spring Batch still compatible and usable with Spring Data Neo4j (&gt;= 7.2.1)?","false","77744069","114",,,,,
"378",":User","","","","","ThirstForKnowledge","","","","","","User","","false","10287036","",,,,,
"379",":Question","","1","I am using Neo4j from Java.The program logic contains running of multiple and manipulating the obtained data to further execute queries against the database.How do I properly include them in a transaction and rollback in case of errors?","1703850095","","","","https://stackoverflow.com/q/77731783","","","Question","Are transactions In Neo4j default or should I manually handle it.I am using Neo4j from Java using the neo4j driver.How should i manage transactions?","false","77731783","21",,,,,
"380",":Question","","0","I am running queries on neo4j db using python and it is failing. 

Running queries on neo4j using python code are failing. I am getting this error:

&gt; {code: Neo.TransientError.Transaction.BookmarkTimeout} {message: Database &#39;neo4j&#39; not up to the requested version: 96025349. Latest database version is 96025343}. 

How to resolve this error? I am using neo4j library. ","1703790652","","","","https://stackoverflow.com/q/77728734","","","Question","Database &#39;neo4j&#39; not up to the requested version","false","77728734","52",,,,,
"381",":User","","","","","Utkarsh Baranwal","","","","","","User","","false","23169479","",,,,,
"382",":Question","","0","I am trying to read and load a parquet file data to neo4j, below is the schema of my parquet file:
```
root
 |-- globalcustid: string (nullable = true)
 |-- member_node: struct (nullable = false)
 |    |-- label: string (nullable = false)
 |    |-- properties: array (nullable = false)
 |    |    |-- element: struct (containsNull = false)
 |    |    |    |-- key: string (nullable = false)
 |    |    |    |-- value: string (nullable = true)
 |-- relationships: array (nullable = false)
 |    |-- element: struct (containsNull = false)
 |    |    |-- node: struct (nullable = false)
 |    |    |    |-- label: string (nullable = true)
 |    |    |    |-- properties: array (nullable = false)
 |    |    |    |    |-- element: struct (containsNull = false)
 |    |    |    |    |    |-- key: string (nullable = false)
 |    |    |    |    |    |-- value: string (nullable = true)
 |    |    |-- relationship: struct (nullable = false)
 |    |    |    |-- label: string (nullable = false)
 |    |    |    |-- properties: array (nullable = false)
 |    |    |    |    |-- element: struct (containsNull = false)
 |    |    |    |    |    |-- key: string (nullable = false)
 |    |    |    |    |    |-- value: string (nullable = true)
```

Here is one row of my parquet data (displayed in json format for better readability):
```
{
	&quot;globalcustid&quot;: &quot;12345&quot;,
	&quot;member_node&quot;: {
		&quot;label&quot;: &quot;MEMBER&quot;,
		&quot;properties&quot;: [
			{
				&quot;key&quot;: &quot;age&quot;,
				&quot;value&quot;: &quot;45&quot;
			},
			{
				&quot;key&quot;: &quot;gender&quot;,
				&quot;value&quot;: &quot;Male&quot;
			}
		]
	}
	&quot;relationships&quot;: [
		{
			&quot;relationship&quot;: {
				&quot;label&quot;: &quot;LIVE_IN&quot;,
				&quot;properties&quot;: [
					{
						&quot;key&quot;: &quot;createdate&quot;,
						&quot;value&quot;: &quot;2023-11-22&quot;
						},
					{
						&quot;key&quot;: &quot;enddate&quot;,
						&quot;value&quot;: &quot;9999-12-31&quot;
					}
				]
			},
			&quot;node&quot;: {
				&quot;label&quot;: &quot;COUNTRY&quot;,
				&quot;properties&quot;: [
					{
						&quot;key&quot;: &quot;country_id&quot;,
						&quot;value&quot;: &quot;c123&quot;
					},
					{
						&quot;key&quot;: &quot;country_name&quot;,
						&quot;value&quot;: &quot;us&quot;
					}
				]
			}
		}
	]
}
```

And here is my cypher script to load the file:
```
call apoc.load.parquet(
    &#39;part-00000-183a44db-1c2a-4e98-9db2-6aefaa419751-c000.snappy.parquet&#39;,
    {
        batchSize: 50000,
        mapping: {
                globalcustid: &#39;Varchar&#39;, member_node: &#39;MAP&#39;, relationships: &#39;LIST&#39;
        }
    }
) yield value as row

return *
```

However, it returned the following error. But the key values are unique in the properties array.
```
Failed to invoke procedure `apoc.load.parquet`: Caused by: java.lang.RuntimeException: Multiple element with the same key found, but the element type is not a list
```","1703754529","","","","https://stackoverflow.com/q/77725935","","","Question","Neo4j to load parquet file: Multiple element with the same key found, but the element type is not a list","false","77725935","31",,,,,
"383",":User","","","","","Kevin Lee","","","","","","User","","false","6086295","",,,,,
"384",":Question","","1","Getting this error while starting the neo4j docker, I am on linux server

    

&gt; ERROR Failed to start Neo4j on 0.0.0.0:7474.
java.lang.RuntimeException: Error starting Neo4j database server at /data/databases
	at org.neo4j.graphdb.facade.DatabaseManagementServiceFactory.startDatabaseServer(DatabaseManagementServiceFactory.java:255) ~[neo4j-5.2.0.jar:5.2.0]
	at org.neo4j.graphdb.facade.DatabaseManagementServiceFactory.build(DatabaseManagementServiceFactory.java:193) ~[neo4j-5.2.0.jar:5.2.0]
	at org.neo4j.server.CommunityBootstrapper.createNeo(CommunityBootstrapper.java:36) ~[neo4j-5.2.0.jar:5.2.0]
	at org.neo4j.server.NeoBootstrapper.start(NeoBootstrapper.java:164) ~[neo4j-5.2.0.jar:5.2.0]
	at org.neo4j.server.NeoBootstrapper.start(NeoBootstrapper.java:85) ~[neo4j-5.2.0.jar:5.2.0]
	at org.neo4j.server.CommunityEntryPoint.main(CommunityEntryPoint.java:30) ~[neo4j-5.2.0.jar:5.2.0]
Caused by: org.neo4j.kernel.lifecycle.LifecycleException: Component &#39;org.neo4j.procedure.impl.GlobalProceduresRegistry@2fd954f&#39; was successfully initialized, but failed to start. Please see the attached cause exception &quot;Unable to register procedure, because the name `apoc.atomic.add` is already in use.&quot;.
	at org.neo4j.kernel.lifecycle.LifeSupport$LifecycleInstance.start(LifeSupport.java:370) ~[neo4j-common-5.2.0.jar:5.2.0]
	at org.neo4j.kernel.lifecycle.LifeSupport.start(LifeSupport.java:92) ~[neo4j-common-5.2.0.jar:5.2.0]
	at org.neo4j.graphdb.facade.DatabaseManagementServiceFactory.startDatabaseServer(DatabaseManagementServiceFactory.java:246) ~[neo4j-5.2.0.jar:5.2.0]
	... 5 more
Caused by: org.neo4j.internal.kernel.api.exceptions.ProcedureException: Unable to register procedure, because the name `apoc.atomic.add` is already in use.
	at org.neo4j.procedure.impl.ProcedureRegistry.register(ProcedureRegistry.java:84) ~[neo4j-procedure-5.2.0.jar:5.2.0]
	at org.neo4j.procedure.impl.GlobalProceduresRegistry.register(GlobalProceduresRegistry.java:145) ~[neo4j-procedure-5.2.0.jar:5.2.0]
	at org.neo4j.procedure.impl.GlobalProceduresRegistry.register(GlobalProceduresRegistry.java:89) ~[neo4j-procedure-5.2.0.jar:5.2.0]
	at org.neo4j.procedure.impl.GlobalProceduresRegistry.start(GlobalProceduresRegistry.java:340) ~[neo4j-procedure-5.2.0.jar:5.2.0]
	at org.neo4j.kernel.lifecycle.LifeSupport$LifecycleInstance.start(LifeSupport.java:353) ~[neo4j-common-5.2.0.jar:5.2.0]
	at org.neo4j.kernel.lifecycle.LifeSupport.start(LifeSupport.java:92) ~[neo4j-common-5.2.0.jar:5.2.0]
	at org.neo4j.graphdb.facade.DatabaseManagementServiceFactory.startDatabaseServer(DatabaseManagementServiceFactory.java:246) ~[neo4j-5.2.0.jar:5.2.0]
	... 5 more","1703745474","","","","https://stackoverflow.com/q/77725349","","","Question","Neo4j not able to start using apoc plugin","false","77725349","19",,,,,
"385",":User","","","","","DILIP KUMAR","","","","","","User","","false","11772551","",,,,,
"386",":Question","","0","I&#39;ve been trying to setup Neo4j in my existing Rails project which has Rails version 5.2.8.1 and Ruby 2.7.7

I&#39;ve gone through almost every documentation i could find and had long chats with ChatGPT but nothing has worked so far.

I&#39;m trying to run Neo4j with Docker.

My docker-compose file is as follows:

```
version: &#39;3.8&#39;

services:
  neo4j:
    image: neo4j
    ports:
      - 7474:7474
      - 7687:7687
    environment:
      - NEO4J_AUTH=neo4j/password
      - NEO4J_dbms_memory_pagecache_size=512m
    volumes:
      - ./neo4j/data:/data
      - ./neo4j/logs:/logs
```

I&#39;ve tried various combinations of settings with neo4j.yml, neo4j.conf and application.rb
Nothing has worked unfortunately.

If anyone can help me with steps to setup even a new Rails app with ruby 2.7.7 and with any recent version of Neo4j, that&#39;ll be immensely helpful !!

Docker works. I can run graph database and run cypher queries in the browser. But from rails, it doesn&#39;t work.

The most i could get to was being able to run a MATCH query but when it came to creating nodes or running neo4j:migrate command, it didn&#39;t work at all.","1703738819","","","","https://stackoverflow.com/q/77725052","","","Question","How to setup Ruby on Rails with Neo4j database on Macbook M1? Ruby 2.7.7 and Rails 5.2.8.1","false","77725052","15",,,,,
"387",":User","","","","","Vishnu Narang","","","","","","User","","false","1484384","",,,,,
"388",":Question","","1","I need to access remotely to Neo4j running on a Docker container using the server&#39;s public IP address, but when I configure the IP address via parameters, the connection through http via 7474 port fails and neo4j.log shows these exceptions:

```
org.neo4j.kernel.lifecycle.LifecycleException: Component &#39;org.neo4j.bolt.protocol.common.connector.netty.SocketNettyConnector@2548fc01&#39; was successfully initialized, but failed to start. Please see the attached cause exception &quot;bind(..) failed: Cannot assign requested address&quot;.
 
org.neo4j.configuration.helpers.PortBindException: An error occurred while trying to bind to the socket /&lt;server_public_IP&gt;:7687
 
io.netty.channel.unix.Errors$NativeIoException: bind(..) failed: Cannot assign requested address
```

The server is running on an AWS virtual server with these settings:

```
  Virtualization: amazon
Operating System: Ubuntu 22.04.3 LTS              
          Kernel: Linux 6.2.0-1017-aws
    Architecture: arm64
```

I am using the latest [docker image for neo4j 5.15.0](https://hub.docker.com/layers/library/neo4j/5.15.0/images/sha256-49209c959ae23185b7625d0f9185b59cb82269f2dfbeba266376afd1f55d4ed9?context=explore)

As instructed in the [Operations manual](https://neo4j.com/docs/operations-manual/current/docker/configuration/), and [this post](https://community.neo4j.com/t/remote-neo4j-server-port-7474-connection-refused/30058) the command I am using to create and run the container with the neo4j image is:

```
sudo docker run -d 
    --name=neo4jdocker \
    --restart always \
    --publish=7474:7474 --publish=7687:7687 \
    --env NEO4J_AUTH=neo4j/&lt;my password&gt; \
    --env NEO4J_server_memory_heap_initial__size=12288m \
    --env NEO4J_server_memory_heap_max__size=20480m \
    --env NEO4J_server_default__listen__address=0.0.0.0 \
    --env NEO4J_server_default__advertised_address=&lt;server_public_IP&gt; \
    --env NEO4J_server_bolt_enabled=true \
    --env NEO4J_server_bolt_tls__level=DISABLED \
    --env NEO4J_server_bolt_listen__address=0.0.0.0:7687 \
    --env NEO4J_server_bolt_advertised__address=&lt;server_public_IP&gt;:7687 \
    --env NEO4J_server_http_enabled=true \
    --env NEO4J_server_http_listen__address=0.0.0.0:7474 \
    --env NEO4J_server_http_advertised__address=&lt;server_public_IP&gt;:7474 \
    --env NEO4J_server_https_enabled=false \
    --volume=/home/ubuntu/path/data:/data \
    --volume=/home/ubuntu/path/import:/import \
    --volume=/home/ubuntu/path/logs:/logs \
    --volume=/home/ubuntu/path/plugins:/plugins \
    neo4j:5.15.0
```

Then the Neo4j finds something wrong and restarts each minute:

```
sudo docker ps
 
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS                          PORTS     NAMES
2a641248b8d9   neo4j:5.15.0   &quot;tini -g -- /startup…&quot;   About a minute ago   Restarting (1) 18 seconds ago             neo4jdocker
```


On the other hand, when I create the container without the public IP configuration settings, everything works as expected locally at the server machine:

```
sudo docker run -d \
    --name=neo4jdocker \
    --restart always \
    --publish=7474:7474 --publish=7687:7687 \
    --env NEO4J_AUTH=neo4j/&lt;my password&gt; \
    --env NEO4J_server_memory_heap_initial__size=12288m \
    --env NEO4J_server_memory_heap_max__size=20480m \
    --env NEO4J_server_default__listen__address=0.0.0.0 \
    --volume=/home/ubuntu/path/data:/data \
    --volume=/home/ubuntu/path/import:/import \
    --volume=/home/ubuntu/path/logs:/logs \
    --volume=/home/ubuntu/path/plugins:/plugins \
    neo4j:5.15.0
```

Docker reports everything ok:

```
sudo docker ps

CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                                                                                            NAMES
f5432bafedd5   neo4j:5.15.0   &quot;tini -g -- /startup…&quot;   34 minutes ago   Up 34 minutes   0.0.0.0:7474-&gt;7474/tcp, :::7474-&gt;7474/tcp, 7473/tcp, 0.0.0.0:7687-&gt;7687/tcp, :::7687-&gt;7687/tcp   neo4jdocker
```

I even have access to the web interface:

```
curl http://localhost:7474

{
  &quot;bolt_routing&quot; : &quot;neo4j://localhost:7687&quot;,
  &quot;transaction&quot; : &quot;http://localhost:7474/db/{databaseName}/tx&quot;,
  &quot;bolt_direct&quot; : &quot;bolt://localhost:7687&quot;,
 &quot;neo4j_version&quot; : &quot;5.15.0&quot;,

  &quot;neo4j_edition&quot; : &quot;community&quot;
}
```

And obviously the ports appear to be listened by the docker container:

```
sudo lsof -i -P -n
 
COMMAND       PID            USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
docker-pr 2179741            root    4u  IPv4 5668735      0t0  TCP *:7687 (LISTEN)
docker-pr 2179747            root    4u  IPv6 5667661      0t0  TCP *:7687 (LISTEN)
docker-pr 2179759            root    4u  IPv4 5670560      0t0  TCP *:7474 (LISTEN)
docker-pr 2179766            root    4u  IPv6 5669470      0t0  TCP *:7474 (LISTEN)
```

And neo4j.log shows expected messages:

```
2023-12-27 15:30:10.305+0000 INFO  Starting...
2023-12-27 15:30:11.033+0000 INFO  This instance is ServerId{57946358} (57946358-4700-4f22-bb6f-9bf3d5559522)
2023-12-27 15:30:11.614+0000 INFO  ======== Neo4j 5.15.0 ========
2023-12-27 15:30:12.773+0000 INFO  Bolt enabled on 0.0.0.0:7687. 
2023-12-27 15:30:13.346+0000 INFO  HTTP enabled on 0.0.0.0:7474.
2023-12-27 15:30:13.347+0000 INFO  Remote interface available at http://localhost:7474/
2023-12-27 15:30:13.349+0000 INFO  id: 0101D8AABC7A7290033198E46D8969889C893917A0BC961C751565FB9B130D40
2023-12-27 15:30:13.350+0000 INFO  name: system
2023-12-27 15:30:13.350+0000 INFO  creationDate: 2023-12-22T22:57:40.961Z
2023-12-27 15:30:13.350+0000 INFO  Started. 
```

Can you please help me to identify what I did wrong? What is missing?","1703697028","","","","https://stackoverflow.com/q/77723167","","","Question","Docker Neo4j 5.15.0 community error when using public IP address","false","77723167","36",,,,,
"389",":User","","","","","Andr&#233;s Meza-Escall&#243;n","","","","","","User","","false","888367","",,,,,
"390",":Question","","0","read my json files from google drive with python 
I want to transfer to neo4j database in aura db, how do I do it?



I have not done such a process before, I do not have any information, can you help?
I think there are a few methods, which method should I use and how do I use that method?","1703683499","","","","https://stackoverflow.com/q/77722165","","","Question","read my json files from google drive with python I want to transfer to neo4j database in aura db, how do I do it?","false","77722165","32",,,,,
"391",":User","","","","","gorkemkaratepe","","","","","","User","","false","23163447","",,,,,
"392",":Question","","1","I am trying to dockerize my springboot application with my Neo4j application.
This is my docker-compose.yml
```
version: &quot;3&quot;
services:
  myneo4j:
    image: neo4j:5.15.0
    container_name: &quot;myneo4j&quot;
    ports:
      - 7474:7474
      - 7687:7687
    restart: unless-stopped
    environment:
      - NEO4J_AUTH=neo4j/12345678
    volumes:
      - ./db/data:/data
      - ./db/conf:/conf
      - ./db/logs:/logs
      - ./db/plugins:/plugins
  springboot-neo4j:
    image: springboot-neo4j:1.0
    container_name: springboot-neo4j
    depends_on:
      - myneo4j
    ports:
      - 3002:3002
    links:
      - myneo4j
```

This is my application.properties:
```
spring.data.neo4j.uri=bolt://host.docker.internal:7687
spring.neo4j.authentication.username=neo4j
spring.neo4j.authentication.password=12345678

```

I already looked up past forums and the spring.data.neo4j.uri=bolt://host.docker.internal:7687 was the fix for most people except it doesn&#39;t work for me here.

myneo4j container works and runs. the springboot-neo4j container doesn&#39;t work. It gives me this error:
```
springboot-neo4j  | Caused by: org.neo4j.driver.v1.exceptions.ServiceUnavailableException: Unable to connect to localhost:7687, ensure the database is running and that there is a working network connection to it.
```

https://github.com/phammings/Music-Microservice-API
Here is my github if anyone would like to replicate my error. I am trying to dockerize my profile-microservice with absolute no luck

Thank you so much if anyone can let me know whats the fix here","1703657148","","","","https://stackoverflow.com/q/77720317","","","Question","How to dockerize springboot app with Neo4j","false","77720317","61",,,,,
"393",":User","","","","","Ryan Pham","","","","","","User","","false","19978679","",,,,,
"394",":Question","","1","I used to call
```
call apoc.export.json.all(&quot;backup.json&quot;,{useTypes:true})
```
to backup my database content on the one hand and now I&#39;m trying to migrate data to another machine on the other hand by exporting to json first and importing it afterwards.
```
call apoc.import.json(&quot;backup.json&quot;)
```
which should be a valid option according to [some neo4j developer](https://community.neo4j.com/t/unable-to-import-json-file-with-apoc-import-json/53199/2). However I run into an exception:
```
Failed to invoke procedure `apoc.import.json`: Caused by: java.lang.RuntimeException: Missing constraint required for import. Execute this query:
CREATE CONSTRAINT FOR (n:MyLabel01) REQUIRE n.neo4jImportId IS UNIQUE;
```
Even creating this requirement results in more and more errors of that type.

These error occur when I try to migrate my data from an older neo4j version / apoc version to a newer one, but also when I export from *neo4j kernel 5.12.0 enterprise* with apoc version 5.12.0 according to `return apoc.version()` and try to import in a fresh database of the same version where I exported the json.

So I tried to find some workaround and found 
```
CALL apoc.load.json(&quot;backup.json&quot;) yield value
WHERE value.type = &quot;node&quot;
CALL apoc.create.node(value.labels,value.properties)
yield node return node
```

but I could not figure out how to import the relashionships too.

* Is there (a different) standard way of porting database content to another machine?
* Or is there some option to utilize apoc.load.json(&quot;backup.json&quot;) and to create nodes and relationships?
","1703544108","","","","https://stackoverflow.com/q/77715125","","","Question","Migrating neo4j database content / apoc.import.json not working","false","77715125","27",,,,,
"395",":User","","","","","Necktschnagge","","","","","","User","","false","6346852","",,,,,
"396",":Question","77705741","3","I have a simple graph with nodes `bgc` and `protein`, where `(:bgc)-[:ENCODES]-&gt;(:protein)`. Proteins can be similar to each other, and that is represented with separate relationship, e.g. `(:protein)-[:MMSEQS_90]-&gt;(:protein)` (for 90% similarity, but can be also `MMSEQS_80`, `MMSEQS_70`, `MMSEQS_50`, etc.

For two `bgc` nodes graph can look like this: 

[![graph schema][1]][1]

Paths between `bgc` nodes can be direct (sharing the exact same `protein`) or indirect (through proteins that are similar).  

Now, I want to calculate similarity score between `bgc` nodes, which is defined as:

`score` = `100%  * pathsAll` / (`pathsAll + notCommon`) 
Where
- `pathsAll` is total number of paths, direct and indirect (1 + 2 = 3 in the example above)
- `notCommon` are nodes not shared by any paths (3 + 2 = 5) 
- `score` is similarity score: 100% * 3 / (3 + 5) = 37.5%

Score is calculated pair-wise for all `bgc` pairs, and saved as relation `(:bgc)-[:SIMILAR_TO {score: &lt;int&gt;})-(:bgc)`. 

I have managed to solve this exact problem with query as below: 

    MATCH (bgc1:bgc)-[:ENCODING]-&gt;(p1:protein)
    MATCH (bgc2:bgc)-[:ENCODING]-&gt;(p2:protein)
    WHERE elementId(bgc1) &lt; elementId(bgc2)
    
    OPTIONAL MATCH pathIndirect = (bgc1)-[:ENCODING]-&gt;(:protein)-[:MMSEQS_90*1..5]-(:protein)&lt;-[:ENCODING]-(bgc2)
    OPTIONAL MATCH pathDirect = (bgc1)-[:ENCODING]-&gt;(:protein)&lt;-[:ENCODING]-(bgc2)
    
    WITH bgc1, bgc2, COUNT(DISTINCT pathIndirect) + COUNT(DISTINCT pathDirect) AS pathsAll,
                  COUNT(DISTINCT p1) + COUNT(DISTINCT p2) - 2 * (COUNT(DISTINCT pathIndirect) + COUNT(DISTINCT pathDirect)) AS notCommon
    
    WITH bgc1, bgc2, 100 * pathsAll / (pathsAll + notCommon) AS similarity_score
    
    WITH bgc1, bgc2, similarity_score
    WHERE similarity_score &gt; 0.0  
    
    MERGE (bgc1)-[:IS_SIMILAR {score: similarity_score}]-&gt;(bgc2)
    RETURN bgc1.id AS BGC1, bgc2.id AS BGC2, similarity_score
    ORDER BY similarity_score DESC, BGC1, BGC2;

Resulting in: 

    ╒═══════╤═══════╤════════════════╕
    │BGC1   │BGC2   │similarity_score│
    ╞═══════╪═══════╪════════════════╡
    │&quot;BGC03&quot;│&quot;BGC01&quot;│83              │
    ├───────┼───────┼────────────────┤
    │&quot;BGC01&quot;│&quot;BGC02&quot;│37              │
    ├───────┼───────┼────────────────┤
    │&quot;BGC03&quot;│&quot;BGC02&quot;│25              │
    └───────┴───────┴────────────────┘

   
This however, is immediately crashing database (out of memory) for larger number of nodes (few 1000`s), making it impossible to execute (despite reasonable memory provisioning). 

I have noticed that first line can be executed instantly, but adding the second is already sufficient to cause crash (so maybe here is a first problem?): 

    // this executes instantly
    MATCH rs1=(bgc1:bgc)-[:ENCODING]-&gt;(p1:protein)
    RETURN rs1;
    // this goes forever and crashes
    MATCH rs1=(bgc1:bgc)-[:ENCODING]-&gt;(p1:protein)
    MATCH rs2=(bgc2:bgc)-[:ENCODING]-&gt;(p2:protein)
    RETURN rs1, rs2 

Thanks a lot for any suggestions on why is that crashing and how to construct better query doing the same thing. Maybe I&#39;m doing something totally wrong here - I am very new to Neo4j. 

Example data: 

    MERGE (b1:bgc {id: &#39;BGC01&#39;})
    MERGE (b2:bgc {id: &#39;BGC02&#39;})
    MERGE (b3:bgc {id: &#39;BGC03&#39;})
    MERGE (p1:protein {id: &#39;PROT01&#39;})
    MERGE (p2:protein {id: &#39;PROT02&#39;})
    MERGE (p3a:protein {id: &#39;PROT03a&#39;})
    MERGE (p3b:protein {id: &#39;PROT03b&#39;})
    MERGE (p4a:protein {id: &#39;PROT04a&#39;})
    MERGE (p4b:protein {id: &#39;PROT04b&#39;})
    MERGE (p5:protein {id: &#39;PROT05&#39;})
    MERGE (p6:protein {id: &#39;PROT06&#39;})
    MERGE (p7:protein {id: &#39;PROT07&#39;})
    MERGE (p8:protein {id: &#39;PROT08&#39;})
    MERGE (b1)-[:ENCODING]-&gt;(p1)
    MERGE (b1)-[:ENCODING]-&gt;(p2)
    MERGE (b1)-[:ENCODING]-&gt;(p3a)
    MERGE (b1)-[:ENCODING]-&gt;(p4a)
    MERGE (b1)-[:ENCODING]-&gt;(p5)
    MERGE (b1)-[:ENCODING]-&gt;(p6)
    MERGE (b2)-[:ENCODING]-&gt;(p2)
    MERGE (b2)-[:ENCODING]-&gt;(p3b)
    MERGE (b2)-[:ENCODING]-&gt;(p4b)
    MERGE (b2)-[:ENCODING]-&gt;(p7)
    MERGE (b2)-[:ENCODING]-&gt;(p8)
    MERGE (b3)-[:ENCODING]-&gt;(p1)
    MERGE (b3)-[:ENCODING]-&gt;(p2)
    MERGE (b3)-[:ENCODING]-&gt;(p5)
    MERGE (b3)-[:ENCODING]-&gt;(p6)
    MERGE (b3)-[:ENCODING]-&gt;(p4b)
    MERGE (p3a)-[:MMSEQS_90]-&gt;(p3b)
    MERGE (p4a)&lt;-[:MMSEQS_90]-(p4b)


  [1]: https://i.stack.imgur.com/zwfTP.png
","1703212269","","","","https://stackoverflow.com/q/77701440","","","Question","Neo4J: How to calculate similarity score based on number of existing paths?","false","77701440","74",,,,,
"397",":User","","","","","Art","","","","","","User","","false","1061924","",,,,,
"398",":Question","","1","I&#39;m not able to figure out why I can&#39;t stream the results like this:

```
try (var session = driver.session()) {
  var maybeRecord = session.executeRead(tx -&gt; tx.run(&quot;MATCH (c:Category { id:$id }) RETURN c&quot;, parameters(&quot;bggId&quot;, id))) //
					.stream() //
					.findFirst();
}
```

When I do this, I get an error:

```
org.neo4j.driver.exceptions.ClientException: org.neo4j.driver.Result is not a valid return value, it should be consumed before producing a return value
```

I understand what that error means, and I can change my code to do the whole  `while (results.hasNext()) { }` business, but it&#39;s very verbose. Is there a way I can do it similar to streaming while keeping within the bounds of consuming the Result?","1703110694","","","","https://stackoverflow.com/q/77694771","","","Question","Why can&#39;t I stream transaction results from Neo4J Bolt Driver","false","77694771","30",,,,,
"399",":User","","","","","Gregg","","","","","","User","","false","261159","",,,,,
"400",":Question","","1","I have an aks cluster with two neo4j database images (db-1 and db-2) in it, services for those. Using nginx ingress controller, I want to route the user to a particular database based on the url he requests for example if user wants to go to db-1, my neo4j url will be ```http://&lt;external-ip&gt;/db1```

I want to use an internal IP, and have my aks cluster linked to it.

I have used the following steps to create the databases, and nginx controller. Yet my databases are not being connected. Neo4j says ```Service Unavailable```

```helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx```

```helm repo update```

```helm install ingress-nginx ingress-nginx/ingress-nginx --create-namespace  --namespace ingress-test  --set controller.service.annotations.&quot;service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path&quot;=/healthz  --set-string controller.service.annotations.&quot;service\.beta\.kubernetes\.io/azure-load-balancer-internal&quot;=&quot;true&quot; --tcp-services-configmap=ingress-test/tcp-services```

Applying the below yaml ```kubectl apply -f ingress.yaml ```

```apiVersion: apps/v1
kind: Deployment
metadata:
  name: aks-neo4j-one  
spec:
  replicas: 1
  selector:
    matchLabels:
      app: aks-neo4j-one
  template:
    metadata:
      labels:
        app: aks-neo4j-one
    spec:
      containers:  
      - name: neo4j  
        image: neo4j:latest 
        env:      
           - name: NEO4J_AUTH       
             value: neo4j/&lt;mypassword&gt;      
        ports:  
        - containerPort: 7474  
          name: http
        - containerPort: 7687  
          name: tcp
        
---
apiVersion: v1
kind: Service
metadata:
  name: aks-neo4j-one  
spec:
  type: ClusterIP
  ports:  
    - protocol: TCP  
      port: 80  
      targetPort: 7687 
  selector:
    app: aks-neo4j-one
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: neo4j-ingress  
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /neo4jone
        pathType: Prefix
        backend:
          service:
            name: aks-neo4j-one
            port:
              number: 80
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: tcp-services
  namespace: ingress-test
data:
  7687: &quot;ingress-test/aks-neo4j-one:80&quot;
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ingress-nginx-controller
  namespace: ingress-test
spec:
  template:
    spec:
      containers:
      - name: controller
        args:
          - /nginx-ingress-controller
          - --tcp-services-configmap=ingress-test/tcp-services
```
Did try it with and without config map as well as neo4j requires 7687 bolt port

Changing the services port to 7474, and browsing the External IP leads to a popup of username and password, and doesn&#39;t proceed for any inputs.
","1703046851","","","","https://stackoverflow.com/q/77689238","","","Question","Unable to access specific neo4j database exposed using AKS","false","77689238","94",,,,,
"401",":User","","","","","spd","","","","","","User","","false","17778275","",,,,,
"402",":Question","","0","I have a question about how to deal with Neo4j queries that are slow and then crash.

First of all, let me explain the graphs.
There are 20million nodes called &quot;Party&quot;. Each Party node has properties &quot;id&quot; and &quot;type&quot;. Each Party is connected to one or more &quot;Account&quot; nodes by a relationship called &quot;HAS&quot;, with a total number of Accounts of 70million.
The relationships between Accounts are connected by a relationship called &quot;TRANSACTION&quot;, with a total number of 350million.
TRANSACTION has the properties &quot;timestamp&quot;, &quot;price&quot;.

Now, to calculate the impact of a Party whose type property is on (say P1) on a Party 2hop away (a Party whose type property is off, say P3), the following two-stage query is performed.

```
CALL apoc.periodic.iterate(&quot;

// P1-A1-A2
MATCH (P1:Party{type:&#39;on&#39;})-[:HAS]-(A1:Account)-[t1:TRANSACTION]-(A2:Account)&lt;-[:HAS]-(P2:Party{type:&#39;off&#39;})
     CASE
         WHEN datetime(t1.timestamp) &gt;= datetime(reference_date) THEN 4

...（Sorry, it&#39;s too long to write, but there is a complex case split that depends on values of t1.timestamp and t1.price.）

// A2-A3-P3
MATCH (A2)-[t2:TRANSACTION]-(A3:Account)&lt;-[:HAS]-(P3:Party{type:&#39;off&#39;})
     CASE
         WHEN datetime(t2.timestamp) &gt;= datetime(reference_date) THEN 4

...（This one also has a complex case split depending on the values of t2.timestamp and t2.price. Finally, the value of score is calculated.）

RETURN
     P3.id, score
  &quot;CREATE (temp:TempResult {id: id, score: score})&quot;,
  {batchSize:100, parallel:true}
)
```

The CPU usage is running at around 30% at the beginning of the calculation, but finally the CPU usage reaches 100% and the operation becomes very slow. Eventually, the connection to the Neo4j Browser database is broken down.

What do you think is the reason for the disconnection from the database?
1. Is it because the 2hop algorithm is inefficient? (Does it use a lot of memory? Or do you get a lot of disk accesses?)
2. It is said that indexes make queries work more efficiently, but it is not well understood how they should be created.
3. Is the size of the batch process processed at one time not appropriate? (batchSize:100)
4. Are there not enough machine specs? Also, I am not sure that the appropriate values for heap and cache settings.

The server and Neo4j specifications are as follows.

Server  

 - OS: Windows Server 2019  
 - CPU: Intel Xeon Platinum 2.90GHz 4core
 - Memory: 512GB 
 - HDD: 1TB

Neo4j
 - Version: Enterprise v5.12.0
 - server.memory.heap.initial_size=240g
 - server.memory.heap.max_size=240g
 - server.memory.pagecache.size=240g
 - dbms.memory.transaction.total.max=400G
 - db.transaction.timeout=1440m

I would be very grateful for any advice from any knowledgeable person. Any information would be much appreciated. 
Thank you in advance for your kind attention.

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/muzbl.png","1702979468","","","","https://stackoverflow.com/q/77684255","","","Question","About crashing during a 2hop query operation in Neo4j","false","77684255","46",,,,,
"403",":User","","","","","newbie","","","","","","User","","false","21351077","",,,,,
"404",":Question","","1","I am using neo4j to load a json file which is 103 MB worth.  It has only 6500 records though.

I created a apoc.config in the right Configuration location and added the property:
```
apoc.import.file.enabled=true
```

I placed the file in dbmss/&lt;dbms_id&gt;/import/&lt;client_name&gt;/data_dump/&lt;file_name.json&gt;.  I am able to apoc procedure using:
```
CALL apoc.load.json(&quot;file:///&lt;client_name&gt;/data_dump/&lt;file_name.json&gt;&quot;)
YIELD value
RETURN value; 
```
However, after ~1 mins 50 seconds, the process stops with a blank browser page.

[![Neo4j Browser error][1]][1]  


The following error is shown in the console.

```
[14:07:54.869] [info]  Neo4j @ 7687 is up and running!
[14:07:54.885] [info]  Neo4j @ 7474 is up and running!






Error sending from webFrameMain:  Error: Render frame was disposed before WebFrameMain could be accessed
    at n.send (node:electron/js2c/browser_init:165:417)
    at b.send (node:electron/js2c/browser_init:161:2494)
    at send (/tmp/.mount_neo4j-WfMZ7l/resources/app.asar/dist/main.prod.js:6062:13)
    at /tmp/.mount_neo4j-WfMZ7l/resources/app.asar/dist/main.prod.js:6066:63
    at Array.forEach (&lt;anonymous&gt;)
    at broadcast (/tmp/.mount_neo4j-WfMZ7l/resources/app.asar/dist/main.prod.js:6066:48)
    at Timeout.onlineCheck [as _onTimeout] (/tmp/.mount_neo4j-WfMZ7l/resources/app.asar/dist/main.prod.js:13066:38)
    at process.processTicksAndRejections (node:internal/process/task_queues:96:5)
```

I googled somewhere and added:
```
apoc.http.timeout.connect=600000
apoc.http.timeout.read=600000
```

No change.  Still errors out around 1 min 50 seconds.  Not sure what this config is.  It is consistently reproducable.

This happens on all of Ubuntu VM, Ubuntu standalone system and Windows.  Doesn&#39;t look like a display issue.  Please help.

  [1]: https://i.stack.imgur.com/5ruSQ.jpg","1702976317","","","","https://stackoverflow.com/q/77683954","","","Question","Neo4j Browser blank screen with error when loading json using apoc.load.json","false","77683954","35",,,,,
"405",":User","","","","","Mahesh","","","","","","User","","false","1071179","",,,,,
"406",":Question","","1","This is the structure of my schema 
```
type Process @query(read: true, aggregate: true) {
  material_id: String
  batch_id: String
  basic_mat: String
  happened: Date
}
```

Now, querying process returns an empty array 
```
query Processes($where: ProcessWhere) {
  processes(where: $where) {
    basic_mat
    material_id
    batch_id
  }
}
```
This is the variable where
```
{ 
  &quot;where&quot;: {
    &quot;batch_id&quot;: &quot;abc101&quot;
  }
}
```
I went further to enable debug and this is what I get
```
  @neo4j/graphql:auth using JWT provided in context: undefined +0ms
  @neo4j/graphql:execution executing cypher +0ms
  @neo4j/graphql:execution CALL dbms.components() YIELD versions, edition UNWIND versions AS version RETURN version, edition +1ms
  @neo4j/graphql:execution cypher params: {} +0ms
  @neo4j/graphql:translate ReadOperation
  @neo4j/graphql:translate |──── PropertyFilter [batch_id] &lt;EQ&gt;
  @neo4j/graphql:translate |──── AttributeField &lt;basic_mat&gt;
  @neo4j/graphql:translate |──── AttributeField &lt;material_id&gt;
  @neo4j/graphql:translate |──── AttributeField &lt;batch_id&gt; +0ms
  @neo4j/graphql:execution executing cypher +655ms
  @neo4j/graphql:execution MATCH (this:Process)
  @neo4j/graphql:execution WHERE this.batch_id = $param0
  @neo4j/graphql:execution RETURN this { .basic_mat, .material_id, .batch_id } AS this +0ms
  @neo4j/graphql:execution cypher params: { param0: &#39;abc101&#39; } +0ms
  @neo4j/graphql:execution Execute successful, received 0 records +0ms
```
running this cypher in neo4j returns values but not when I am using the neo4j/graphql lib. 
any Idea what the issue is here","1702943151","","","","https://stackoverflow.com/q/77682289","","","Question","Cannot query nodes","false","77682289","25",,,,,
"407",":User","","","","","Joe Olu","","","","","","User","","false","17648725","",,,,,
"408",":Question","","1","
I need to retrieve a node in Neo4j and I only have the internal ID.

Is there a way to retrieve the node that has the ID in the given set in one cypher query ? 

I&#39;m using Neo4j 2.1.5

Thanks !
```
from neomodel import db
query=&quot;MATCH (n:Message) WHERE ID(n)=&quot;+id+&quot; SET n.type=&#39;&quot;+str(ans)+&quot;&#39;, n.reprimands=&#39;&quot;+str(ans2)+&quot;&#39;&quot;
db.cypher_query(query)
```
I tried this but it didn&#39;t work out. I asigned the id in the python code, but it didn&#39;t seemed to have matched the ID I already had in my neo4j db. I used SET to change some attributes in the db but nothing changed at all. 

I am using neomodel to access the DB via python.","1702826013","","","","https://stackoverflow.com/q/77674898","","","Question","Neo4j- How can I match by using the internal ID","false","77674898","66",,,,,
"409",":User","","","","","artMart","","","","","","User","","false","20071464","",,,,,
"410",":Question","77681301","1","I have a neo4j database with 1 million user nodes. I&#39;m trying to load relationships between these nodes from a 4 million-row CSV file. A user can follow another user. At this point, the query has been running for hours. Is there something wrong with the query that&#39;s making it this slow?

``` 
CALL apoc.periodic.iterate(
&quot;LOAD CSV WITH HEADERS FROM &#39;file:///cleaned_follows_output.csv&#39; AS row RETURN row&quot;,
&quot;MATCH (u1 {id: row._s}), (u2 {id: row._t}) MERGE (u1)-[:FOLLOWING]-&gt;(u2)&quot;,
{batchSize: 10000, parallel: true}
);
```

I have already created an index on the id property by running the following:
```
CREATE INDEX FOR (u: User) ON (u.id)
```


Indexs:
```
Index Name	Type	Uniqueness	EntityType	LabelsOrTypes	Properties	State
index_343aff4q	LOOKUP		NODE	null	null	ONLINE
index_9f2536bf	RANGE		NODE	[ &quot;User&quot; ]	[ &quot;id&quot; ]	ONLINE
index_f7700478	LOOKUP		RELATIONSHIP	null	null	ONLINE
```","1702823714","","","","https://stackoverflow.com/q/77674781","","","Question","Neo4J- Improve LoadCSV relations query time","false","77674781","34",,,,,
"411",":User","","","","","osaro","","","","","","User","","false","10687078","",,,,,
"412",":Question","","0","IS IT POSSIBLE FOR APOC TO SELECTIVELY CRASH ON JUST ONE PROCEDURE?

```
MATCH (n:Node) 
RETURN apoc.temporal.format(n.DT, &quot;dd/MM/yyyy&quot;)
```
was returning **&quot;14/12/23&quot;** (via neo4j browser)

Then I ran query through php client, and it returns 

**&quot;Neo.ClientError.Procedure.ProcedureCallFailed: Failed to invoke function `apoc.temporal.format`: Caused by: java.lang.NullPointerException&quot;**

Then I run it again via neo4j browser and get the same error. So the browser shows working query, then a handful of minutes later shows the exact same query yielding error. I am puzzled.

```
CALL apoc.help(&quot;apoc&quot;)
```
returns long list that includes:

**&quot;function    apoc.temporal.format    apoc.temporal.format(input, format) | Format a temporal value&quot;**

Meanwhile, a bunch of other apoc functions seem to be working fine...

Rebooting the database does not fix it.

MY QUESTION: HOW DO I &quot;REBOOT&quot; APOC OR MAKE THIS PROCEDURE WORK AGAIN, AND HOW TO ENSURE THIS DOES NOT HAPPEN DURING DEPLOYMENT?

Thanks!","1702562690","","","","https://stackoverflow.com/q/77660729","","","Question","Failed to invoke apoc procedure (that was working just a minute ago)","false","77660729","29",,,,,
"413",":User","","","","","Stephanie","","","","","","User","","false","10768865","",,,,,
"414",":Question","","1","My database is set up, and when I query it and visualize the result in Bloom, I should manually sort one of the entities in a line to make it more meaningful for the audience. I am wondering if it is possible to sort the entities in Bloom, i.e. from left to right in a horizontal line?
[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/c2pws.png","1702516693","","","","https://stackoverflow.com/q/77657328","","","Question","Does Neo4j Bloom can sort the entities in visualization?","false","77657328","33",,,,,
"415",":User","","","","","Amir Rouhi","","","","","","User","","false","4701433","",,,,,
"416",":Question","","1","To create my databases, I have set up a *Neo4j desktop* and use a *localhost browser* to query and visualise the results. Would it be possible for me to query and visualise my databases graphs in the *Neo4j browser in the cloud* instead of localhost? To make it more accessible, I need it.","1702510542","","","","https://stackoverflow.com/q/77657073","","","Question","How can i migrate from localhost neo4j browser to cloud?","false","77657073","14",,,,,
"417",":Question","","1","If I choose a specific node LABEL, I can get a list of distinct node KEYS using the below:

```
MATCH(n:Person) 
WITH KEYS(n) AS keys
UNWIND keys AS key
RETURN COLLECT(DISTINCT key) AS DistinctKeys
```

the result is something like `[&quot;Title&quot;,&quot;Name&quot;,&quot;Location&quot;,&quot;Division&quot;]`

I&#39;m looking for a way to loop over this list and return the following equivalent, without having to specify each key:

`RETURN n.Title, n.Name, n.Location, n.Division `

Ideally would accommodate any node LABEL I specify where each LABEL can have varying numbers of KEYS. 

Not even sure where to start as looking online it doesn&#39;t look possible. Anything I have tried is not even close. ","1702472889","","","","https://stackoverflow.com/q/77653829","","","Question","neo4j table where a list of node keys defines the columns for RETURN","false","77653829","27",,,,,
"418",":User","","","","","user17864612","","","","","","User","","false","17864612","",,,,,
"419",":Question","","1","I have a cypher to read the json file and do some processing to create/merge nodes and relationship, 


```
// Read the json file
CALL apoc.load.json(&#39;file:///test/test.json&#39;) YIELD value

// Read the json fields as variables
with value.globalcustid as v_globalcustid, value.member_node_properties as member_node_properties, value.relationships as relationships

// Update the member node demographic properties, if the member node does not exist, create it
MERGE (m:Member {globalcustid: v_globalcustid})
ON CREATE SET m.age_group=member_node_properties.age_group, m.gender=member_node_properties.gender, m.education=member_node_properties.education
ON MATCH SET m.age_group=member_node_properties.age_group, m.gender=member_node_properties.gender, m.education=member_node_properties.education

// Unwind the relationships array into multiple rows of relationship
with v_globalcustid, m, member_node_properties, relationships
UNWIND relationships as r

// Get the tag node and skip the null tag
with m, v_globalcustid, r, r.node.label as node_label, r.node.tag_id as tag_id
where tag_id is not null
CALL apoc.cypher.run(
    &quot;MATCH (t:&quot; + node_label + &quot; {tag_id: &#39;&quot; + tag_id +&quot;&#39;}) RETURN t limit 1&quot;, 
    {}
) yield value as tag_node

// Merge the relationship of member node and tag node
with m, v_globalcustid, r, tag_node.t as tag_node
CALL apoc.merge.relationship(
  m, 
  r.relationship.label,
  {createdate: r.relationship.createdate, enddate: r.relationship.enddate, value: r.relationship.value},
  {},
  tag_node,
  {}
) YIELD rel

return *
```

The cypher was working fine with a small json file, then I found that when the json file is too large, it will have out of memory error, so I decided to put it in batch.

```

:auto

// Read the json file
CALL apoc.load.json(&#39;file:///test/test.json&#39;) YIELD value

// Read the json fields as variables
with value.globalcustid as v_globalcustid, value.member_node_properties as member_node_properties, value.relationships as relationships

call {
with v_globalcustid, member_node_properties, relationships

// Update the member node demographic properties, if the member node does not exist, create it
MERGE (m:Member {globalcustid: v_globalcustid})
ON CREATE SET m.age_group=member_node_properties.age_group, m.gender=member_node_properties.gender, m.education=member_node_properties.education
ON MATCH SET m.age_group=member_node_properties.age_group, m.gender=member_node_properties.gender, m.education=member_node_properties.education

// Unwind the relationships array into multiple rows of relationship
with v_globalcustid, m, member_node_properties, relationships
UNWIND relationships as r

// Get the tag node and skip the null tag
with m, v_globalcustid, r, r.node.label as node_label, r.node.tag_id as tag_id
where tag_id is not null
CALL apoc.cypher.run(
    &quot;MATCH (t:&quot; + node_label + &quot; {tag_id: &#39;&quot; + tag_id +&quot;&#39;}) RETURN t limit 1&quot;, 
    {}
) yield value as tag_node

// Merge the relationship of member node and tag node
with m, v_globalcustid, r, tag_node.t as tag_node
CALL apoc.merge.relationship(
  m, 
  r.relationship.label,
  {createdate: r.relationship.createdate, enddate: r.relationship.enddate, value: r.relationship.value},
  {},
  tag_node,
  {}
) YIELD rel

return *
} in transactions of 10000 rows
```

But it looks like it does not work to call another procedure inside the call {} block?
```
Query cannot conclude with CALL together with YIELD (line 31, column 1 (offset: 1319))
&quot;CALL apoc.merge.relationship(&quot;
 ^
```","1702442228","","","","https://stackoverflow.com/q/77651129","","","Question","Neo4j process a json file in batch","false","77651129","34",,,,,
"420",":Question","","0","I currently have a GraphQL server on top of Express.js to query from a Neo4j database using the `Neo4j GraphQL` library. 
```
const typeDefs = await toGraphQLTypeDefs(sessionFactory, false);
const ogm = new OGM({ typeDefs, driver });
const neoSchema = new Neo4jGraphQL({
  typeDefs,
  driver,
  config: {
    skipValidateTypeDefs: true,
  },
  plugins: [
    ApolloServerPluginDrainHttpServer({ httpServer: httpsServer }),
    ApolloServerPluginLandingPageLocalDefault({ embed: true }),
  ],
  resolvers: buildResolvers(ogm, client),
});

Promise.all([neoSchema.getSchema(), ogm.init()]).then(async ([schema]) =&gt; {
  const server = new ApolloServer({ schema });
  await server.start();
  server.applyMiddleware({ app });
  await new Promise((resolve) =&gt; httpsServer.listen({ port: 4000 }, resolve));
  console.log(
    `&#128640; Server ready at ${EXPRESS_SERVER_ORIGIN}${server.graphqlPath}`
  );
});
```

How should I modify this code to make Neo4j one of the &quot;datasources&quot; of the ApolloServer instance like this example from the docs: https://www.apollographql.com/docs/apollo-server/data/fetching-data
```
const server = new ApolloServer({
  typeDefs,
  resolvers,
  dataSources: () =&gt; {
    return {
      moviesAPI: new MoviesAPI(),
      personalizationAPI: new PersonalizationAPI(),
    };
  },
});
```

See the full code here for more context: https://github.com/mskcc/smile-dashboard/blob/d6d9d0d24766d27da470e5aea3218a7776e2f68a/graphql-server/src/index.ts#L289C2-L289C2","1702416688","","","","https://stackoverflow.com/q/77649129","","","Question","Convert Neo4jGraphql class into one of ApolloServer&#39;s data sources","false","77649129","17",,,,,
"421",":User","","","","","Quan","","","","","","User","","false","17265963","",,,,,
"422",":Question","","0","I have a large neo4j database of size more than 1 TB. I was using `dump` and `load` for backup and restore process. `dump` was working fine while my database size was less than 1 TB, but after it reached 1 TB `dump` is failing with error message &quot;Failed to dump database integer overflow&quot;.

I couldn&#39;t find any solution for this.

I need to run neo4j-admin `dump` process successfully.","1702385914","","","","https://stackoverflow.com/q/77646287","","","Question","Neo4j dump fails with integer overflow error","false","77646287","22",,,,,
"423",":User","","","","","Billcates","","","","","","User","","false","13567649","",,,,,
"424",":Question","","1","I suspect that I have encountered a bug. When querying with the Go SDK, the data results obtained are inconsistent with those in the Neo4j browser, with several Relationships missing.

  Neo4j Version: Neo4j Kernel 5.12.0 community

  Neo4j Mode: Single instance

  Driver version: Go driver v5.12.0

  Operating System: centos

My Cypher is

```
MATCH (n1:AAA_IngressOfSecurityGroup {AssetsAccountId:&quot;aaaa&quot;})-[:IngressOfSecurityGroup]-&gt;(n2:AAA_SecurityGroup {AssetsAccountId:&quot;aaaa&quot;})-[:SecurityGroupOfNetworkInterface]-&gt;(n3:AAA_NetworkInterface {AssetsAccountId:&quot;aaaa&quot;})-[:NetworkInterfaceOfCvm]-&gt;(n4:AAA_CvmInstance {AssetsAccountId:&quot;aaaa&quot;,AssetUniqueId:&quot;aaaa-165d2740e7fa&quot;,AssetsVersion:&quot;1702108924&quot;}) WHERE n4.InstanceState = &#39;RUNNING&#39; AND n4.RestrictState = &#39;NORMAL&#39; AND n1.Action = &#39;ACCEPT&#39; AND (n1.Ipv6CidrBlock = &quot;::/0&quot; OR n1.CidrBlock = &quot;0.0.0.0/0&quot;) AND toLower(n1.Port) = &#39;all&#39; AND (toLower(n1.Protocol) = &#39;tcp&#39; or toLower(n1.Protocol) = &#39;udp&#39; or toLower(n1.Protocol)= &#39;all&#39; )   WITH n1, n2, n3, n4 WHERE ALL (groupId IN n3.GroupSet WHERE   NOT EXISTS {     MATCH (n2_other:AAA_SecurityGroup {AssetsAccountId:&quot;aaaa&quot;, SecurityGroupId: groupId})-[:IngressOfSecurityGroup]-&gt;(n1_other:AAA_IngressOfSecurityGroup)     WHERE n1_other.Action = &#39;DROP&#39; AND ((n1_other.CidrBlock = &quot;0.0.0.0/0&quot; OR n1_other.Ipv6CidrBlock = &quot;::/0&quot;) AND toLower(n1_other.Port) = &#39;all&#39;) AND NOT EXISTS {       MATCH (n1_smaller:AAA_IngressOfSecurityGroup)-[:IngressOfSecurityGroup]-&gt;(n2_other)       WHERE toInteger(n1_smaller.PolicyIndex) &lt; toInteger(n1_other.PolicyIndex)     }   } )  OPTIONAL MATCH p2 = (n7:AAA_PublicIp {AssetsAccountId:&quot;aaaa&quot;})-[:PublicIpToVpc]-&gt;(n6:AAA_Vpc {AssetsAccountId:&quot;aaaa&quot;})-[:SubnetsInVPC]-&gt;(n5:AAA_Subnet {AssetsAccountId:&quot;aaaa&quot;})-[:NetworkInterfaceInSubnet]-&gt;(n3) WHERE p2 IS NOT NULL  OPTIONAL MATCH p3 = (n8:AAA_Eip {AssetsAccountId:&quot;aaaa&quot;})-[:EipOToVpc]-&gt;(n6)-[:SubnetsInVPC]-&gt;(n5)-[:NetworkInterfaceInSubnet]-&gt;(n3) WHERE p3 IS NOT NULL      WITH DISTINCT n4, n1, n2, n3, n6, n7, p2, p3  RETURN n1, n2, n3,n4, n6, n7, p2, p3
```

The code I use to process the data returned from Neo4j is as follows.

```
result, session, err := global.Neo4j.RunCypherQuery(body.Cypher, nil)
	if err != nil {
		logger.Log.Error(&quot;RunCypherQuery error: &quot; + err.Error())
		response := responses.NewErrorResponse(responses.StatusCodeUnknownErr, err.Error())
		c.JSON(http.StatusOK, response)
		return
	}

	var nodes []neo4j.Node
	var relationships []neo4j.Relationship

	seenNodes := make(map[int64]bool)
	seenRelationships := make(map[int64]bool)
	for result.Next() {
		record := result.Record()
		for _, value := range record.Values {
			if value == nil {
				continue
			}
			switch v := value.(type) {
			case neo4j.Node:
				if _, found := seenNodes[v.Id]; !found {
					seenNodes[v.GetId()] = true
					nodes = append(nodes, v)
				}
			case neo4j.Relationship:
				if _, found := seenRelationships[v.Id]; !found {
					seenRelationships[v.GetId()] = true
					relationships = append(relationships, v)
				}
			case neo4j.Path:
				for _, node := range v.Nodes {
					if _, found := seenNodes[node.Id]; !found {
						seenNodes[node.GetId()] = true
						nodes = append(nodes, node)
					}
				}
				for _, rel := range v.Relationships {
					if _, found := seenRelationships[rel.Id]; !found {
						seenRelationships[rel.GetId()] = true
						relationships = append(relationships, rel)
					}
				}
			case []interface{}:
				for _, item := range v {
					switch elem := item.(type) {
					case neo4j.Node:
						if _, found := seenNodes[elem.GetId()]; !found {
							seenNodes[elem.GetId()] = true
							nodes = append(nodes, elem)
						}
					case neo4j.Relationship:
						if _, found := seenRelationships[elem.GetId()]; !found {
							seenRelationships[elem.GetId()] = true
							relationships = append(relationships, elem)
						}
					default:
						logger.Log.Error(&quot;Unexpected type in []interface{}: %T&quot;, item)
						response := responses.NewErrorResponse(responses.StatusCodeUnknownErr, errors.New(fmt.Sprintf(&quot;Unexpected type in []interface{}: %T&quot;, item)).Error())
						c.JSON(http.StatusOK, response)
						return
					}
				}
			default:
				logger.Log.Error(&quot;Unexpected type: %T&quot;, v)
				response := responses.NewErrorResponse(responses.StatusCodeUnknownErr, errors.New(fmt.Sprintf(&quot;Unexpected type: %T&quot;, v)).Error())
				c.JSON(http.StatusOK, response)
				return
			}
		}
	}
```

```
func (c *Client) RunCypherQuery(query string, params map[string]interface{}) (neo4j.Result, neo4j.Session, error) {
	session := c.driver.NewSession(neo4j.SessionConfig{})
	fmt.Println(query)
	result, err := session.Run(query, params)
	if err != nil {
		return nil, session, err
	}
	return result, session, nil
}
```

in neo4j desktop search result is

[![enter image description here][1]][1]


in my code search result is

[![enter image description here][2]][2]

The position marked with a red &quot;X&quot; indicates that no results were found.

In the RunCypherQuery method, the data for these three Relationships were not found in the returned result.



  [1]: https://i.stack.imgur.com/LBl50.png
  [2]: https://i.stack.imgur.com/rAFEJ.png","1702185335","","","","https://stackoverflow.com/q/77633753","","","Question","The same Cypher query yields inconsistent results between the SDK and the browser, with several Relationships missing","false","77633753","34",,,,,
"425",":User","","","","","FlagT","","","","","","User","","false","11803228","",,,,,
"426",":Question","","1","We observe unexplainable behaviour with Neo4j Web Browser.

- Cypher query return only 3 relationships but the web browser display 5.

- As you can see, on the right side we have this text : Displaying 4 Nodes, 3 rel
  But the graph shows 5 rel.

- The table Tab in the Web Browser shows 3 records and the cypher results return 3 rel

- We observe this behaviors with other queries, it&#39;s not only for the query shared here.

- When we refresh the Neo4j WebBrowser (reload/refresh the chrome browser tab), sometimes we have the display with the right data, sometimes not

![a snapshot to help to inderstand](https://i.stack.imgur.com/qVgc9.png)

PS : we run 5.14.0 community version and Neo4j Web Browser 5.12.0

Regards,
Nizar","1702117013","","","","https://stackoverflow.com/q/77630912","","","Question","Neo4j Web Browser : Display phantom data (data does not exists on server)","false","77630912","47",,,,,
"427",":User","","","","","Nizar","","","","","","User","","false","23070531","",,,,,
"428",":Question","77622086","1","I am using the Neo4j Graph Data Science (GDS) library with Fast Random Projection (FastRP) for graph embeddings. I&#39;m facing challenges in updating these embeddings efficiently in response to frequent graph changes (additions/removals of nodes and edges). I&#39;m particularly interested in understanding the best practices for updating these embeddings - should I opt for incremental updates after each change, or batch processing at regular intervals?

Additionally, I&#39;m curious if it&#39;s feasible to update embeddings for only the affected sub-graph while maintaining the integrity and consistency of embeddings as if they were done on the global graph projection.","1701967766","","","","https://stackoverflow.com/q/77621751","","","Question","Updating Neo4j Embeddings on Graph Change","false","77621751","71",,,,,
"429",":User","","","","","Chetra Abeid","","","","","","User","","false","21159756","",,,,,
"430",":Question","","0","I&#39;m trying to create a graph where multiple node types can have the same type of relationship between them. 
I have 5 node types; Group (spelled out below), Alias, Software, Technique &amp; Tool. They&#39;re all basically set up the same way with the same properties, I&#39;m just leaving them out for readability. 

```
class Group(StructuredNode):
    created = DateTimeFormatProperty(default_now=True, format=&quot;%Y-%m-%dT%H:%M:%S.%fZ&quot;)
    description = StringProperty()
    ID = StringProperty(index=True)
    modified = DateTimeFormatProperty(default_now=True, format=&quot;%Y-%m-%dT%H:%M:%S.%fZ&quot;)
    name = StringProperty(unique_index=True, required=True)
    TYPE = StringProperty(index=True, default=&#39;review&#39;)
    version = IntegerProperty(default=5)
    #relationship properties go here 

class Alias(StructuredNode):
    name = StringProperty(unique_index=True, required=True)
    TYPE = StringProperty(index=True, default=&#39;review&#39;)
    #relationship properties go here
    
class Software(StructuredNode):
    created = DateTimeFormatProperty(default_now=True, format=&quot;%Y-%m-%dT%H:%M:%S.%fZ&quot;)
    description = StringProperty()
    ID = StringProperty(index=True)
    modified = DateTimeFormatProperty(default_now=True, format=&quot;%Y-%m-%dT%H:%M:%S.%fZ&quot;)
    name = StringProperty(unique_index=True, required=True)
    TYPE = StringProperty(index=True, default=&#39;review&#39;)
    version = IntegerProperty(default=None)
    #relationship properties go here
    
class Technique(StructuredNode):
    created = DateTimeFormatProperty(default_now=True, format=&quot;%Y-%m-%dT%H:%M:%S.%fZ&quot;)
    description = StringProperty()
    ID = StringProperty(index=True)
    modified = DateTimeFormatProperty(default_now=True, format=&quot;%Y-%m-%dT%H:%M:%S.%fZ&quot;)
    name = StringProperty(unique_index=True, required=True)
    TYPE = StringProperty(index=True, default=&#39;review&#39;)
    version = IntegerProperty(default=None)   
    #relationship properties go here
    
class Tool(StructuredNode):
    created = DateTimeFormatProperty(default_now=True, format=&quot;%Y-%m-%dT%H:%M:%S.%fZ&quot;)
    description = StringProperty()
    ID = StringProperty(index=True)
    modified = DateTimeFormatProperty(default_now=True, format=&quot;%Y-%m-%dT%H:%M:%S.%fZ&quot;)
    name = StringProperty(unique_index=True, required=True)
    TYPE = StringProperty(index=True, default=&#39;review&#39;)
    version = IntegerProperty(default=None) 
    #relationship properties go here
```
   I&#39;d like to do something like below where I include a list of all of the possible node types when setting relationships:
``` 
    uses = RelationshipTo([&#39;Alias&#39;, &#39;Software&#39;, &#39;Technique&#39;, &#39;Tool&#39;], &#39;USES&#39;)  
    alias = RelationshipTo([&#39;Software&#39;, &#39;Technique&#39;, &#39;Tool&#39;], &#39;ALIAS&#39;)
    revoked_by = RelationshipTo([&#39;Alias&#39;, &#39;Software&#39;, &#39;Technique&#39;, &#39;Tool&#39;], &#39;REVOKED-BY&#39;)
```
Rather than having to spell out each different relationship type for each node:
```
   usesalias = RelationshipTo(&#39;Alias&#39;, &#39;USES&#39;)
   usestool = RelationshipTo(&#39;Tool&#39;, &#39;USES&#39;)
   usestechnique = RelationshipTo(&#39;Technique&#39;, &#39;USES&#39;)
   usessoftware = RelationshipTo(&#39;Software&#39;, &#39;USES&#39;)

   aliassoftware = RelationshipTo(&#39;Software&#39;, &#39;Alias&#39;)
   aliastool = RelationshipTo(&#39;Tool&#39;, &#39;Alias&#39;)
   aliastechnique = RelationshipTo(&#39;Technique&#39;, &#39;Alias&#39;)

   rbalias = RelationshipTo(&#39;Alias&#39;, &#39;REVOKED-BY&#39;)
   rbtool = RelationshipTo(&#39;Tool&#39;, &#39;REVOKED-BY&#39;)
   rbtechnique = RelationshipTo(&#39;Technique&#39;, &#39;REVOKED-BY&#39;)
   rbsoftware = RelationshipTo(&#39;Software&#39;, &#39;REVOKED-BY&#39;)
   
   ......

```","1701964628","","","","https://stackoverflow.com/q/77621416","","","Question","is it possible to include a list of node classes in a relationshipto object using neomodel in python","false","77621416","41",,,,,
"431",":User","","","","","adam","","","","","","User","","false","2338089","",,,,,
"432",":Question","","2","I&#39;m looking to count the number of distinct pairings in query of neighbor&#39;s neighbors. Let say I have a small graph consisting of the following nodes and edges,

    (id:A, type:1)-&gt;(id:B, type:2)
    (id:A, type:1)-&gt;(id:C, type:2)
    (id:B, type:2)-&gt;(id:D, type:3)
    (id:C, type:2)-&gt;(id:D, type:3)
    (id:C, type:2)-&gt;(id:E, type:3)

and a pattern to match like,

    MATCH (n0 {id: A})--(n1:2)--(n2)
    WHERE n2.id IN [&quot;D&quot;, &quot;E&quot;]

I am looking for a query that will count the distinct pairings along this 2-hop pattern. In other words, the expected answer would give the counts,

    A to type2   : 2 connections
    type2 to D   : 2 connections
    type2 to E   : 1 connection","1701878441","","","","https://stackoverflow.com/q/77614613","","","Question","Count distinct node pairings in a multihop match","false","77614613","39",,,,,
"433",":User","","","","","erikejan","","","","","","User","","false","5868625","",,,,,
"434",":Question","","1","I created a map of city in Neo4j using OpenStreetMap and OpenAddresses data. I want to find the shortest path from one address to another. The problem is that, when I&#39;m using function apoc.algo.aStarConfig,I&#39;m getting a path without consideration about direction of a relationship.


```
MATCH (a:Address)-[:NEAREST_INTERSECTION]-&gt;(source:Intersection)
WHERE a.full_address CONTAINS &quot;410 E 5TH AVE SAN MATEO, CA&quot;
MATCH (poi:Address)-[:NEAREST_INTERSECTION]-&gt;(dest:Intersection) 
WHERE poi.full_address CONTAINS &quot;39 GRAND BLVD SAN MATEO, CA&quot;
CALL apoc.algo.aStarConfig(source, dest, &quot;ROAD_SEGMENT&quot;, 
  {pointPropName: &quot;location&quot;, weight: &quot;length&quot;}) 
YIELD weight, path
RETURN *
```
[Result of the query](https://i.stack.imgur.com/nTytn.png)


**So my question is if there is a possibility to find the shortest path from one path to another not consider upstream relathionships?**","1701805911","","","","https://stackoverflow.com/q/77608911","","","Question","Shortest path of weighted and directed graph in Neo4j","false","77608911","31",,,,,
"435",":User","","","","","strzelaczbramek9","","","","","","User","","false","23048059","",,,,,
"436",":Question","","1","```sql
// BadgesNode
LOAD CSV WITH HEADERS FROM &#39;file:///Badges.csv&#39; AS row
CREATE (:Badges {
  classid: toInteger(row.Class),
  name: row.Name,
  badgeId: toInteger(row.Id)
})
WITH *
LIMIT 1
RETURN classid, name, badgeId;
```

when I run it, there is no value in the properties. But when I run this cypher 

```sql
LOAD CSV WITH HEADERS FROM &#39;file:///Badges.csv&#39; AS row
RETURN row
```

and this is the result that it returns:
```json
{
  &quot;Name&quot;: &quot;Informed&quot;,
  &quot;Date&quot;: &quot;2014-05-13 23:06&quot;,
  &quot;Class&quot;: &quot;3&quot;,
  &quot;Id&quot;: &quot;1&quot;,
  &quot;UserId&quot;: &quot;1&quot;,
  &quot;TagBased&quot;: &quot;FALSE&quot;
}
```


I can not understand why the first cypher does not return values into the properties. Can somebody help me. I stuck in this part for two days. 

I need to fill the properties by the values in the csv file.
And this is a subset of my csv file.

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/834Hw.png","1701799094","","","","https://stackoverflow.com/q/77608338","","","Question","I can not import from csv files into Neo4j","false","77608338","51",,,,,
"437",":User","","","","","mahsa tajik","","","","","","User","","false","10190562","",,,,,
"438",":Question","","1","I am doing a project of converting MySQL tables to Neo4j graph.After conversion I am replicating the delete action of the SQL Database using java in the graph.So when I delete a record in my SQL database,I want to delete the nodes related to that particular record.For example I am deleting from table Complaints with complaint_id=7.Complaint_Details is a child table of Complaints with  ON DELETE CASCADE Action .This further has another child table with ON DELETE SET NULL Action.So in the graph I want to delete the Complaint node with complaint_id = 7,Complaint_Details node with complaint_id =7 and the removal of the respective property of  its child nodes.

My current approach is to query the path from Node complaint with complaint_id 7 using 
 String cypherPath = &quot;MATCH path=(n:&quot; + tableName + &quot;{&quot; + columnName + &quot;:&quot; + PkValue + &quot;})-[*]-&gt;(m) WHERE NOT EXISTS((m)-[]-&gt;()) RETURN path&quot;;
Then i am iterating through each node and checking the database for its action on deletion.Based on that action I am either deleting the node or removing a property.
This method takes up a lot of time (around 5s for 2000 records)
Is there a more efficient way to do this?","1701338493","","","","https://stackoverflow.com/q/77577493","","","Question","In Neo4j I want to obtain the path emerging from a particular node,I then want to iterate each node in the path and delete it based on stored action","false","77577493","80",,,,,
"439",":Question","","2","Trying to build nested query in cypher sql to find the grosssale, sales by distinctcustomer and salesreach and not able to pass column 1 value as input to another column - any help would be appreciated.

Syntax here

```sql
MATCH (n:Commercial)
WITH (n) AS grosssales, count(n) AS distinctcustomer, 
  n.customer_id AS customer, ### grouping by customer_id ###
  grosssale / distinctcustomer AS salesreach
RETURN grossale, distinctcustomer, salesreach, customer_id
```

Tried WITH clause however no joy, would appreciate any help in correcting the cypher syntax.","1701325970","","","","https://stackoverflow.com/q/77576343","","","Question","Cypher Nested Query","false","77576343","44",,,,,
"440",":User","","","","","Shakthi Ramalingam","","","","","","User","","false","6275738","",,,,,
"441",":Question","77574246","1","I want to use the built-in neo4j. I know that neo4j has a built-in neo4j driver for java, but it is not supported by `spring data neo4j`
 ","1701260419","","","","https://stackoverflow.com/q/77571107","","","Question","Spring Boot neo4j","false","77571107","71",,,,,
"442",":User","","","","","asfarasiknow","","","","","","User","","false","20036372","",,,,,
"443",":Question","77565897","1","I&#39;ve got a graph with two types of relationships: `Sync` and `Async`.

I want a query to give me a subgraph, meaning all the nodes that can be reached directly or indirectly.

This query works for this:

    MATCH (s {type: &#39;service&#39;)
    OPTIONAL MATCH (s)-[:Async|Sync*]-&gt;(dependent)
    WITH s, COLLECT(DISTINCT dependent) AS allDependentNodes

This gives me every node that can be reached via an Sync or Async relationship.


But now I&#39;d like to use a different direction based on the type of relation. I want nodes that can be reached via outgoing Sync `a -&gt; b` OR reached via incoming Async `a &lt;- b`.  

So it&#39;s like an OR&#39;d match condition. I&#39;ve tried a few things without much success:

    MATCH (s {type: &#39;service&#39;)
    OPTIONAL MATCH (s)-[:Sync*]-&gt;(dependent), (s)&lt;-[:Async*]-(d)
    WITH s, totalNodes, COLLECT(DISTINCT dependent) AS allDependentNodes


How can I OR&#39;d together relationship matches or how can I match different types of relationships with different directions?","1701190063","","","","https://stackoverflow.com/q/77565696","","","Question","How to match nodes in Cypher query based on different directions per relationship type","false","77565696","61",,,,,
"444",":User","","","","","Richard Deurwaarder","","","","","","User","","false","988324","",,,,,
"445",":Question","77560648","1","I have a neo4j database with two types of node labels: person and email.
One email node always connects two person nodes through the relationships &#39;EMAIL_FROM&#39; and &#39;EMAIL_TO&#39;
such that the relationship can be queried like such:

    match (p1:Person)-[:EMAIL_FROM]-&gt;(:Email)-[:EMAIL_TO]-&gt;(p2:Person) return p1, p2
I&#39;m trying to write a variable-length-relationship query which begins at a certain person node and finds all other person nodes that can be reached through the intermediary email nodes. This is what I tried:

    match (p1:Person where p1.name=&#39;Jeff&#39;)-[:EMAIL_FROM*]-&gt;(:Email)-[:EMAIL_TO*]-&gt;(p2:Person) return p1, p2
This sadly does not work as I thought it would and returns only directly reachable from the &#39;Jeff&#39; node by iterating through the pattern once but then it stops although I know the nodes reached in the first iteration have outgoing &#39;EMAIL_FROM&#39; relationships themselves. Thanks in advance.","1701127131","","","","https://stackoverflow.com/q/77560500","","","Question","Neo4j: Variable-length-relationship with intermediary node","false","77560500","37",,,,,
"446",":User","","","","","NoraTheFlora","","","","","","User","","false","18073394","",,,,,
"447",":Question","77556024","2","This is the code below for connecting and running `neo4j` and python . I have seen a `neo4j` warning from the code . Is that a severe warning or is it mandatory to fix it? How to fix this issue? The warning is `&quot; Type &#39;Neo4jConnector&#39; doesn&#39;t have expected attribute &#39;run&#39; &quot;`
```
from neo4j import GraphDatabase


class Neo4jConnector:
    def __init__(self, uri, user, password):
        self._driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        self._driver.close()

    @property
    def driver(self):
        return self._driver


def get_nodes_by_id_name(tx, id_name):
    query = (
        &quot;MATCH (r:Rule) &quot;
        &quot;WHERE r.id_name = $id_name &quot;
        &quot;RETURN r&quot;
    )
    result = []
    for record in tx.run(query, id_name=id_name):
        result.append(record[&quot;node&quot;])
    return result


def create_inbound_rule(connector, profileid, sender, receiver, message, processingflag1, ruletype):
    id_name = receiver + &#39;_inBOUND_&#39; + sender
    name1_inbound = receiver + &#39;_inBOUND_&#39; + sender + &#39;_SFTP_STEP1&#39;
    return_name = name1_inbound + &#39;&amp; SFTP_STEP2 created successfully&#39;

    query = (
        &quot;CREATE (r:Rule {sender: $sender, receiver: $receiver, &quot;
        &quot;message: $message, profileid: $profileid, ruletype: $ruletype, &quot;
        &quot;processingflag1: $processingflag1,id_name:$id_name})&quot;
    )

    with connector._driver.session() as session:
        session.write_transaction(lambda tx: tx.run(query, sender=sender, receiver=receiver,
                                                    message=message, profileid=profileid,
                                                    ruletype=ruletype, processingflag1=processingflag1,
                                                    id_name=id_name))
        return return_name


def create_outbound_rule(connector, profileid_outbound, sender_outbound, receiver_outbound,
                         message_outbound, processingflag1_outbound, filename_output):
    id_name = receiver_outbound + &#39;_outbound_&#39; + sender_outbound
    name1_outbound = receiver_outbound + &#39;_Outbound_&#39; \
                     + sender_outbound + &#39;_SFTP_STEP1&#39;
    return_name = name1_outbound + &#39;&amp; SFTP_STEP2 created successfully&#39;
    query = (
        &quot;CREATE (r:Rule {sender_outbound: $sender_outbound, receiver_outbound: $receiver_outbound, &quot;
        &quot;message_outbound: $message_outbound, profileid_outbound: $profileid_outbound, &quot;
        &quot;filename_output: $filename_output, &quot;
        &quot;processingflag1_outbound: $processingflag1_outbound,id_name:$id_name})&quot;
    )

    with connector._driver.session() as session:
        session.write_transaction(
            lambda tx: tx.run(query, sender_outbound=sender_outbound, receiver_outbound=receiver_outbound,
                              message_outbound=message_outbound, profileid_outbound=profileid_outbound,
                              filename_output=filename_output, processingflag1_outbound=processingflag1_outbound,
                              id_name=id_name))
        return return_name


def create_both_rule(connector, inbound_profileid, outbound_profileid, sender, receiver, message, processingflag1,
                     filename, return_name, id_name):
    query = (
        &quot;CREATE (r:Rule {sender: $sender, receiver: $receiver, &quot;
        &quot;message: $message, inbound_profileid: $inbound_profileid, outbound_profileid: $outbound_profileid, &quot;
        &quot;processingflag1: $processingflag1, filename: $filename,id_name:$id_name})&quot;
    )

    with connector._driver.session() as session:
        session.write_transaction(lambda tx: tx.run(query, sender=sender, receiver=receiver,
                                                    message=message, inbound_profileid=inbound_profileid,
                                                    outbound_profileid=outbound_profileid,
                                                    processingflag1=processingflag1,
                                                    filename=filename, id_name=id_name))
        return return_name


def create_inbound_basictx_rule(connector, tradingpartner_basictx, profileid_basictx, processingflag1_basictx, id_name):
    name1_basictx = &quot;1.0.0_ELUX_INBOUND_RECEIVE_FROM_&quot; + tradingpartner_basictx + &quot;_SFTP_TO_BASICTX&quot;
    name2_basictx = &quot;1.0.2_ELUX_GENERIC_IN_FLAT_FILE_&quot; + processingflag1_basictx + &quot;_BASICTX_TO_CC_FINISH&quot;
    return_name = name1_basictx + name2_basictx + &quot;created successfully&quot;
    query = (
        &quot;CREATE (r:Rule {TradingPartner: $tradingpartner_basictx, profileid: $profileid_basictx, &quot;
        &quot;processingflag1_basictx: $processingflag1_basictx,id_name:$id_name})&quot;
    )

    with connector._driver.session() as session:
        session.write_transaction(lambda tx: tx.run(query, tradingpartner_basictx=tradingpartner_basictx,
                                                    profileid_basictx=profileid_basictx,
                                                    processingflag1_basictx=processingflag1_basictx, id_name=id_name))
    return return_name


def create_outbound_basictx_rule(connector, tradingpartner_basictx, profileid_basictx, processingflag1_basictx,
                                 id_name):
    name1_basictx = &quot;1.0.0_ELUX_OUTBOUND_RECEIVE_FROM_&quot; + tradingpartner_basictx + &quot;_SFTP_TO_BASICTX&quot;
    name2_basictx = &quot;1.0.2_ELUX_GENERIC_IN_FLAT_FILE_&quot; + processingflag1_basictx + &quot;_BASICTX_TO_CC_FINISH&quot;
    return_name = name1_basictx + name2_basictx + &quot;created successfully&quot;
    query = (
        &quot;CREATE (r:Rule {TradingPartner: $tradingpartner_basictx, profileid: $profileid_basictx, &quot;
        &quot;processingflag1: $processingflag1_basictx,id_name:$id_name})&quot;
    )
    with connector._driver.session() as session:
        session.write_transaction(lambda tx: tx.run(query, tradingpartner_basictx=tradingpartner_basictx,
                                                    profileid_basictx=profileid_basictx,
                                                    processingflag1_basictx=processingflag1_basictx, id_name=id_name))
        return return_name


def edit_inbound_rule(connector, new_profile_id, new_message, new_processingflag1):
    s_id = dict[&quot;s_id&quot;]
    return_name = &#39;Rule Edit Successfully&#39;
    query = (
        &quot;MATCH (r:Rule) WHERE r.id_name = $s_id &quot;
        &quot;SET r.profileid = $new_profile_id, &quot;
        &quot;    r.message = $new_message, &quot;
        &quot;    r.processingflag1 = $new_processingflag1 &quot;
    )
    connector.run(query, new_profile_id=new_profile_id,
                  new_message=new_message, new_processingflag1=new_processingflag1, s_id=s_id)

    return return_name


def edit_outbound_rule(connector, new_profile_id, new_message, new_processing_flag, new_filename):
    s_id = dict[&quot;s_id&quot;]
    return_name = &#39;Rule Edit Successfully&#39;
    query = (
        &quot;MATCH (r:Rule) WHERE r.id_name = $id_name &quot;
        &quot;SET r.profileid_outbound = $new_profile_id, &quot;
        &quot;    r.message_outbound = $new_message, &quot;
        &quot;    r.processingflag1_outbound = $new_processing_flag, &quot;
        &quot;    r.filename_output = $new_filename&quot;
    )
    connector.run(query, return_name=return_name, new_profile_id=new_profile_id,
                  new_message=new_message, new_processing_flag=new_processing_flag,
                  new_filename=new_filename, s_id_name=s_id)


def edit_both_rule(connector, new_inbound_profile_id, new_outbound_profile_id, new_message,
                   new_processing_flag,
                   new_filename):
    s_id = dict[&quot;s_id&quot;]
    return_name = &#39;Rule Edit Successfully&#39;
    query = (
        &quot;MATCH (r:Rule) WHERE r.id_name = $s_id &quot;
        &quot;SET r.inbound_profileid_both = $new_inbound_profile_id, &quot;
        &quot;    r.outbound_profileid_both = $new_outbound_profile_id, &quot;
        &quot;    r.message_both = $new_message, &quot;
        &quot;    r.processingflag1_both= $new_processing_flag, &quot;
        &quot;    r.filename_both = $new_filename&quot;
    )
    connector.run(query, new_inbound_profile_id=new_inbound_profile_id,
                  new_outbound_profile_id=new_outbound_profile_id, new_message=new_message,
                  new_processing_flag=new_processing_flag, new_filename=new_filename, s_id_=s_id)

    return return_name


def edit_inbound_basictx_rule(connector, new_tradingpartner, new_profile_id, new_processing_flag):
    s_id = dict[&quot;s_id&quot;]
    return_name = &#39;Rule Edit Successfully&#39;
    query = (
        &quot;MATCH (r:Rule) WHERE r.id_name = $s_id &quot;
        &quot;SET r.tradingpartner = $new_tradingpartner, &quot;
        &quot;    r.profile_id = $new_profile_id, &quot;
        &quot;    r.processing_flag = $new_processing_flag&quot;
    )
    connector.run(query, new_tradingpartner=new_tradingpartner,
                  new_profile_id=new_profile_id, new_processing_flag=new_processing_flag, s_id=s_id)

    return return_name


def edit_outbound_basictx_rule(connector, new_tradingpartner, new_profile_id, new_processing_flag):
    s_id = dict[&quot;s_id&quot;]
    return_name = &#39;Rule Edit Successfully&#39;
    query = (
        &quot;MATCH (r:Rule) WHERE r.id_name = $s_id &quot;
        &quot;SET r.tradingpartner_basictx = $new_tradingpartner, &quot;
        &quot;    r.profileid_basictx = $new_profile_id, &quot;
        &quot;    r.processingflag1_basictx = $new_processing_flag&quot;
    )

    connector.run(query, return_name=return_name, new_tradingpartner=new_tradingpartner,
                  new_profile_id=new_profile_id, new_processing_flag=new_processing_flag, s_id=s_id)

    return return_name


def main(dict):
    uri = &quot;bolt://localhost:7687&quot;
    user = &quot;admin&quot;
    password = &quot;password&quot;
    connector = Neo4jConnector(uri, user, password)
    ruletype = dict[&#39;ruletype&#39;]
    # Initialize a dictionary to store the result

    if ruletype == &#39;Inbound&#39;:
        profileid = dict[&#39;profile_id&#39;]
        sender = dict[&#39;sender&#39;]
        receiver = dict[&#39;receiver&#39;]
        message = dict[&#39;message&#39;]
        processingflag1 = dict[&#39;processingflag1&#39;]
        create_inbound_rule(connector, profileid, sender, receiver, message, processingflag1, )

    elif ruletype == &#39;Outbound&#39;:
        profileid_outbound = dict[&#39;profileid_outbound&#39;]
        sender_outbound = dict[&#39;sender_outbound&#39;]
        receiver_outbound = dict[&#39;receiver_outbound&#39;]
        message_outbound = dict[&#39;message_outbound&#39;]
        processingflag1_outbound = dict[&#39;processingflag1_outbound&#39;]
        filename_output = dict[&#39;filename_output&#39;]

        create_outbound_rule(connector, profileid_outbound, sender_outbound, receiver_outbound,
                             message_outbound, processingflag1_outbound, filename_output)
    elif ruletype == &#39;Both&#39;:
        inbound_profileid_both = dict[&#39;inbound_profileid_both&#39;]
        outbound_profileid_both = dict[&#39;outbound_profile_id_both&#39;]
        sender_both = dict[&#39;sender_both&#39;]
        receiver_both = dict[&#39;receiver_both&#39;]
        message_both = dict[&#39;message_both&#39;]
        processingflag1_both = dict[&#39;processingflag1_both&#39;]

        filename_both = dict[&#39;filename_both&#39;]
        id_name = receiver_both + &#39;_Both_&#39; + sender_both
        return_name = receiver_both + &#39;both&#39; + sender_both + &#39;SFTP_STEP1,SFTP_STEP2 created successfully&#39;
        create_both_rule(connector, inbound_profileid_both, outbound_profileid_both, sender_both,
                         receiver_both, message_both, processingflag1_both, filename_both, return_name)

    elif ruletype == &#39;Inbound BasicTx&#39;:
        tradingpartner_basictx = dict[&quot;tradingpartner_Basictx&quot;]
        profileid_basictx = dict[&quot;profileid_Basictx&quot;]
        processingflag1_basictx = dict[&quot;ProcessingFlag1_Basictx&quot;]
        id_name = &quot;ELUX_INBOUND_RECEIVE_FROM_&quot; + tradingpartner_basictx
        create_inbound_basictx_rule(connector, tradingpartner_basictx, profileid_basictx,
                                    processingflag1_basictx, id_name)
    elif ruletype == &#39;Outbound BasicTx&#39;:
        tradingpartner_basictx = dict[&quot;tradingpartner_basictx&quot;]
        profileid_basictx = dict[&quot;profile_id_basictx&quot;]
        processingflag1_basictx = dict[&quot;processingflag1_basictx&quot;]
        id_name = &quot;ELUX_INBOUND_RECEIVE_FROM_&quot; + tradingpartner_basictx
        create_outbound_basictx_rule(connector, tradingpartner_basictx, profileid_basictx,
                                     processingflag1_basictx, id_name)
    elif ruletype == &#39;Edit Inbound Rule&#39;:

        new_message = dict[&quot;new_message&quot;]
        new_profile_id = dict[&quot;new_profile_id&quot;]
        new_processing_flag = dict[&quot;new_processing_flag&quot;]

        edit_inbound_rule(connector, new_profile_id, new_message, new_processing_flag)

    elif ruletype == &#39;Edit Outbound Rule&#39;:

        new_profile_id = dict[&quot;new_profile_id&quot;]
        new_message = dict[&quot;new_message&quot;]
        new_processing_flag = dict[&quot;new_processing_flag&quot;]
        new_filename = dict[&quot;new_filename&quot;]
        edit_outbound_rule(connector, new_profile_id, new_message, new_processing_flag, new_filename)

    elif ruletype == &#39;Edit Both Rule&#39;:

        new_inbound_profile_id = dict[&quot;new_inbound_profile_id&quot;]
        new_outbound_profile_id = dict[&quot;new_outbound_profile_id&quot;]
        new_filename = dict[&#39;new_filename&#39;]
        new_message = dict[&quot;Message_edit_Both&quot;]
        new_processing_flag = dict[&quot;new_processing_flag&quot;]
        edit_both_rule(connector, new_inbound_profile_id, new_outbound_profile_id, new_message,
                       new_processing_flag, new_filename)
    elif ruletype == &#39;Edit Inbound BasicTx&#39;:
        id_name = dict[&#39;id_name&#39;]
        new_tradingpartner = dict[&quot;new_tradingpartner&quot;]
        new_profile_id = dict[&quot;new_profile_id&quot;]
        new_processing_flag = dict[&quot;new_processing_flag&quot;]
        edit_inbound_basictx_rule(connector, new_tradingpartner, new_profile_id, new_processing_flag)

    elif ruletype == &#39;Edit Outbound BasicTx&#39;:
        new_tradingpartner = dict[&quot;new_tradingpartner&quot;]
        new_profile_id = dict[&quot;new_profile_id&quot;]
        new_processing_flag = dict[&quot;new_processing_flag&quot;]
        edit_outbound_basictx_rule(connector, new_tradingpartner, new_profile_id, new_processing_flag)

    elif ruletype == &#39;Rule Search&#39;:
        # Call the get_nodes_by_id_name function to retrieve nodes by id_name
        id_name = dict[&#39;id_name&#39;]
        return_name = &#39;Rule Search Successfully&#39;

    else:
        print(f&quot;Unsupported ruletype: {ruletype}&quot;)
    connector.close()

```


I tried to solve this error to fix these warnings and it did not fix the issue
","1701068434","","","","https://stackoverflow.com/q/77555016","","","Question","How to fix &quot;Type &#39;Neo4jConnector&#39; doesn&#39;t have expected attribute &#39;run&#39; &quot; in python file","false","77555016","47",,,,,
"448",":User","","","","","Kevin Paul Babu","","","","","","User","","false","19443460","",,,,,
"449",":Question","","1","Is there any way to return the count of affected nodes after doing the update operation with Spring Data Neo4j repository?

e.g
```
@Query(&quot;MATCH (n:Student) WHERE n.id IN $idList SET n.isRegistered = true&quot;)
Integer updateRegisterInfo(@Param(&quot;idList&quot;) List&lt;String&gt; idList);
```

But sdn can only return void/null value for such operation.

Thanks","1700880286","","","","https://stackoverflow.com/q/77546470","","","Question","Spring Data Neo4j return count of affected nodes after update operation","false","77546470","46",,,,,
"450",":User","","","","","stackoverflow_user","","","","","","User","","false","13574344","",,,,,
"451",":Question","","0","I have Neo4j Desktop 1.5.8 installed on a Windows PC. Created few databases and used the Query browser and Bloom as well. However, I keep encountering annoying issues like:

`Database xxx can not be started due to conflicts with external processes. To fix this problem, let us change these port configurations: bolt: xxxx -&gt; xxxx`

Clicking `Fix configuration` doesn&#39;t work and keeps showing that error message. One solution (hack) that I found online was to find the process `Zulu Platform x64 Architecture` and terminate it. It works sometimes but most often it doesn&#39;t even appear in the Task Manager. I have also found that stopping/restarting a database results in forever `Stopping` operation. 

I have tried:
- restarting Neo4j: works rarely
- keep hunting for the `Zulu Platform x64 Architecture`: works when I find it in taskmgr
- restarting the PC: works sometimes

Does anyone know of an actual fix to this problem? Any way, I can start/stop the database from command line, e.g., using cypher-shell or Python library?","1700665334","","","","https://stackoverflow.com/q/77531031","","","Question","Neo4j Desktop - Error connecting/stopping/starting databases - Database X can not be started","false","77531031","11",,,,,
"452",":User","","","","","Benny","","","","","","User","","false","1089239","",,,,,
"453",":Question","","0","Let&#39;s say I have a CPU with `24 cores`/`48 threads`.

I would like to correctly specify the `partitions` parameter to `apoc.cypher.mapParallel2` procedure https://neo4j.com/labs/apoc/5/overview/apoc.cypher/apoc.cypher.mapParallel2/.

How to calculate `partitions` parameter value based on CPU charcteristcs ?","1700607356","","","","https://stackoverflow.com/q/77526391","","","Question","How to correctly calculate partitions for apoc.cypher.mapParallel2 based on CPU characteristics","false","77526391","38",,,,,
"454",":Question","","1","I have a CSV header and data file that I want to import in Neo4J using `neo4j-admin database` along with other files.

Here are my files

`HEADER`
```
id:ID,:LABEL,amount:double,measureUnit:string,gramWeight:double,embedding:LIST&lt;FLOAT&gt;
```

`DATA`
```
FFP_0_321358,FoodPortion_3_0_0,2,&quot;tablespoon&quot;,33.9,[0.1671835333108902,-0.7092851996421814,0.14913123846054077,0.7785872220993042,-0.312934011220932,0.08211034536361694,-0.028107712045311928,-0.25594303011894226,0.5699977278709412,0.6135631799697876,0.19823063910007477,0.09847097098827362,-0.6676387190818787,0.004426721017807722,-0.5394071340560913,0.9914360046386719,0.37802284955978394,0.2705143392086029,-0.06354071199893951,-0.3283253610134125,-0.12500542402267456,0.5226773023605347,-0.5599125623703003,-0.17582887411117554,0.33407628536224365,0.8492608666419983,1.6623034477233887,1.037268877029419,0.22571976482868195,0.5713614821434021,0.004049248062074184,-0.3291890323162079,-0.2762421667575836,0.2313031107187271,-0.1946457028388977,-0.17294952273368835,-0.08332429081201553,0.3433372676372528,0.5293984413146973,1.145921230316162,-0.6517155170440674,0.8047919273376465,0.012163370847702026,0.3513254225254059,-0.04551488906145096,0.2955775856971741,-0.023389466106891632,0.06517010182142258,-0.1647074818611145,-0.0821857675909996,0.23624971508979797,-0.7499469518661499,0.3026871979236603,-0.996300995349884,0.4166252911090851,0.338083416223526,1.4630589485168457,0.3421212434768677,-0.740848183631897,0.10450270026922226,-0.5746254920959473,0.9487141370773315,-0.6349362134933472,0.6473907232284546,0.737545907497406,0.631997287273407,-0.585864782333374,-1.2288835048675537,-0.4180561304092407,-0.2542168200016022,0.2972530126571655,0.14671950042247772,-0.22330710291862488,-0.602167546749115,0.29623106122016907,0.7523813247680664,-0.7711286544799805,-0.46698877215385437,-0.6049727201461792,0.5525864362716675,0.3214971125125885,-0.0008972518844529986,0.024934018030762672,0.09121513366699219,-0.99419105052948,0.01268870010972023,-0.25948208570480347,0.0844053328037262,-0.198614239692688,-0.03724987059831619,-0.6223516464233398,0.616694450378418,-0.7710570693016052,0.1813107579946518,0.2166164517402649,-0.2937754690647125,0.03168824687600136,-0.09738413244485855,-0.9887257814407349,-0.2576909363269806,-0.003925889730453491,0.039951808750629425,-0.1942584365606308,0.01654890924692154,0.027941200882196426,0.060958266258239746,0.31667277216911316,-0.5193405747413635,-0.5178394317626953,0.2285129725933075,-0.3170968294143677,-0.2246341109275818,0.2833319902420044,-0.5099343657493591,-0.49715498089790344,-0.3493226170539856,0.3292626142501831,0.24636048078536987,0.7207037210464478,0.16913318634033203,-0.6909018754959106,0.06924944370985031,0.4800015687942505,-0.2168654501438141,0.5917078852653503,0.23160593211650848,0.537395715713501,0.7937036752700806,0.17396502196788788,-0.3983372151851654,0.8670725226402283,-0.21596691012382507,0.7286391854286194,0.338647723197937,-0.541279137134552,-0.24414321780204773,0.7341932058334351,0.4927745461463928,-0.7745022177696228,0.8004167079925537,-0.6826944947242737,0.13118436932563782,-0.19548332691192627,0.07437360286712646,-0.5719180703163147,0.24923273921012878,-0.5927393436431885,0.8679149150848389,0.5983684062957764,-0.027823010459542274,0.7718298435211182,-0.4654153287410736,-1.3462893962860107,0.7995166182518005,-0.011185641400516033,-0.4824565351009369,0.5111072063446045,-0.44001948833465576,-0.3706497848033905,-0.5190173983573914,0.32828569412231445,-0.08511803299188614,-0.2909694015979767,0.6947621703147888,-0.48054996132850647,0.9403616786003113,0.9104567766189575,-0.3861950635910034,0.12150025367736816,-1.0906805992126465,-0.4025906026363373,0.9348596930503845,-1.0202574729919434,0.20373153686523438,-0.523996114730835,0.053802911192178726,0.24222053587436676,0.3762281537055969,-0.5176705121994019,-0.20220249891281128,0.03934430330991745,0.09392368793487549,0.7321622967720032,-0.14787785708904266,0.09097499400377274,-1.0559947490692139,0.48921504616737366,0.05759872868657112,0.8594281077384949,0.7001445293426514,-0.5685751438140869,-1.088683009147644,-0.6474522948265076,0.7292926907539368,0.09484611451625824,-0.13430261611938477,0.5815054774284363,-0.12725986540317535,-0.2390153408050537,-0.5564658641815186,0.03633316978812218,-0.13943913578987122,0.8008201122283936,-0.03932861611247063,-0.592444121837616,-0.28947505354881287,-1.3887320756912231,-0.2919691503047943,0.10906774550676346,-0.16127485036849976,0.4028816521167755,0.18391253054141998,-0.4581294655799866,0.7862441539764404,-0.8642418384552002,-0.8036615252494812,-0.20525407791137695,0.0392296127974987,0.9526417255401611,0.42765557765960693,0.33285951614379883,-0.5506075620651245,-0.6694586873054504,0.07510815560817719,-0.038032107055187225,-0.03092881664633751,-0.04241414740681648,0.1725407838821411,-0.5417670607566833,-0.5349268317222595,-0.5855259299278259,0.5592337250709534,0.4357283115386963,-0.47289806604385376,0.4332028329372406,-0.8731499910354614,0.6391263604164124,-0.5809072256088257,0.13061028718948364,0.1224871352314949,-0.35391929745674133,0.005123510956764221,-0.035462722182273865,-0.3733997642993927,-0.28362974524497986,-0.5538771152496338,0.3602936565876007,-0.6868255138397217,-0.03687463328242302,-0.02161470241844654,-0.01347095426172018,0.33665063977241516,0.17859768867492676,-0.11408817768096924,0.9829856157302856,0.2166203111410141,-0.8720398545265198,0.5416585206985474,0.4413844347000122,-0.45122820138931274,0.6702153086662292,-0.8764693140983582,-0.2828983664512634,-0.3100939989089966,-0.12255239486694336,-1.0492029190063477,-0.8187520503997803,0.24328432977199554,-0.6477587223052979,-0.5662667155265808,0.5299931168556213,-0.16486720740795135,-0.5515258312225342,-0.4993116557598114,0.20804063975811005,0.5959509611129761,-0.5303364992141724,0.33830690383911133,0.6449111104011536,0.15322712063789368,-0.5701629519462585,-0.8095422387123108,0.299686998128891,-0.15813173353672028,-0.42938998341560364,0.01225562859326601,0.2296690195798874,-0.003090759040787816,-0.4748457670211792,-0.6214565634727478,-0.34394094347953796,0.25212395191192627,0.6680505275726318,-0.4346116781234741,0.05700011923909187,-0.5419701337814331,-0.06856900453567505,0.22415021061897278,0.39412787556648254,0.15209266543388367,-0.12497655302286148,-0.14452865719795227,0.10466565191745758,-0.885491669178009,0.16965919733047485,0.3295234143733978,0.5647721886634827,0.6704097390174866,0.3424019515514374,-0.03930060938000679,-0.09012854844331741,-0.4867702126502991,-0.19723494350910187,-0.3999251127243042,-0.12402091920375824,-0.3148922622203827,-0.03522349148988724,0.08981114625930786,-0.5273032784461975,-0.2906345725059509,-0.008796274662017822,0.10828336328268051,-0.5253278017044067,0.32934826612472534,0.1370808184146881,0.40024134516716003,0.15117497742176056,-0.39427340030670166,0.28206363320350647,0.03590822592377663,-0.5984677076339722,-0.7090610861778259,-0.9651968479156494,0.2385367751121521,-0.6296990513801575,0.4865530729293823,-0.3372344374656677,-0.4074413478374481,0.40377700328826904,0.2570020258426666,0.4174588918685913,0.8144797086715698,0.36606156826019287,0.3249886631965637,-0.3144724667072296,-0.13040763139724731,0.11302396655082703,-0.5673134326934814,-0.302737295627594,0.07992523908615112,0.8787054419517517,1.172546148300171,0.4492942988872528,-0.030851297080516815,0.2505459785461426,0.41262075304985046,-0.49564653635025024,0.8719723224639893,0.07523376494646072,-1.1572521924972534,-0.01636483334004879,-0.26380544900894165,-1.4837547540664673,0.5048713088035583,-0.08823634684085846,0.07521479576826096,-0.49488142132759094,0.26249536871910095,-0.6110193729400635,-0.2207442820072174,-0.6484773755073547,1.0147236585617065,-0.44640663266181946,-0.5317413806915283,-0.14681464433670044,-1.1751823425292969,0.23739926517009735,0.7769442796707153,0.5977027416229248,-0.09468377381563187,-0.1947668194770813,0.8031347990036011,-0.27485743165016174,0.3829503059387207,0.008609862998127937,-0.12533974647521973,-0.14479875564575195,0.09938973188400269,0.32281163334846497,0.9557879567146301,0.44236403703689575,-0.3139778673648834,-0.6251403093338013,-0.9560933709144592,-0.026251723989844322,1.0045522451400757,-0.37324783205986023,-1.1330887079238892,-0.7285730242729187,-0.8578240871429443,0.283489465713501,0.3208872675895691,-0.19238921999931335,0.018476346507668495,-0.5433160066604614,0.7849560379981995,0.6621338725090027,-0.04260914772748947,0.5969443321228027,0.44642236828804016,-0.26311758160591125,-0.9876590371131897,0.3932715058326721,-0.15448811650276184,0.13365773856639862,-0.0799962505698204,0.7488629817962646,-0.6475675106048584,-0.009853999130427837,-0.7468257546424866,0.47061026096343994,-0.3518182933330536,-0.18345221877098083,-0.5140756368637085,0.1674567610025406,-0.9340670704841614,-0.025641120970249176,-0.34011444449424744,-0.8153799176216125,-0.26087984442710876,0.3495074212551117,-0.07597187161445618,0.6782748699188232,-0.12641578912734985,1.2685917615890503,-0.8028026819229126,0.5285968780517578,0.5295302271842957,0.3867567479610443,-0.1515539586544037,-1.0572096109390259,-0.49948495626449585,-0.39823028445243835,-0.8323652744293213,-0.9415347576141357,0.6449390053749084,-0.14691118896007538,0.04789162799715996,1.2827277183532715,-0.09551580995321274,0.603675901889801,0.09274474531412125,1.0837756395339966,0.4858129918575287,-0.9330762028694153,0.09257236123085022,-0.6846525073051453,0.6818339824676514,0.4644860029220581,0.8943250179290771,-0.5759118795394897,-0.05204038321971893,-1.039456844329834,-0.7968854308128357,0.25239646434783936,0.4111694395542145,0.0011898776283487678,0.04329173266887665,-0.7683977484703064,0.09674887359142303,0.5332443118095398,-0.8648918271064758,-0.4710420072078705,0.2660006582736969,0.22469790279865265,0.5526612401008606,-0.2161717712879181,-0.48416608572006226,-0.924457848072052,0.5668873190879822,0.4644615948200226,0.016160206869244576,-0.16353924572467804,-0.13962322473526,-0.3175646960735321,0.4352322518825531,0.6779831051826477,0.9168933033943176,-0.7922529578208923,0.5794135332107544,-0.05354280769824982,-0.3465318977832794,0.06871140003204346,-0.2459251582622528,-0.05720151960849762,0.32953858375549316,-0.44721513986587524,0.050602808594703674,0.8087331056594849,-0.5344159603118896,0.305500328540802,-0.18340158462524414,-0.19031253457069397,-0.309244304895401,-0.2884880304336548,0.11887530237436295,0.18470722436904907,0.199752539396286,-0.06084237992763519,0.24666717648506165,-0.26213422417640686,0.49224817752838135,0.48226016759872437,-0.5415734052658081,-0.3253564238548279,1.3615599870681763,0.5222530364990234,-0.32182902097702026,0.46122345328330994,0.24173259735107422,-0.0673547014594078,0.5831491351127625,1.2432188987731934,0.49218353629112244,-0.5042010545730591,0.7092238664627075,0.06750074774026871,-0.09383261948823929,-0.0081543093547225,0.44860950112342834,-0.1970268189907074,-0.28806084394454956,0.6269216537475586,-0.803895890712738,-0.22598743438720703,0.5601255893707275,-0.3778359591960907,0.2135166972875595,-0.7522717118263245,-0.779211163520813,0.1779584139585495,-0.11637934297323227,-0.5567536354064941,0.4780929386615753,0.07993963360786438,1.180921196937561,-1.0012739896774292,1.0854748487472534,1.2030161619186401,-0.39551323652267456,-0.3470480144023895,-0.5964025259017944,-0.003305548569187522,-0.5828757882118225,0.6706764698028564,-0.07850617915391922,0.16851960122585297,-0.20571738481521606,-0.268282413482666,-0.7996156215667725,0.33568376302719116,-0.12711429595947266,-0.25941455364227295,-0.015434486791491508,0.42356789112091064,-0.13292774558067322,0.0037969565019011497,-0.18581432104110718,0.9464324116706848,0.8409354090690613,0.4372020363807678,-0.6313837170600891,-0.055603086948394775,0.09673861414194107,0.3239489793777466,-0.06169762834906578,-0.7502389550209045,0.7076743245124817,-0.45781442523002625,-0.16617447137832642,0.38411039113998413,1.180161476135254,0.21009182929992676,0.11365732550621033,0.5472085475921631,1.1442530155181885,0.2281898409128189,0.2820669710636139,0.9721088409423828,0.5765435099601746,0.4725164771080017,0.8732017874717712,-0.15962526202201843,-0.06697147339582443,0.9765822291374207,-0.6608487963676453,0.43563368916511536,0.46180063486099243,0.11050009727478027,0.5212056636810303,0.6355578899383545,-0.280332088470459,0.11997316777706146,-0.800595760345459,-0.287690669298172,0.43648675084114075,0.026447953656315804,-0.4591667354106903,-0.9742065072059631,-0.11056825518608093,0.07913459837436676,0.3082919120788574,0.22297149896621704,0.4662155508995056,0.24451857805252075,-0.3344615399837494,0.6512241363525391,0.04811880365014076,-0.011844181455671787,-0.10874098539352417,-0.20612436532974243,-0.27597931027412415,0.6450008749961853,0.038915444165468216,-0.8701965808868408,0.19781824946403503,-0.5256267189979553,-0.1740768998861313,-0.16985800862312317,0.12679293751716614,-0.4636904299259186,-0.16456031799316406,-0.21601201593875885,0.27244970202445984,0.41580191254615784,0.47157996892929077,-1.0791044235229492,0.27602824568748474,-0.12321404367685318,-0.1431848406791687,-0.016102466732263565,-0.11164054274559021,0.3355039954185486,0.7526078820228577,0.3873237371444702,0.43889203667640686,0.020581483840942383,0.0665377601981163,0.7098839282989502,-1.2233948707580566,-0.8678389191627502,-0.30513134598731995,0.3215208649635315,-0.3935432434082031,-0.5412213206291199,1.115997314453125,0.9920573830604553,0.914484977722168,-0.9107837677001953,0.017293615266680717,-0.2077222615480423,0.2669888138771057,0.22706453502178192,0.649146318435669,-0.4583829343318939,-0.22682905197143555,0.2800329625606537,-1.0090821981430054,-0.362485408782959,0.4176114797592163,0.1970158964395523,-0.38053134083747864,0.5054555535316467,0.6325038075447083,-0.4901634752750397,0.21487581729888916,0.31514257192611694,0.20230068266391754,-0.10582146048545837,0.22879809141159058,0.8290401101112366,-0.5272077918052673,-0.1003471314907074,-0.4193391501903534,-0.3952881693840027,-0.5583227872848511,-0.6888096332550049,-0.0452975295484066,-0.13799642026424408,-0.62837815284729,-0.4729372262954712,-0.14849378168582916,1.0821017026901245,0.9769520163536072,-1.0336458683013916,-0.852587878704071,0.9743750691413879,0.370536208152771,-0.6756088137626648,-0.23825114965438843,-0.1673172116279602,-0.07628379762172699,-0.5976764559745789,0.7753019332885742,0.6446144580841064,0.5124966502189636,0.31413015723228455,-0.00003639691567514092,-0.8735217452049255,0.5028191208839417,0.49051231145858765,0.2277340292930603,-0.6177209615707397,-0.30641138553619385,-0.605127215385437,-0.2127356231212616,0.28962069749832153,0.7604162096977234,-0.3130319118499756,-0.11445695906877518,0.4159240424633026,0.6234878301620483,0.2780379056930542,0.5945948958396912,0.37354910373687744,-1.0610800981521606,0.521527111530304,0.31822124123573303,0.33180931210517883,-0.10160930454730988,-0.513020396232605,0.570996105670929,0.47622430324554443,-0.8863240480422974,-0.44037914276123047,-0.3269352912902832,-1.8785266876220703,-0.6457673907279968,0.8876060247421265,-0.08890876173973083,-1.0130339860916138,-0.2681725323200226,-0.025494800880551338,0.30071747303009033,-0.7092866897583008,0.8538867831230164,-0.08444361388683319,0.1759151965379715,-0.0645117536187172,-0.6093289852142334,0.3150272071361542,0.6975864768028259,-0.7012813687324524,-0.22271794080734253,0.649813711643219,0.5986615419387817,-0.08681211620569229,0.04726758971810341,-0.36053359508514404,0.36199748516082764,-0.09300746023654938,-0.1462542563676834,-0.13827596604824066,-0.6411302089691162,0.06707187741994858,0.31476008892059326,0.3629421889781952,-1.0855286121368408]
```

My command is 
```
neo4j-admin database import full --nodes=datasets/bulk/t/ff_sr_fndds_food_portions_header.csv,datasets/bulk/t/ff_sr_fndds_food_portions.csv --relationships=datasets/bulk/t/ff_sr_fndds_food_portions_relations_header.csv,datasets/bulk/t/ff_sr_fndds_food_portions_relations.csv
```

It fails with the following error
```
org.neo4j.internal.batchimport.input.HeaderException: Unable to parse header, unknown property type &#39;LIST&lt;FLOAT&gt;&#39;
	at org.neo4j.internal.batchimport.input.csv.DataFactories.parsePropertyType(DataFactories.java:483)
	at org.neo4j.internal.batchimport.input.csv.DataFactories$AbstractDefaultFileHeaderParser.propertyExtractor(DataFactories.java:280)
	at org.neo4j.internal.batchimport.input.csv.DataFactories$DefaultNodeFileHeaderParser.create(DataFactories.java:410)
	at org.neo4j.internal.batchimport.input.csv.DataFactories.parseHeaderEntries(DataFactories.java:196)
	at org.neo4j.internal.batchimport.input.csv.DataFactories$AbstractDefaultFileHeaderParser.create(DataFactories.java:221)
	at org.neo4j.internal.batchimport.input.csv.CsvInput.verifyHeaders(CsvInput.java:164)
	at org.neo4j.internal.batchimport.input.csv.CsvInput.&lt;init&gt;(CsvInput.java:145)
	at org.neo4j.internal.batchimport.input.csv.CsvInput.&lt;init&gt;(CsvInput.java:108)
	at org.neo4j.importer.CsvImporter.doImport(CsvImporter.java:175)
	at org.neo4j.importer.ImportCommand$Base.doExecute(ImportCommand.java:431)
	at org.neo4j.importer.ImportCommand$Full.execute(ImportCommand.java:590)
	at org.neo4j.cli.AbstractCommand.call(AbstractCommand.java:92)
	at org.neo4j.cli.AbstractCommand.call(AbstractCommand.java:37)
	at picocli.CommandLine.executeUserObject(CommandLine.java:2041)
	at picocli.CommandLine.access$1500(CommandLine.java:148)
	at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461)
	at picocli.CommandLine$RunLast.handle(CommandLine.java:2453)
	at picocli.CommandLine$RunLast.handle(CommandLine.java:2415)
	at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273)
	at picocli.CommandLine$RunLast.execute(CommandLine.java:2417)
	at picocli.CommandLine.execute(CommandLine.java:2170)
	at org.neo4j.cli.AdminTool.execute(AdminTool.java:94)
	at org.neo4j.cli.AdminTool.main(AdminTool.java:82)
Caused by: java.lang.IllegalArgumentException: &#39;LIST&lt;FLOAT&gt;&#39;
	at org.neo4j.csv.reader.Extractors.valueOf(Extractors.java:199)
	at org.neo4j.internal.batchimport.input.csv.DataFactories.parsePropertyType(DataFactories.java:481)
	... 22 more
root@51d13ae3cbf2:/var/lib/neo4j/import# 
```

I am using neo4j in my docker with following version
```
root@51d13ae3cbf2:/var/lib/neo4j/import# neo4j version
neo4j 5.13.0
```

It seems admin command only understand simple types like `STRING`, `INT`, etc. so, how can I fix this issue? ","1700596915","","","","https://stackoverflow.com/q/77525633","","","Question","Importing Vector Embedding in Neo4J via neo4j-admin import is failing with unknown property type &#39;LIST&lt;FLOAT&gt;&#39;","false","77525633","18",,,,,
"455",":User","","","","","daydreamer","","","","","","User","","false","379235","",,,,,
"456",":Question","77525820","2","I&#39;ve got a Neo4j DB that contains `Resource` nodes with several relationship nodes including `Tag`, `Address`, `PhoneNumber`, etc.

The schema for `Resource` is as follows:
```
Resource: {
  name: str,
  description: str,
  legal_name: str,
  organization_type: str,
}
```

The schema for `Tag` is as follows:
```
Tag: {
  tag: str,
}
```

I&#39;m building a query that returns all `Resource` nodes along with their relationship nodes where the `Resource` node has a property that contains a specific string AND/OR related `Tag` node(s) has(ve) a property that contains the same string.

Example cases to return:
1. A `Resource` node DOES have one or more property that contains the string &quot;school&quot; but all related `Tag` nodes DO NOT have a `tag` property containing the string &quot;school&quot;: the `Resource` node is returned along with all of its relationship nodes
2. A `Resource` node DOES NOT have any properties that contain the string &quot;school&quot; but has at least one related `Tag` node that DOES have a `tag` property containing the string &quot;school&quot;: the `Resource` node is returned along with all of its relationship nodes
3. A `Resource` node DOES have one or more property that contains the string &quot;school&quot; and has at least one related `Tag` node that DOES have a `tag` property containing the string &quot;school&quot;: the `Resource` node is returned along with all of its relationship nodes

  I&#39;m currently using the below query and it works for the most part; however, for case 2 above no other relationship nodes of the originating `Resource` node are returned in the result set.  Ideally, we would ALWAYS get all relationship nodes of the `Resource` node matching the above criteria.  Any help would be greatly appreciated!

```
MATCH (n:Resource)-[]-&gt;(m) 
WHERE n.name CONTAINS &#39;school&#39;
    OR n.description CONTAINS &#39;school&#39;
    OR n.legal_name CONTAINS &#39;school&#39;
    OR n.organization_type CONTAINS &#39;school&#39;
    OR m.tag CONTAINS &#39;school&#39;
RETURN n, collect(m);
```","1700589233","","","","https://stackoverflow.com/q/77524947","","","Question","[Neo4j][Cypher Query] Filter On Node or Relationship Node Properties and Then Return All Nodes and Their Relationship Nodes","false","77524947","58",,,,,
"457",":User","","","","","Daniel Kohli","","","","","","User","","false","6487302","",,,,,
"458",":Question","","0","I&#39;ve noticed that Neo4J Enterprise docker image is taking a lot of time to actually startup.

[![enter image description here][1]][1]

In this example you can see that it takes over 13 minutes just to start. Also, in this example, I&#39;ve done a clean start, meaning I&#39;ve deleted all data (databases and transactions).

This is the command I&#39;m running:

&gt; docker run --name Neo4J \
    -p 7474:7474 -p 7687:7687 \
    -d \
    -v C:/Docker/Neo4J/data:/data:z \
    -v C:/Docker/Neo4J/logs:/logs:z \
    -v C:/Docker/Neo4J/plugins:/plugins:z \
    -v C:/Docker/Neo4J/data/backups:/data/backups:z \
    --env NEO4J_AUTH=neo4j/11111111 \
	--env NEO4J_dbms_memory_pagecache_size=5G \
	--env NEO4J_dbms_memory_heap_initial__size=5G \
	--env NEO4J_dbms_memory_heap_max__size=5G \
    --env NEO4J_dbms_ssl_policy_bolt_client__auth=NONE \
    --env NEO4J_dbms_ssl_policy_https_client__auth=NONE \
    --env NEO4J_ACCEPT_LICENSE_AGREEMENT=yes \
    --env NEO4J_apoc_export_file_enabled=true \
    --env NEO4J_apoc_import_file_enabled=true \
    --env NEO4J_apoc_import_file_use__neo4j__config=true \
    --env NEO4JLABS_PLUGINS=&#39;[&quot;apoc&quot;]&#39; \
    neo4j:4.4-enterprise

Right now I&#39;m running this on a Windows machine (Dell XPS 15 - i9 13900H with 64GB Ram) so machine wise I don&#39;t see any bottlenecks. In the past I&#39;ve ran this on a Mac and sometimes it would also be slow to startup but not this frequent.

Does anybody ever has this issue? What have you done to solve it?

Regards!


  [1]: https://i.stack.imgur.com/GMw9t.png","1700585065","","","","https://stackoverflow.com/q/77524536","","","Question","Neo4J Docker Image Takes Too Long to Start","false","77524536","29",,,,,
"459",":User","","","","","Ricardo Mota","","","","","","User","","false","4333113","",,,,,
"460",":Question","","0","I downloaded the neo4j OVA from bitnami and spun it up on my VSphere Server. The installed version of Neo4j on this prepackaged VM is 5.13 Community Edition.

It has a static IP address (192.168.1.6)

I am able to connect via SSH, I can ping it, and everything&#39;s fine here

The neo4j.conf was altered like this:

    server.default_listen_adress = 0.0.0.0
    server.default_advertised_adress = 192.168.1.6
    server.bolt.enabled=true
    server.bolt.list_adress=:7687
    server.bolt.advertised_adress=:7687
    server.http.enabled=true
    server.http.listen_adress=:7474
    server.http.advertised_adressadress=:7474
    
The `sudo neo4j-admin server validate-config` does not show any errors

I am able to connect to the graph from within the server VM using `cyper-shell -a localhost -u neo4j -p myPassword`, so I know the user credentials work.

The `ss -tulpn` shows
|netid|state|Local Address:Port|Peer Address:Port|
|:----|:----|:-----------------|:----------------|
|tcp|LISTEN|*:7687|* : *|
|tcp|LISTEN|*:7474|* : *|


But whatever I try to use to connect this server as a remote connection within the Neo4j Desktop Client, I can&#39;t get a connection. Every possible combination of port, and protocol (neo4j, bolt, neo4j+s, etc.) just yields &quot;Unable to establish remote connection: ServiceUnavailable&quot;.

What am I doing wrong? Is it just not possible to connect to a community edition using the Desktop app?","1700584010","","","","https://stackoverflow.com/q/77524421","","","Question","Unable to connect to neo4j VM on the network via Neo4jDesktop","false","77524421","23",,,,,
"461",":User","","","","","Pantheos Max","","","","","","User","","false","4824040","",,,,,
"462",":Question","","1","```
MATCH (t1:Tel {TB:true})&lt;-[:TelBIZ]-
  (:ACC {TB:true})-[or:REBIZ {movOre:t1.nuTel}]-&gt;
  (:ACC {TB:true})-[:TelBIZ]-&gt;(t2:Tel {TB:true,nuTel:or.movBene}) 
WHERE t1.nuTel&lt;&gt;t2.nuTel
RETURN t1, t2, COUNT(or) AS Ope, SUM(or.imp) AS Total, 
  10^3 as Precision, max(or.Txt) AS mRB
```

I am trying to get this query to return few values, but I find the query is not optimised and returns a lot of data. Please suggest me how I can optimize it. I am using Neo4j v3.5.","1700566122","","","","https://stackoverflow.com/q/77522450","","","Question","Optimization of a MATCH statement","false","77522450","58",,,,,
"463",":User","","","","","Somnath Deb","","","","","","User","","false","22845737","",,,,,
"464",":Question","","1","I&#39;m using Neo4jClient to do the following query for retrieving nodes and relationships by paths.
```
    public Collection&lt;Map&lt;String, Object&gt;&gt; findBookByUniqueIds(List&lt;String&gt; srcUniqueIds, String name) {

        return neo4jClient.query(
                        &quot;&quot;&quot;
                                MATCH path = (src:Book)-[*1..2]-(target:Book)
                                WHERE src.uniqueId IN $uniqueIds
                                AND toUpper(target.name) = toUpper($name)
                                RETURN nodes(path) AS nodes, relationships(path) AS relations
                                &quot;&quot;&quot;)
                .bind(srcUniqueIds).to(&quot;uniqueIds&quot;)
                .bind(name).to(&quot;name&quot;)
                .fetch().all();
    }
```

And I extract the data like this:
```
Collection&lt;Map&lt;String, Object&gt;&gt; result = findBookByUniqueIds(ids, name);
List&lt;Object&gt; nodes = (List&lt;Object&gt;) result.get(&quot;nodes&quot;);
List&lt;Object&gt; relationships = (List&lt;Object&gt;) result.get(&quot;relations&quot;);
```

When I was trying to cask the node back to entity class:
```
if (nodes.size() == 2) {
    Book book1 = (Book) nodes.get(0);
    Book book2 = (Book) nodes.get(1);
} else if (nodes.size() == 3) {
    Book book1 = (Book) nodes.get(0);
    Author author = (Author) nodes.get(1);
    Book book2 = (Book) nodes.get(2);
}
```
And I got the exception `java.lang.ClassCastException: class org.neo4j.driver.internal.InternalNode cannot be cast to class xxx`

Any idea on how to convert the node back to entity class?

Thanks","1700534522","","","","https://stackoverflow.com/q/77520005","","","Question","Spring data Neo4j can&#39;t convert InternalNode back to entity class when retrieving paths","false","77520005","75",,,,,
"465",":Question","","1","Is it possible to show data in hex format if I stored data as byte array using Neo4j Browser?
It is 16 bytes of md5 sum.
","1700473840","","","","https://stackoverflow.com/q/77514862","","","Question","Display byte array as hex string in Neo4j Browser","false","77514862","25",,,,,
"466",":User","","","","","Hett","","","","","","User","","false","1491378","",,,,,
"467",":Question","77576603","1","I&#39;m testing the new Neo4j PARALLEL runtime and am unable to pass my tests because my queries return different results (different elements order) compared to SLOTTED or PIPELINED. Do I need to somehow refine these queries so that they work properly on PARALLEL runtime? Do you have any docs on this? Or, are these refinements unnecessary, and the queries should return exactly the same result as on SLOTTED or PIPELINED?

Also, there is a limitation `It is not possible to use the parallel runtime if a change has been made to the state of a transaction.` https://neo4j.com/docs/cypher-manual/current/planning-and-tuning/runtimes/reference/

Unfortunately, I have many scenarios where I currently use `apoc.cypher.mapParallel2` to read data in the same transaction where I&#39;m updating it. I would like to transition to the PARALLEL runtime, but I am unable to do so due to this limitation. Are you planning to overcome this limitation in the future?","1700350923","","","","https://stackoverflow.com/q/77509091","","","Question","Neo4j PARALLEL runtime query returns different result","false","77509091","157",,,,,
"468",":Question","77508731","1","&gt; This question follows up on [@cybersam&#39;s answer to one of my previous questions](https://stackoverflow.com/a/77499034/4756173), however no previous knowledge about this problem is necessary.

In a pattern-search query, a simplified version of [@cybersam&#39;s query here](https://stackoverflow.com/a/77499034/4756173), I would like to, ideally, match paths not only to an input pattern but to all of its isomorphisms (board rotations and reflections) and permutations.

&gt; A pattern in this case is a list of strings (A-Z) of length 2, e.g. `[&#39;pq&#39;, &#39;dd&#39;, &#39;pp&#39;]`.

So, in that query, I would have to create an `OR` statement for each pattern in a pattern list:

```cypher
MATCH p =   (mFirst:MoveNode)
           -[:NEXT_MOVE*${patternLength - 1}]
          -&gt;(:MoveNode)

WHERE (
            mFirst.move = HEAD($patterns[0]) 
        AND [m IN NODES(p) | m.move] = $patterns[0]
      )
   OR (
            mFirst.move = HEAD($patterns[1]) 
        AND [m IN NODES(p) | m.move] = $patterns[1]
      )
   OR (...)
   .
   .
   .
```

Is there a way of making this programmatic? Cause, this isn&#39;t scalable, since I don&#39;t know how many permutations I&#39;m gonna end up having. ","1700340432","","","","https://stackoverflow.com/q/77508656","","","Question","Practical Way of Doing Equality Against Multiple Possible Values in Cypher","false","77508656","29",,,,,
"469",":User","","","","","Philippe Fanaro","","","","","","User","","false","4756173","",,,,,
"470",":Question","","0","I have a Spring Boot webapp with embedded neo4j and I want to execute custom Cypher and get a response in form of Json. Like that:
```
try (var tx = graphDatabaseService.beginTx()) {
  org.neo4j.graphdb.Result result = tx.execute(cypherQuery);
  String json = JsonSerializer.writeValueAsString(result);
}
```

I assume such serializer exists (which can take Result, Node, Relationship etc objects) because there is a `org.neo4j.configuration.connectors.HttpConnector` which enables Http endpoint which allows to do exactly what I need:

https://neo4j.com/docs/http-api/current/query/
```
{
  &quot;results&quot;: [ {
    &quot;columns&quot;: [ &quot;p&quot; ],
    &quot;data&quot;: [ {
      &quot;row&quot;: [ {
        &quot;name&quot;: &quot;Bob&quot;
      } ],
      &quot;meta&quot;: [ {
        &quot;id&quot;: 8,
        &quot;elementId&quot;: &quot;4:0ea4a108-32c5-498c-99e7-95cc67ab5f7d:8&quot;,
        &quot;type&quot;: &quot;node&quot;,
        &quot;deleted&quot;: false
      } ]
    ] }
  ] },
  {
    &quot;columns&quot;: [ &quot;n&quot; ],
    &quot;data&quot;: [ {
      &quot;row&quot;: [ {
        &quot;val&quot;: 1
      } ],
      &quot;meta&quot;: [ {
        &quot;id&quot;: 1,
        &quot;elementId&quot;: &quot;4:0ea4a108-32c5-498c-99e7-95cc67ab5f7d:1&quot;,
        &quot;type&quot;: &quot;node&quot;,
        &quot;deleted&quot;: false
      } ]
    } ]
  } ],
  &quot;errors&quot;: [ {
    &quot;code&quot;: &quot;Neo.ClientError.Statement.ArithmeticError&quot;,
    &quot;message&quot;: &quot;/ by zero&quot;
  } ]
}
```
but HttpConnector doesn&#39;t work in embedded neo4j. But maybe I can use just serializer, not whole endpoint.

[This question](https://stackoverflow.com/q/17412784/20340543) and answers show how it can be written manually, but probably such class should exist in `org.neo4j.neo4j` maven artifact already. I can&#39;t find it.

Another approach is to use [apoc export json](https://neo4j.com/labs/apoc/4.1/export/json/) function but it requires enabling apoc plugin and there is no info on how to do it for embedded db.","1700253706","","","","https://stackoverflow.com/q/77504521","","","Question","Execute Cypher and get Json response from embedded db","false","77504521","25",,,,,
"471",":User","","","","","Podbrushkin","","","","","","User","","false","20340543","",,,,,
"472",":Question","77502358","1","Looks like Neo4j is naturally stepping into the world of parallel processing with the brand new parallel runtime in version 5.13.0.

Thus, I have a question: Is it possible with Neo4j to utilize GPU power for parallel processing instead of the CPU? If not, do you have plans to support it?","1700226655","","","","https://stackoverflow.com/q/77501923","","","Question","Neo4j parallel runtime and GPU","false","77501923","82",,,,,
"473",":Question","77499034","2","I&#39;m trying to reproduce a Go SGF game tree in Neo4j through Cypher so I can pattern-search through, as a graph. This is the shape of a Go game tree &amp;mdash; based on [Sabaki&#39;s SGF Parser](https://github.com/SabakiHQ/sgf) &amp;mdash;:

```typescript
type GameTree = {
  id: number;
  data: { [key: string]: string[] };
  parentId: number | null;
  children: GameTree[];
};
```

&gt; You can find a reproducible sample of the problem [in this commit](https://github.com/psygo/go_pattern_search/tree/01a11ff85b85e226b2f222aa4743e87842649651).

So far, I&#39;ve successfully managed to model it just like it appears in a Go editor&#39;s game tree:

[![Game Tree on Neo4j Desktop][1]][1]

&gt; `B` and `W` mean Black and White moves. `AB` and `AW` are &quot;added black or white stones&quot;, for when editing the board position. For this question&#39;s purposes, only `move` matters actually, which has the same value as either `B` or `W`. Board coordinates are given in 2 letters, e.g. column `m` and row `r` gives out the string `&#39;rm&#39;`.

Now, what I would like to do is return the full path (probably the root node would suffice actually) from the root if a specified subpath (no skipping) is found. So far, I have this, which does work:

```cypher
MATCH p=(g:GameNode)-[:NEXT_MOVE*]-&gt;()

WITH g, p,
     [m in TAIL(NODES(p)) | m.move] AS moves

WITH g, p,
     REDUCE(path = &#39;&#39;, move in moves | path + move) AS joined_moves

WHERE joined_moves CONTAINS &quot;rmro&quot;

RETURN g, p, joined_moves
```

Following @cybersam&#39;s answer, I think this could make it more explicit to Neo4j so it uses an index on `m.move` &amp;mdash; e.g. `CREATE INDEX move_node_move_idx FOR (m:MoveNode) ON (m.move)` &amp;mdash;:

```cypher
MATCH p=(g:GameNode)-[:NEXT_MOVE*]-&gt;(m1:MoveNode)-[:NEXT_MOVE*]-&gt;()

WHERE m1.move = HEAD([&#39;rm&#39;, &#39;ro&#39;])

WITH g, p,
     [m in TAIL(NODES(p)) | m.move] AS moves

WITH g, p,
     REDUCE(path = &#39;&#39;, move in moves | path + move) AS joined_moves

WHERE joined_moves CONTAINS &quot;rmro&quot;

RETURN g, p, joined_moves
```

But I really don&#39;t know if this type of pattern-search would be efficient enough through Neo4j or other graph databases. I think it could be since, even though most games have 200+ move branches, there aren&#39;t that many of them usually. And the analysis would be on unidirectional branches where order matters (no skipping), so it should probably limit the search space even more.

Alternatively, I&#39;m considering placing a string with the full path to it in each move node. This way I could use Regexes (I know Regexes can also be modeled as graphs) instead of path searches. That said, if it works, then I think using a SQL database would be probably enough. However, I would probably stick to Neo4j still, cause modeling this as a graph could provide more useful features in the future.

---

## References

- [Stack Overflow - *Neo4j how to match subpath*](https://stackoverflow.com/a/51872011/4756173)
- [Stack Overlflow - *Efficient way of matching a subtree, using cypher in Neo4J?*](https://stackoverflow.com/a/31587455/4756173)


  [1]: https://i.stack.imgur.com/XMF1g.png","1700161233","","","","https://stackoverflow.com/q/77497411","","","Question","How to (Efficiently) Find Subpaths in Recursive Trees through Cypher (Graph vs Regex)","false","77497411","79",,,,,
"474",":Question","77495682","1","I&#39;m trying to replicate an SGF game tree on Neo4j with Cypher. The tree is of this shape:

```typescript
type GameTree = {
  id: number;
  data: { [key: string]: string[] };
  parentId: number | null;
  children: GameTree[];
};
```

This is the creation query I&#39;m trying to work out:

```cypher
UNWIND $moves AS move

MATCH (parent)

WHERE ((parent:GameNode) OR (parent:MoveNode))
  AND parent.game_id = $gameId
  AND parent.id = move.parentId

CREATE   (parent)
        -[:NEXT_MOVE]
       -&gt;(:MoveNode{
           game_id: $gameId,
           id:      move.id
         })
```

Initially, the root of the tree is a `GameNode`, which I create separately, because it holds interesting metadata. Anyways, this won&#39;t work like this because, at the time of the `UNWIND` and `MATCH` clauses, there exists only one parent, the rest of them will/should be created recursively.

Is there a way of doing this recursive creation in Cypher? Maybe there&#39;s some recursive keyword I can&#39;t seem to find (this seems like such a common kind of problem...)? Maybe there&#39;s a useful APOC procedure somewhere?

As a workaround, I&#39;m thinking about creating all the `MoveNode`s first, and then using the query above to string them back together. It would look like this:

```cypher
// 1. Create All The Move Nodes

UNWIND $moveNodes AS move

CREATE (:MoveNode{
         game_id: move.game_id,
         id:      move.id
       })

// 2. Tie them to their Parents

WITH move

MATCH (parent{
        game_id: move.game_id,
        id:      move.parentId
      }),
      (m:MoveNode{
        game_id: move.game_id,
        id:      move.id
      })

WHERE parent:GameNode
   OR parent:MoveNode
  
CREATE (parent)-[:NEXT_MOVE]-&gt;(m)
```","1700140416","","","","https://stackoverflow.com/q/77495108","","","Question","How to Recursively Create a Tree with Cypher (Neo4j)","false","77495108","56",,,,,
"475",":Question","","1","My Requirement is straight forward. I have a API call which retrieves huge amount of data. I want to use PySpark to convert those as Dataframes and write into Neo4J. 

Convert the API result into Dataframes and store it in Neo4j, Could you please let me know if that&#39;s possible?","1700107404","","","","https://stackoverflow.com/q/77492233","","","Question","Connect APIs, Parse the result using pyspark and store it in neo4j","false","77492233","32",,,,,
"476",":User","","","","","Sathyamoorthy","","","","","","User","","false","21190101","",,,,,
"477",":Question","","1","`python 3.8, Windows 10, neo4j==5.14.1, langchain==0.0.336`

I&#39;m attempting to utilize a local Langchain model (GPT4All) to assist me in converting a corpus of loaded `.txt` files into a `neo4j` data structure through querying. I have provided a minimal reproducible example code below, along with the references to the article/repo that I&#39;m attempting to emulate. I have also provided a &quot;context&quot; that should be included in the query, along with all the `Document` objects. I&#39;m still learning how to use `Langchain` so I really don&#39;t know what I&#39;m doing yet, but the current traceback I&#39;m getting looks like this:

```
Traceback (most recent call last):
  File &quot;.\neo4jmain.py&quot;, line xx, in &lt;module&gt;
    prompt_template = PromptTemplate(
  File &quot;C:\Users\chalu\AppData\Local\Programs\Python\Python38\lib\site-packages\langchain\load\serializable.py&quot;, line 97, in __init__
    super().__init__(**kwargs)
  File &quot;pydantic\main.py&quot;, line 339, in pydantic.main.BaseModel.__init__
  File &quot;pydantic\main.py&quot;, line 1102, in pydantic.main.validate_model
  File &quot;C:\Users\chalu\AppData\Local\Programs\Python\Python38\lib\site-packages\langchain\schema\prompt_template.py&quot;, line 76, in validate_variable_names
    if &quot;stop&quot; in values[&quot;input_variables&quot;]:
KeyError: &#39;input_variables&#39;
```

As you&#39;ll see, I&#39;m literally not defining `input_variables` anywhere, so I assume this is a default behaviour of Langchain, but again, not sure. I was also getting an error:

```
LLaMA ERROR: The prompt is 5161 tokens and the context window is 2048!
ERROR: The prompt size exceeds the context window size and cannot be processed.
```

...which is clearly a result of the query string itself being too big. I want to be able to query my documents for the answer, while providing the model with the Documents to reference. How can I do this? The Langchain documentation is not great for noobies in this space, it&#39;s all over the place and lacks MANY, SIMPLE use cases for noobies so I&#39;m asking it here.

```
# https://medium.com/neo4j/enhanced-qa-integrating-unstructured-and-graph-knowledge-using-neo4j-and-langchain-6abf6fc24c27
# https://github.com/sauravjoshi23/ai/blob/main/retrieval%20augmented%20generation/integrated-qa-neo4j-langchain.ipynb

# Script to convert a corpus of many text files into a neo4j graph

# Imports
import os
from langchain.document_loaders import TextLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.llms.gpt4all import GPT4All
from langchain.prompts import PromptTemplate
from transformers import AutoTokenizer

# Load tokenizer
tokenizer = AutoTokenizer.from_pretrained(&quot;bert-base-uncased&quot;)

def bert_len(text):
    &quot;&quot;&quot;Return the length of a text in BERT tokens.&quot;&quot;&quot;
    tokens = tokenizer.encode(text)
    return len(tokens)

def get_files(path: str) -&gt; list:
    &quot;&quot;&quot;Return a list of all files in a directory, recursively.&quot;&quot;&quot;
    files = []
    for file in os.listdir(path):
        file_path = os.path.join(path, file)
        if os.path.isdir(file_path):
            files.extend(get_files(file_path))
        else:
            files.append(file_path)
    return files

# Get the text files
all_txt_files = get_files(&#39;data&#39;)
raw_txt_files = []
for current_file in all_txt_files:
    raw_txt_files.extend(TextLoader(current_file, encoding=&#39;utf-8&#39;).load())

# Create a text splitter object that will help us split the text into chunks
text_splitter = RecursiveCharacterTextSplitter(
    chunk_size = 1024, # 200,
    chunk_overlap = 128, # 20
    length_function = bert_len,
    separators=[&#39;\n\n&#39;, &#39;\n&#39;, &#39; &#39;, &#39;&#39;],
)

# Split the text into &quot;documents&quot;
documents = text_splitter.create_documents([raw_txt_files[0].page_content])

# Utilizing these Document objects, we want to query the GPT4All model to help us create
# a JSON object that contains the ontology of terms mentioned in the given context,
# while mitigating &quot;max_tokens&quot; error.
# Create a PromptTemplate object that will help us create the prompt for GPT4All(?)
prompt_template = PromptTemplate(
    template = &quot;&quot;&quot;
    You are a network graph maker who extracts terms and their relations from a given context.
    You are provided with a context chunk (delimited by ```). Your task is to extract the ontology
    of terms mentioned in the given context. These terms should represent the key concepts as per the context.
    
    Thought 1: While traversing through each sentence, Think about the key terms mentioned in it.
        Terms may include object, entity, location, organization, person,
        condition, acronym, documents, service, concept, etc.
        Terms should be as atomistic as possible
    
    Thought 2: Think about how these terms can have one on one relation with other terms.
        Terms that are mentioned in the same sentence or the same paragraph are typically related to each other.
        Terms can be related to many other terms
        
    Thought 3: Find out the relation between each such related pair of terms.

    Format your output as a list of json. Each element of the list contains
    a pair of terms and the relation between them, like the following:
    [Dict(&quot;node_1&quot;: &quot;A concept from extracted ontology&quot;,
            &quot;node_2&quot;: &quot;A related concept from extracted ontology&quot;,
            &quot;edge&quot;: &quot;relationship between the two concepts, node_1 and node_2 in one or two sentences&quot;,
        ),
    Dict(&quot;node_1&quot;: &quot;A concept from extracted ontology&quot;,
        &quot;node_2&quot;: &quot;A related concept from extracted ontology&quot;,
        &quot;edge&quot;: &quot;relationship between the two concepts, node_1 and node_2 in one or two sentences&quot;,
    ),
    Dict(...)]
    Context Documents: {documents}
    &quot;&quot;&quot;,
    variables = {
        &quot;documents&quot;: documents,
    }
)

# Create a GPT4All object that will help us query the GPT4All model
llm = GPT4All(
    model=r&quot;C:\Users\chalu\AppData\Local\nomic.ai\GPT4All\gpt4all-falcon-q4_0.gguf&quot;,
    n_threads=3,
    max_tokens=5162, # &lt;-- attempt to mitigate &quot;max_tokens&quot; error
    verbose=True,
)

# Get the response from GPT-4-All
response = llm(prompt_template)
print(response)
```","1700103114","","","","https://stackoverflow.com/q/77492026","","","Question","Query GPT4All local model with Langchain and many .txt files - KeyError: &#39;input_variables&#39;","false","77492026","798",,,,,
"478",":User","","","","","wildcat89","","","","","","User","","false","10018602","",,,,,
"479",":Question","","1","I&#39;m using Neo4jClient to do the query since my source and target node have the same label.

Following is how I do the query

```
@Repository
public class Neo4jClientRepository {
    @Autowired
    private Neo4jMappingContext neo4jMappingContext;

    @Autowired
    private Neo4jClient neo4jClient;

    public Collection&lt;NodePair&gt; findNodesByUniqueIds(List&lt;String&gt; srcUniqueIds, String nodeName) {
        BiFunction&lt;TypeSystem, MapAccessor, Node&gt; mappingFunction = neo4jMappingContext.getRequiredMappingFunctionFor(Node.class);

        return neo4jClient.query(
                        &quot;&quot;&quot;
                                MATCH (src:Node)
                                WHERE src.uniqueId IN $uniqueIds
                                OPTIONAL MATCH (src:Node)-[*1..2]-(target:Node)
                                WHERE toUpper(target.name) = toUpper($name)
                                RETURN {src: src, target: target} AS nodePair
                                &quot;&quot;&quot;)
                .bind(srcUniqueIds).to(&quot;uniqueIds&quot;)
                .bind(nodeName).to(&quot;name&quot;)
                .fetchAs(NodePair.class)
                .mappedBy((typeSystem, record) -&gt; {
                        MapValue nodePair = (MapValue) record.get(&quot;nodePair&quot;);
                        var src = mappingFunction.apply(typeSystem, nodePair.get(&quot;src&quot;));
                        var target = mappingFunction.apply(typeSystem, nodePair.get(&quot;target&quot;));
                    return new NodePair(src, target);
                })
                .all();
    }
}
```
The function works fine when there&#39;s a match in the database.

However, for some business cases, the above query doesn&#39;t necessarily have a match, meaning it will return empty results based on different inputs. When there&#39;s no match, the following exception will be thrown
```
org.springframework.dao.InvalidDataAccessApiUsageException: NULL is not iterable; Error code &#39;N/A&#39;
	at org.springframework.data.neo4j.core.Neo4jPersistenceExceptionTranslator.translateImpl(Neo4jPersistenceExceptionTranslator.java:107)
	at org.springframework.data.neo4j.core.Neo4jPersistenceExceptionTranslator.translateExceptionIfPossible(Neo4jPersistenceExceptionTranslator.java:81)
	at org.springframework.data.neo4j.core.DefaultNeo4jClient.potentiallyConvertRuntimeException(DefaultNeo4jClient.java:230)
	at org.springframework.data.neo4j.core.DefaultNeo4jClient$DefaultRecordFetchSpec.all(DefaultNeo4jClient.java:488)
```

Is there a way to do a null check before the result being mapped to entity class? Or how could I avoid this kind of situation?

Thanks","1700080341","","","","https://stackoverflow.com/q/77490723","","","Question","Spring data neo4j client throws exception when there&#39;s no match in database","false","77490723","64",,,,,
"480",":Question","","2","I want to represent the modules of a Python package as nodes in a neo4j graph. I get inputs like the following and have to update the graph if the module hasn&#39;t already been included. Let&#39;s say my inputs look like this:

```
a.b.c.d
a.b.c.e
a
a.b.c
a.b
```

If `a.b.c` already exists, I don&#39;t want to recreate those nodes when I encounter `a.b.c.d`. I would only want to make a new node called `d` and connect it to `c`. Likewise if I get `a.b.c` and none of those nodes exist yet, then I want to create all of the nodes and connect them accordingly. My real inputs can have an arbitrary number of nodes per path, so I&#39;d like a Cypher query that can handle arbitrary path lengths.

I&#39;m new to Cypher. Here was my first attempt.

```cypher
MERGE p=(module:Module {name: $module_name})
WITH p, module
MATCH (package:Module)-[:contains*]-&gt;(module)
WHERE [x in nodes(p) | x.name] = $module_path
```

However, Cypher gives me the following error:

&gt; Query cannot conclude with MATCH

I also tried this:
```
MERGE p=(:Module)-[:contains*]-&gt;(:Module)
WHERE [x in nodes(p) | x.name] = $module_path
```

But then Cypher complains about the presence of `WHERE`.

Note that I&#39;m using the neo4j Python library to run this query, and I pass in parameters like this: `{&quot;module_path&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;module_name&quot;:&quot;c&quot;}`. I&#39;m happy to parameterize my query differently if there is a better way, but I don&#39;t think that is the source of my errors.

I&#39;m using neo4j `5.12`, community edition.","1700004397","","","","https://stackoverflow.com/q/77484411","","","Question","Create all nonexistent nodes and edges if path doesn&#39;t exist","false","77484411","53",,,,,
"481",":User","","","","","user554481","","","","","","User","","false","554481","",,,,,
"482",":Question","77482258","1","I&#39;m trying to get around IF queries in NEO4J.

Something like (if I could use  IF):

    MATCH (n:person)&lt;-[r:aetei]-(m:person)    
    IF m.ai &gt;= 2
    RETURN n, m, r

with `aetei` being a relationship between persons, and `ai` an attribute (obviously).

I tried some queries with foreach, but without results as I don&#39;t understand what to put after the | and how to get into the return. 
I&#39;ve seen some examples with queries in the RETURN ... is that possible ?
greetings

I tried several solutions like FOREACH or CASE, but nothing worked. I guess I&#39;m too fresh on NEO4J to really get what &#39;im doing. 
Should i install apoc ?","1699976941","","","","https://stackoverflow.com/q/77482002","","","Question","testing value in NEO4j","false","77482002","37",,,,,
"483",":User","","","","","Olivier Caignart","","","","","","User","","false","6380243","",,,,,
"484",":Question","77473606","2","So there is a requirement of counting the number of occurrences of non null and non empty values of all properties for a given node label.

For example, 
```
MATCH(p:Person) 
WHERE p.name IS NOT NULL and p.name &lt;&gt; &quot;&quot; 
RETURN COUNT(p.name);
```

This gives me a count for name properties for node label ```Person```
I have to get the count of such other 200 properties for this node label. I am able to get the count of the properties but I am not sure for conditional count like the above. Anything would be helpful as I have just started learning neo4j.

The query I am using for all properties count is 
```
MATCH(p:Person)
WITH p
UNWIND keys(p) as key
WITH key, COUNT(keys(p)) as cnt
RETURN DISTINCT key, cnt
ORDER BY key
```


What needs to be modified in the query? Or my query is wrong to start with. Thanks in advance.","1699870636","","","","https://stackoverflow.com/q/77473139","","","Question","Noe4j : how to get property names with count of non-null or non-empty value for a given node label","false","77473139","78",,,,,
"485",":User","","","","","Tony Riddle","","","","","","User","","false","13954862","",,,,,
"486",":Question","77476221","1","I have the following Cypher query:
    
    PROFILE
    MATCH (childDStat:JobableStatistic {jobableId: childD.id}) 
    WITH collect({`childDStat`:childDStat, `childD`:childD}) as childDStats 
    CALL apoc.cypher.mapParallel2(
      &quot; WITH _.childD as childD, _.childDStat as childDStat 
        WITH childD, childDStat 
        UNWIND childD.detailedCriterionIds as dCId 
        WITH childD, childDStat, dCId + coalesce(childDStat[&#39;replaceableCriterionIds.&#39; + dCId],[]) as cGroup 
        WITH childD, childDStat, cGroup 
        WHERE NOT AlL(x IN cGroup WHERE x IN $zeroCriterionIds ) 
        WITH childD, childDStat, collect(cGroup) as cGroups 
        WHERE size(cGroups) &gt;= size(childD.detailedCriterionIds) 
        UNWIND cGroups as cGroup 
        WITH childD, childDStat, cGroup 
        WHERE ANY(x IN cGroup WHERE x IN $detailedCriterionIds) 
        WITH childD, childDStat, collect(cGroup) as cGroups 
        WHERE size(cGroups) &gt; 1 
        RETURN childD, childDStat, cGroups &quot;,
      {`detailedCriterionIds`: [3, 5, 7, 8, 12, 13, 14, 15, 16, 18, 20, 21, 23, 26, 28, 29, 30, 31, 33, 35, 36, 40, 42, 44, 45, 46, 47, 51, 54],
       `zeroCriterionIds`: []},
      childDStats, 6, 10) 
    YIELD value
    WITH value.childD as childD, value.childDStat as childDStat, value.cGroups as cGroups WITH collect({`childDStat`:childDStat, `childD`:childD, `cGroups`:cGroups}) as childDStats 
    
    CALL apoc.cypher.mapParallel2(
      &quot; WITH _.childD as childD, _.childDStat as childDStat, _.cGroups as cGroups WITH childD, childDStat, size(cGroups) as cGroupsSize, cGroups 
        UNWIND cGroups as cGroup 
        WITH childD, childDStat, cGroupsSize, cGroup 
        UNWIND cGroup as cId WITH childD, childDStat, cGroupsSize, cGroup, cId, cGroup[0] as cG0
    
        WITH childD, childDStat, cGroupsSize, cGroup, cId, cG0, childDStat[&#39;criterionAvgVoteWeights.&#39; + cG0] as childDStatCriterionAvgVoteWeight,
          childDStat[&#39;criterionExperienceMonths.&#39; + cG0] as childDStatCriterionExperienceMonth, 
          $criterionAvgVoteWeights[toString(cId)] as criterionAvgVoteWeight, $criterionExperienceMonths[toString(cId)] as criterionExperienceMonth 
        WHERE 
          (childDStatCriterionAvgVoteWeight = 0 OR childDStatCriterionAvgVoteWeight &lt;= criterionAvgVoteWeight OR criterionAvgVoteWeight IS NULL) AND
          (childDStatCriterionExperienceMonth = 0 OR childDStatCriterionExperienceMonth &lt;= criterionExperienceMonth OR criterionExperienceMonth IS NULL)
    
        WITH childD, childDStat, cGroupsSize, cG0, collect(cId) as cIds WITH childD, childDStat, cGroupsSize, collect(DISTINCT cG0 + cIds) as cGroups
        WHERE size(cGroups) &gt;= cGroupsSize
        RETURN childD, childDStat, cGroups &quot;,
      {`detailedCriterionIds`: [3, 5, 7, 8, 12, 13, 14, 15, 16, 18, 20, 21, 23, 26, 28, 29, 30, 31, 33, 35, 36, 40, 42, 44, 45, 46, 47, 51, 54],
       `zeroCriterionIds`: [],
       `criterionAvgVoteWeights`: {`51`:5.0, `8`:0.0, `33`:5.0, `21`:0.0, `31`:0.0, `26`:4.0, `14`:5.0, `36`:3.0, `46`:3.0, `12`:3.0, `18`:5.0, `28`:5.0, `16`:2.0, `7`:5.0, `40`:1.0, `5`:5.0, `44`:4.0, `3`:1.0, `54`:4.0, `20`:4.0, `42`:4.0, `30`:3.0, `15`:4.0, `47`:1.0, `35`:1.0, `13`:3.0, `45`:3.0, `23`:4.0, `29`:1.0},
       `criterionExperienceMonths`: {`8`:109, `33`:8, `21`:184, `31`:14, `26`:100, `14`:157, `36`:140, `46`:123, `12`:85, `18`:96, `28`:116, `16`:15, `7`:63, `40`:56, `5`:166, `44`:101, `3`:129, `42`:84, `20`:102, `30`:173, `15`:97, `47`:54, `13`:91, `35`:137, `45`:119, `23`:162, `29`:97}
      },
      childDStats, 6, 10) 
    YIELD value
    RETURN value.childD.id
The following condition takes most of the query execution time:

    WHERE 
      (childDStatCriterionAvgVoteWeight = 0 OR childDStatCriterionAvgVoteWeight &lt;= criterionAvgVoteWeight OR criterionAvgVoteWeight IS NULL) AND
      (childDStatCriterionExperienceMonth = 0 OR childDStatCriterionExperienceMonth &lt;= criterionExperienceMonth OR criterionExperienceMonth IS NULL)

With this condition in place the query works `~1000ms`, without it `5ms`.

Is there something I may do with this condition in order to improve the query performance?

P.S

This is just a test query. The real query uses parameters for each single value.","1699835053","","","","https://stackoverflow.com/q/77471207","","","Question","Neo4j Cypher query performnce optimization with WHERE condition","false","77471207","50",,,,,
"487",":Question","","0","I&#39;m trying to run a database with the apoc and gds plugins. However, if I have the gds plugin installed attemtping to start the database responds in the following error: &quot;DBMS failed to restart: DBMS process terminated, see logs&quot;.
Unfortunately, I don&#39;t have much experience with reading errors in the logs. Can anyone tell me what&#39;s happening in this?

    [2023-11-11 21:46:50.496] [info]  Check if neo4j is available on { host: &#39;127.0.0.1&#39;, path: &#39;/&#39;, port: 7687 }
    [2023-11-11 21:46:50.497] [info]  Check if neo4j is available on { host: &#39;127.0.0.1&#39;, path: &#39;/&#39;, port: 7474 }
    [2023-11-11 21:46:50.498] [info]  Neo4j @ 7687 is down. connect ECONNREFUSED 127.0.0.1:7687
    [2023-11-11 21:46:50.499] [info]  Neo4j @ 7474 is down. connect ECONNREFUSED 127.0.0.1:7474
    [2023-11-11 21:46:51.509] [info]  Retrieved status for DBMS[database-d66031cf-5040-434c-ae01-65887d023f17]: false
    [2023-11-11 21:47:12.339] [info]  Online check request: https://dist.neo4j.org/neo4j-desktop/win/latest.yml
    [2023-11-11 21:47:12.445] [info]  Online check response: 200 version: 1.5.9



","1699757694","","","","https://stackoverflow.com/q/77467579","","","Question","Why is the Graph Data Science Library Plug In preventing me from starting a database","false","77467579","31",,,,,
"488",":User","","","","","Vincent Baldassari","","","","","","User","","false","10156351","",,,,,
"489",":Question","77448519","1","I can create a relationship in my graph, assign weights and write in disk as follows:

```
MATCH (a1:node1)-[rel1]-(p:other_node)-[rel2]-(a2:node2)
// create the weight
with a1.id as id1, a2.id as id2, count(p) as common_ocurrences
// create the rel
MERGE (a1)-[r:NEW_REL]-(a2)
// use the weights as a property of the created relationship
ON CREATE SET r.counter = common_occurrences
ON MATCH SET r.counter = common_occurrences

// create projection 
CALL gds.graph.project(
 &#39;new-graph&#39;,
 &#39;node1&#39;,
 {NEW_REL:{
 orientation:&#39;UNDIRECTED&#39;,
 properties:&#39;counter&#39;
 }
 }
)
yield *
```

but what i want is to do the same, without writing the relationship nor the associated weight.
for that i tried using **virtual relationships** like with this method:

```
MATCH (a1:node1)-[rel1]-(p:other_node)-[rel2]-(a2:node2)
with a1, a2, count(p) as common_occurrences
where a1.id&gt;a2.id
return 
a1, a2, 
apoc.create.vRelationship(a1, &#39;COAUTHORS_WITH_VIRTUAL2&#39;, {weight: common_occurrences}, a2) as REL_VIRTUAL2;
```

this part seems to work but now i&#39;m quite puzzled about how to use it. if right after the last clause i write something like 

```
CALL gds.graph.project(
 &#39;graph42&#39;,
 &#39;node1&#39;,
 {REL_VIRTUAL_2:{
 orientation:&#39;UNDIRECTED&#39;,
 properties:&#39;common_occurrences&#39;
 }
 }

)
yield *
```

it says that the relationship can not be found.
any help on this?","1699461025","","","","https://stackoverflow.com/q/77447334","","","Question","Neo4j: use in a projection a virtual relationship with weights","false","77447334","32",,,,,
"490",":User","","","","","albertovpd","","","","","","User","","false","12315558","",,,,,
"491",":Question","","3","I&#39;m writing Spring Data Neo4j webapp.
I have this domain object:
```java
@Node(&quot;Person&quot;)
public class Person {
    
    @Id
    @GeneratedValue
    private String id;
```

and a `(:Image) - [:DEPICTS] -&gt; (:Person)` relationship.

I need to count images depicting specific person.
This was my attempt:
```java
public interface ImageRepositoryNeo4j extends Neo4jRepository&lt;Image, String&gt; {
@Query(&quot;&quot;&quot;
        MATCH (i:Image) -[:DEPICTS] -&gt; (p:Person)
        WHERE p = $person
        RETURN count(i)
        &quot;&quot;&quot;)
    // DSNT WORK
    public Integer countByPeopleContains(@Param(&quot;person&quot;) Person person);
```
but it always returns 0.

## Other failed attempts
```java
@Query(&quot;&quot;&quot;
        MATCH (i:Image)-[:DEPICTS]-&gt;(p:Person)
        WHERE p IN $people
        RETURN count(i)
        &quot;&quot;&quot;)
    // DOESN&#39;T WORK, 0 RESULTS
    public Integer countByPeopleContains(@Param(&quot;people&quot;) Collection&lt;Person&gt; people);

@Query(&quot;&quot;&quot;
        MATCH (i:Image) -[:DEPICTS] -&gt; (p:Person)
        WHERE ID(p) = $person.__id__
        RETURN count(i)
        &quot;&quot;&quot;)
    // DSNT WORK
    public Integer countByPeopleContains(@Param(&quot;person&quot;) Person person);

@Query(&quot;&quot;&quot;
        MATCH (i:Image) -[:DEPICTS] -&gt; (p:Person)
        WHERE id(p)=$person
        RETURN count(i)
        &quot;&quot;&quot;)
    // DSNT WORK
    public Integer countByPeopleContains(@Param(&quot;person&quot;) String personId);

@Query(&quot;&quot;&quot;
        MATCH (i:Image) -[:DEPICTS] -&gt; (p:Person {id: $person.__id__})
        RETURN count(i)
        &quot;&quot;&quot;)
    // DSNT WORK, ALWAYS 0
    public Integer countByPeopleContains(@Param(&quot;person&quot;) Person person);
```
All of them return 0.

And this one works, but since `fullName` isn&#39;t unique property, it is not suitable by domain logic:
```java
@Query(&quot;&quot;&quot;
        MATCH (i:Image) -[:DEPICTS] -&gt; (p:Person {fullName: $person})
        RETURN count(i)
        &quot;&quot;&quot;)
    // TODO: personFullname is not unique, use smth else
    public Integer countByPeopleContains(@Param(&quot;person&quot;) String personFullName);
```

How do I use domain object in custom Cypher query in Spring Data Neo4j Repository?

## Clue
In [Spring Data Neo4j documentation][1] closest what I&#39;ve found to what I need is this:
```java
@Node
public final class Movie {

    @Id
    private final String title;
...
interface MovieRepository extends Neo4jRepository&lt;Movie, String&gt; {

    @Query(&quot;MATCH (m:Movie {title: $movie.__id__})\n&quot;
           + &quot;MATCH (m) &lt;- [r:DIRECTED|REVIEWED|ACTED_IN] - (p:Person)\n&quot;
           + &quot;return m, collect(r), collect(p)&quot;)
    Movie findByMovie(@Param(&quot;movie&quot;) Movie movie);
}
```
but for some reason it doesn&#39;t work in my case. Maybe that&#39;s because my id is `@GeneratedValue`.

## Another clue

In [Neo4j embedded docs](https://neo4j.com/docs/java-reference/current/java-embedded/query-parameters/) there is an example on how to pass an object to Cypher without Spring Data Neo4j:
```
Map&lt;String,Object&gt; params = new HashMap&lt;&gt;();
params.put( &quot;node&quot;, bobNode );

String query =
    &quot;MATCH (n:Person)&quot; + &quot;\n&quot; +
    &quot;WHERE n = $node&quot; + &quot;\n&quot; +
    &quot;RETURN n.name&quot;;

Result result = transaction.execute( query, params );
```
It works wif $node is `org.neo4j.graphdb.Node`:
```java
@Bean
CommandLineRunner countForGregWithoutSDN(GraphDatabaseService graphDatabaseService) {
	return args -&gt; {
		try (var tx = graphDatabaseService.beginTx()) {
			String cypherGetGreg = &quot;MATCH (n:Person {birthday: date(&#39;1993-03-03&#39;)}) RETURN n LIMIT 5;&quot;;
			Result result = tx.execute(cypherGetGreg);
			var greg1993 = (Node) result.next().get(&quot;n&quot;);
			if (!greg1993.getProperty(&quot;name&quot;).equals(&quot;Greg&quot;)) 
				throw new RuntimeException(&quot;Should be Greg1993 but actually &quot;+greg1993);
			result.close();

			Map&lt;String,Object&gt; params = new HashMap&lt;&gt;();
			params.put( &quot;node&quot;, greg1993 );

			String cypherCountForGreg = &quot;&quot;&quot;
				MATCH (i:Image) -[:DEPICTS] -&gt; (p:Person)
				WHERE p = $node
				RETURN count(i)
				&quot;&quot;&quot;;
			result = tx.execute( cypherCountForGreg, params );
			var count = result.next().values().iterator().next();
			System.out.println(&quot;Count for Greg1993 is &quot;+count);	// 1
			result.close();
		}
	};
}
```
 but it results in 0 if $node is SDN Entity.

  [1]: https://docs.spring.io/spring-data/neo4j/reference/appendix/custom-queries.html#custom-queries.parameters","1699455750","","","","https://stackoverflow.com/q/77446718","","","Question","Passing domain object as argument to custom Cypher query in Spring Data Neo4j","false","77446718","94",,,,,
"492",":Question","","2","I&#39;ve got this Query working:

```cypher
MATCH (doc:Captions)-[:HAS_CATEGORY]-(c:Categories {id: &#39;ne0MtinOO6DXryRvqMxS&#39;})
MATCH (doc:Captions)-[:HAS_PILLAR]-(p:Pillars {name: &#39;Feel Good&#39;})
WITH count(doc) as docCount
MATCH (doc:Captions)-[:HAS_CATEGORY]-(c:Categories {id: &#39;ne0MtinOO6DXryRvqMxS&#39;})
MATCH (doc:Captions)-[:HAS_PILLAR]-(p:Pillars {name: &#39;Feel Good&#39;})
WITH docCount, doc Limit 12
RETURN doc, docCount
```

This will return a `docCount` of 25 and the `doc`s, limited to 12.
But it feels like I&#39;m making the same call twice.

I&#39;m wanting to not make the same call twice","1699302877","","","","https://stackoverflow.com/q/77434080","","","Question","Neo4j Query set of node with 2 relationships and set value for each relationship node","false","77434080","48",,,,,
"493",":User","","","","","Skel","","","","","","User","","false","5520810","",,,,,
"494",":Question","","2","I created a graph in Neo4j for test purposes. Graph looks like screenshot below (simplified):
[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/Mzzug.png

What I want is the path from London to Edinburgh. For that I created following Cypher Query:


```
MATCH (start:CITY {Name: &quot;London&quot;})
MATCH (end:CITY {Name: &quot;Edinburgh&quot;})
MATCH path = (start)-[:HAS_STATION]-&gt;(:STATION)-[:BOARDS]-&gt;(:SECTION)-[:NEXT_SECTION*]-&gt;(:SECTION)-[:UNBOARDS]-&gt;(:STATION)&lt;-[:HAS_STATION]-(end)
 
```

This Query leaves me with the whole path Via Section 1, 2 and 3. All I need for my result is the first and last section. If there is a transshipment in between (i.e. Glasgow), I also would need the last section before transshipment and the first after the transshipment.

In other words: I need every section that is directly connected to a station from the path. I tried out following extension:

```
with nodes(path) as nodes
unwind nodes as node
with node
where ()-[:BOARDS]-&gt;(node) or (node)-[:UNBOARDS]-&gt;()
```

But with that query extension I ended up with all Sections, since they all can either board or unboard at a specific station (even if that station is not part of the path).","1699265434","","","","https://stackoverflow.com/q/77430266","","","Question","Neo4j Cypher show first and last connected node","false","77430266","53",,,,,
"495",":User","","","","","thomaswiiswitch","","","","","","User","","false","21613020","",,,,,
"496",":Question","77503708","1","I&#39;m currently using `DatabaseManagementServiceBuilder` to store `neo4j` data on my local host. Is there anyway to import the data to `neo4j` desktop or any other tool for visualisation? for example by creating a `.csv` file or dumping the data.

This is how my directories look like.

first  
![first][1]

second  
![second][2]

third  
![third][3]

I tried to replace the `/data` directory in a `neo4j` desktop database with my own `/data` directory but it didn&#39;t work (`neo4j` desktop kept giving an error which was no surprise).


[enter image description here][4]


  [1]: https://i.stack.imgur.com/QLm9Z.jpg
  [2]: https://i.stack.imgur.com/3EW2r.jpg
  [3]: https://i.stack.imgur.com/uU9xt.jpg

this is my code for connecting
  [4]: https://i.stack.imgur.com/GkIKu.png","1699247159","","","","https://stackoverflow.com/q/77428848","","","Question","Embedded database to neo4j desktop","false","77428848","93",,,,,
"497",":User","","","","","AES","","","","","","User","","false","14708942","",,,,,
"498",":Question","","0","I&#39;m trying to do the following:
Create `Person` and `Dog` nodes which have the following relationships:
`Person` has 2 relationships: `TEAMMATE` with a list of `Persons` and &#39;OWNER_OF&#39; with a list of `dogs`

`Dog` has 1 relationship: `OWNED_BY` with a single person

So for example:
I have 2 people: Chris and Roger. Roger is a teammate of Chris
and 1 dog: Ghost which is owned by Chris

My endgame is to query the following:
get me all the teammates of a person who is the owner of a dog named Ghost (the result is Roger from the example)

I created the following code:

```
@Node
data class Dog(
        @Id @GeneratedValue
        val id: Long?,
        val name: String,
        @Relationship(type = &quot;OWNED_BY&quot;)
        var owner: Person? = null) {
    constructor(name: String) : this(null, name)

    override fun toString(): String {
        return &quot;$name&#39;s owner =&gt; ${owner?.name}&quot;
    }

    override fun hashCode(): Int {
        return id?.hashCode() ?: super.hashCode()
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Dog

        if (id != other.id) return false
        return name == other.name
    }
}

```

```
@Node
data class Person(
        @Id @GeneratedValue
        val id: Long?,
        val name: String,
        @Relationship(type = &quot;TEAMMATE&quot;)
        var teammates: MutableSet&lt;Person&gt; = mutableSetOf(),
        @Relationship(type = &quot;OWNER_OF&quot;)
        var dogs: MutableSet&lt;Dog&gt; = mutableSetOf()) {

    constructor(name: String) : this(null, name)

    fun addTeammates(person: Set&lt;Person&gt;) {
        teammates.addAll(person)
    }

    fun addDog(dogs: Set&lt;Dog&gt;) {
        this.dogs.addAll(dogs)
    }

    override fun toString(): String {
        val teammatesList = teammates.stream().map(Person::name).toList()
        val dogsList = dogs.stream().map(Dog::name).toList()
        return &quot;$name&#39;s teammates =&gt; $teammatesList, dogs =&gt; $dogsList&quot;
    }

    override fun hashCode(): Int {
        return id?.hashCode() ?: super.hashCode()
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Person

        if (id != other.id) return false
        return name == other.name
    }
}

```

```
@Repository
interface DogRepository : Neo4jRepository&lt;Dog, Long&gt;
```

```
@Repository
interface PersonRepository : Neo4jRepository&lt;Person, Long&gt;
```

I&#39;m creating the following demo:
```
    @PostMapping(&quot;/demo2&quot;)
    fun addDemo2() {
        // Delete existing data (optional)
        personRepository.deleteAll()
        dogRepository.deleteAll()

        val chris = Person(&quot;Chris&quot;)
        val roger = Person(&quot;Roger&quot;)
        val ghost = Dog(&quot;Ghost&quot;)

        // Establish the relationships manually
        ghost.owner = chris
        chris.dogs.add(ghost)
        chris.addTeammates(setOf(roger))

        // Save the entities
        personRepository.save(chris)
        dogRepository.save(ghost)
    }
}
```

when I run this, I&#39;m getting the following error:
```
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.orElseThrow(Optional.java:377) ~[na:na]
	at org.springframework.data.neo4j.core.TemplateSupport.retrieveOrSetRelatedId(TemplateSupport.java:412) ~[spring-data-neo4j-7.1.5.jar:7.1.5]
	at org.springframework.data.neo4j.core.Neo4jTemplate.lambda$processNestedRelations$28(Neo4jTemplate.java:839) ~[spring-data-neo4j-7.1.5.jar:7.1.5]
	at org.springframework.data.neo4j.core.mapping.AssociationHandlerSupport.lambda$doWithAssociations$0(AssociationHandlerSupport.java:51) ~[spring-data-neo4j-7.1.5.jar:7.1.5]
	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithAssociations(BasicPersistentEntity.java:317) ~[spring-data-commons-3.1.5.jar:3.1.5]
	at org.springframework.data.neo4j.core.mapping.AssociationHandlerSupport.doWithAssociations(AssociationHandlerSupport.java:49) ~[spring-data-neo4j-7.1.5.jar:7.1.5]
	at org.springframework.data.neo4j.core.Neo4jTemplate.processNestedRelations(Neo4jTemplate.java:731) ~[spring-data-neo4j-7.1.5.jar:7.1.5]
....
```

Any idea?","1699197826","","","","https://stackoverflow.com/q/77426516","","","Question","Creating a Neo4J node with multiple relationships and bi-directional relationships","false","77426516","47",,,,,
"499",":User","","","","","Lior Derei","","","","","","User","","false","4132541","",,,,,
"500",":Question","77429408","1","I set up kafka neo4j sink connector the following way:
 1. Created `/tmp/plugins`, downloaded `neo4j-kafka-connect-neo4j-5.0.3-kc-oss.zip` (for Apache Kafka) and unzip into plugins folder i.e.
 2. Modified `connect-standalone.properties`, added `plugin.path=/tmp/plugins`
 3. Created `connect-neo4j-sink.properties` in config with the following

    ```name=Neo4jSinkConnector
    topics=my-events
    connector.class=streams.kafka.connect.sink.Neo4jSinkConnector
    key.converter=org.apache.kafka.connect.json.JsonConverter
    key.converter.schemas.enable=false
    value.converter=org.apache.kafka.connect.json.JsonConverter
    errors.retry.timeout=-1
    errors.retry.delay.max.ms=1000
    errors.tolerance=all
    errors.log.enable=true
    errors.log.include.messages=true
    neo4j.server.uri=bolt://neo4j:7687
    neo4j.authentication.basic.username=neo4j
    neo4j.authentication.basic.password=neo4j
    neo4j.encryption.enabled=false
    neo4j.topic.cypher.my-topic=MERGE (p:Person{name: event.name, surname: event.surname}) MERGE (f:Family{name: event.surname}) MERGE (p)-[:BELONGS_TO]-&gt;(f)```


And when I start:

```/bin/connect-standalone.sh config/connect-standalone.properties config/connect-neo4j-sink.properties```

I get this error: 

```Caused by: org.apache.kafka.connect.errors.ConnectException: Failed to find any class that implements Connector and which name matches streams.kafka.connect.sink.Neo4jSinkConnector```

**Environment**

 - neo4j:5-community 
 - apache kafka 2.13-3.6.0","1699139716","","","","https://stackoverflow.com/q/77424154","","","Question","Apache Kafka Neo4j Connector issues","false","77424154","52",,,,,
"501",":User","","","","","DevEx","","","","","","User","","false","1102806","",,,,,
"502",":Question","77419012","2","I want to count the relationships for each type of a given start node. I have constructed two possible queries to achieve that, but I don&#39;t know which one is going to be more efficient when dealing with lots of relationships.

1. Cypher only query with `count()`
```sql
MATCH (n) WHERE id(n) = 0
CALL {
    WITH n
    MATCH (n)&lt;-[r]-()
    RETURN &#39;&lt;&#39;+TYPE(r) AS type, COUNT(r) AS count
UNION ALL 
    WITH n
    MATCH (n)-[r]-&gt;()
    RETURN TYPE(r)+&#39;&gt;&#39; AS type, COUNT(r) AS count
}
RETURN type, count
```

Result:
```
╒════════════╤═════╕
│type        │count│
╞════════════╪═════╡
│&quot;&lt;ACTED_IN&quot; │5    │
├────────────┼─────┤
│&quot;&lt;PRODUCED&quot; │1    │
├────────────┼─────┤
│&quot;&lt;DIRECTED&quot; │2    │
└────────────┴─────┘
```

2. Cypher + APOC `apoc.node.relationship.types()` and `type, apoc.node.degree.[in|out]()`
```sql
MATCH (n) WHERE id(n) = 0
WITH n, apoc.node.relationship.types(n) AS types
CALL {
    WITH n, types
    UNWIND types as type
    RETURN &#39;&lt;&#39;+type AS type, apoc.node.degree.in(n, type) as count
UNION ALL 
    WITH n, types
    UNWIND types as type
    RETURN type+&#39;&gt;&#39; AS type, apoc.node.degree.out(n, type) as count
}
RETURN type, count
```
Result:
```
╒════════════╤═════╕
│type        │count│
╞════════════╪═════╡
│&quot;&lt;ACTED_IN&quot; │5    │
├────────────┼─────┤
│&quot;&lt;DIRECTED&quot; │2    │
├────────────┼─────┤
│&quot;&lt;PRODUCED&quot; │1    │
├────────────┼─────┤
│&quot;ACTED_IN&gt;&quot; │0    │
├────────────┼─────┤
│&quot;DIRECTED&gt;&quot; │0    │
├────────────┼─────┤
│&quot;PRODUCED&gt;&quot; │0    │
└────────────┴─────┘
```

The second query returns rows for empty relationship types, but this can be neglected.

I can only profile the first cypher-only query, because custom procedures like APOC can&#39;t be profiled.  ","1699025458","","","","https://stackoverflow.com/q/77417923","","","Question","Neo4j count relationships of each type for given node","false","77417923","61",,,,,
"503",":User","","","","","zirkelc","","","","","","User","","false","1967693","",,,,,
"504",":Question","","0","Does anybody use Memgraph as a graph database with the Spring Data Neo4j API through the Neo4j java driver?
Would be interested in hearing your experiences. Thanks!

Memgraph advertises as a drop-in replacement for Neo4j. Quickly spinning up memgraph/memgraph-platform in Docker and trying to connect from Spring Data Neo4j fails with lots of Exceptions though.","1699020531","","","","https://stackoverflow.com/q/77417303","","","Question","Memgraph with Spring Data Neo4j","false","77417303","81",,,,,
"505",":User","","","","","user22852956","","","","","","User","","false","22852956","",,,,,
"506",":Question","","1","I am trying to run neo4j with podman  with persisted data on volumes. 

I do not know why but when I try to run the container with `--volume` option it dies. 
Am I doing something wrong? 


```
(venv) [app_runner@eu012vm2093 ~]$ podman ps -a
CONTAINER ID  IMAGE       COMMAND     CREATED     STATUS      PORTS       NAMES
(venv) [app_runner@eu012vm2093 ~]$ podman run -d --name neo4jVol -p 7474:7474 -p 7687:7687 --volume /app/podman_storage/volumes/neo4j:/data neo4j
a281c68231f0987140e0d8a5b74d1e960056bd1a65df7a2be1426e433de05b10
(venv) [app_runner@eu012vm2093 ~]$ podman ps -a
CONTAINER ID  IMAGE                           COMMAND     CREATED        STATUS                    PORTS                                           NAMES
a281c68231f0  docker.io/library/neo4j:latest  neo4j       3 seconds ago  Exited (1) 4 seconds ago  0.0.0.0:7474-&gt;7474/tcp, 0.0.0.0:7687-&gt;7687/tcp  neo4jVol
(venv) [app_runner@eu012vm2093 ~]$ podman run -d --name neo4j -p 7474:7474 -p 7687:7687  neo4j
8408fd2f49bcc478b303fa05170dc56a5c48da2e0f59fbdabe8ace7e415bdfb8
(venv) [app_runner@eu012vm2093 ~]$ podman ps -a
CONTAINER ID  IMAGE                           COMMAND     CREATED         STATUS                     PORTS                                           NAMES
a281c68231f0  docker.io/library/neo4j:latest  neo4j       17 seconds ago  Exited (1) 18 seconds ago  0.0.0.0:7474-&gt;7474/tcp, 0.0.0.0:7687-&gt;7687/tcp  neo4jVol
8408fd2f49bc  docker.io/library/neo4j:latest  neo4j       3 seconds ago   Up 3 seconds               0.0.0.0:7474-&gt;7474/tcp, 0.0.0.0:7687-&gt;7687/tcp  neo4j
(venv) [app_runner@eu012vm2093 ~]$
```


EDIT:

I have tried to do as suggested by jonathan but I still get the same error:

```
(venv) [app_runner@eu012vm2093 ~]$ cat run_neo4j.sh
podman run -dt --name=neo4jdb01     --env=NEO4J_ACCEPT_LICENSE_AGREEMENT=yes     --env=NEO4J_AUTH=neo4j/password     --userns=keep-id   --publish=7474:7474 --publish=7687:7687 \
    --volume=$HOME/data/data:/data \
    --volume=$HOME/data/conf:/conf \
    --volume=$HOME/data/logs:/logs \
    --volume=$HOME/data/plugins:/plugins \
    neo4j
(venv) [app_runner@eu012vm2093 ~]$ podman ps -a
CONTAINER ID  IMAGE       COMMAND     CREATED     STATUS      PORTS       NAMES
(venv) [app_runner@eu012vm2093 ~]$ sh run_neo4j.sh
dfe473547f6d7a16912d160e9654b5b0ed08945149fb4aacae7b4c1f2a6cd7fe
(venv) [app_runner@eu012vm2093 ~]$ podman ps -a
CONTAINER ID  IMAGE                           COMMAND     CREATED        STATUS                    PORTS                                           NAMES
dfe473547f6d  docker.io/library/neo4j:latest  neo4j       2 seconds ago  Exited (1) 3 seconds ago  0.0.0.0:7474-&gt;7474/tcp, 0.0.0.0:7687-&gt;7687/tcp  neo4jdb01
(venv) [app_runner@eu012vm2093 ~]$
```
","1698930949","","","","https://stackoverflow.com/q/77409903","","","Question","podman neo4j unable to mount volume to persist data","false","77409903","53",,,,,
"507",":User","","","","","Donbeo","","","","","","User","","false","2411173","",,,,,
"508",":Question","","2","I am trying to delete a few duplicate relationships that got created between the same nodes. For example, node A is connected to node B with relationship R two times. Hence I have to delete one relationship. To do that I have written a query like this: 
```
MATCH p = ()-[r:relationship]-&gt;()
WITH r.id AS id, collect(r) AS branches WHERE size(branches) &gt; 1
FOREACH (n IN tail(branches) | DELETE n)
```

My question is whether I should use `DETACH DELETE`, or is a simple `DELETE` ok? Or in this case will `DETACH DELETE` and `DELETE` both do the same work?

In addition, please suggest how I can optimize this query!! Since there are millions of records to be deleted.

I have tried using both the `DELETE` clause and the `DETACH DELETE` clause, seems both worked the same. Note: I am using Neo4j version 3.5.","1698924475","","","","https://stackoverflow.com/q/77409184","","","Question","Optimization of a cypher query which deletes duplicate relationships","false","77409184","85",,,,,
"509",":Question","77405263","1","I&#39;m working with a Neo4j database with a data model with GAP and SCENARIO nodes. Each GAP node has a &quot;next&quot; property that lists the keys of connected SCENARIO nodes. The SCENARIO nodes have a &quot;parents&quot; property indicating how many parent nodes they have. I want to filter SCENARIO nodes based on a list of selected GAP nodes and the number of parents. 

Here is how GAP nodes are supposed to SCENARIO nodes:   

- gap1 key:g1
- gap2 key:g2
- gap3 key:g3

----------

- scenario1 key:  s1 
- scenario2 key:  s2
- scenario3 key: s3

----------

- parents of scenario 1 are: gap1, gap2
- parents of scenario 2 are: gap1, gap2, gap3
- parents of scenario 3 are: gap2

Here is my GAP and SCENARIO nodes model:    

     (gap1:GAP {name:  &#39;g1&#39;,
	            key:   &#39;g1&#39;,
	            desc:  &#39;&#39;,
	            next:  &#39;s1,s2&#39;
	  }),
	//GAP2
	  (gap2:GAP {name:  &#39;g2&#39;,
                 key:   &#39;g2&#39;,
                 desc:  &#39;&#39;,
                 next:  &#39;s1,s2,s3&#39;
	  }),
	//GAP3
	  (gap3:GAP {name:  &#39;g3&#39;,
                 key:   &#39;g3&#39;,
                 desc:  &#39;g3&#39;,
                 next:  &#39;s2&#39;
	  }),

	//SCENARIO
	  (scenario1:SCENARIO {name:    &#39;s1&#39;,
                           key:     &#39;s1&#39;,
                           DESC:    &#39;&#39;,
                           parents: 2
                           }),
	  (scenario2:SCENARIO {name:    &#39;s2&#39;,
                           key:     &#39;s2&#39;,
                           DESC:    &#39;&#39;,
                           parents: 3
                           }),
	  (scenario3:SCENARIO {name:    &#39;s3&#39;,
                           key:     &#39;s3&#39;,
                           DESC:    &#39;&#39;,
                           parents: 1}),

If a gap is provided as input in the query and it is a parent of a scenario, but the number of parents of that scenario is more than 1 in the parent node, it should exclude the scenario from the result. If two gaps are provided, and both are parents of a single scenario, other scenario nodes are included. Still, the parent condition only meets for that single node; it should only return that single node. 

I have tried too many combinations but always fail somewhere.
This query somehow worked, but it failed for the following conditions: 

 1. When g1,g2 are provided, it should return s1 only. it returns all three scenario
 2. if g1 is provided, it should return empty, but it returns s1,s2
 3. if g2 is provided, it should return only s3 but it returns all s1,s2,s3    


I have been stuck on this for around three days but have been unable to figure out a solution. Please note that, per the scenario, a direct link from GAP to SCENARIO will not solve the problem.

    MATCH (gap:GAP)
	WHERE gap.name IN [&#39;g1&#39;, &#39;g2&#39;, &#39;g3&#39;]

	WITH COLLECT(DISTINCT gap) AS selectedGaps

	WHERE size(selectedGaps) &gt; 0  

	MATCH (scenario:SCENARIO)
	WHERE ANY(gap IN selectedGaps WHERE scenario.key IN split(gap.next, &#39;,&#39;))
	RETURN scenario.name AS ScenarioName;
","1698863109","","","","https://stackoverflow.com/q/77404810","","","Question","Cypher Query to Filter SCENARIO Nodes Based on GAP Nodes","false","77404810","44",,,,,
"510",":User","","","","","JAMSHAID","","","","","","User","","false","7497127","",,,,,
"511",":Question","77411430","1","I followed the quickstart-tutorial for the [Neo4J-Kafka-Connector](https://neo4j.com/docs/kafka/quickstart-connect/). The following source instance cypher

```
MATCH (ts:TestSource) WHERE ts.timestamp &gt; $lastCheck RETURN ts.name AS name, ts.surname AS surname, ts.timestamp AS timestamp
```

inserts `name, surname, timestamp` rows in a kafka topic, if the `ts.timestamp &gt; $lastCheck` condition is satisfied.

If I am removing the `ts.timestamp as timestamp` from the return-clause, then the `$lastCheck `parameter isn&#39;t updated anymore, so the where condition is always true and the whole graph is queried for every request. Is there a way to update the `$lastCheck` parameter without returning a timestamp? This would be great, especially for aggregations, if a grouping on the timestamp is not wanted.

**EDIT**

To illustrate the problem a bit better, I added the `$lastCheck` parameter to the return clause. So my first query
```
MATCH (ts:TestSource) WHERE ts.timestamp &gt; $lastCheck RETURN ts.name AS name, ts.surname AS surname, ts.timestamp AS timestamp, $lastCheck as lastCheck
```
writes the following messages into my topic:
[![Topic after first topic][1]][1]


Here, I inserted the example `TestSource` nodes **twice** (after a short delay), to show the updated `$lastCheck` parameter.

&gt; CREATE (:TestSource {name: &#39;john&#39;, surname: &#39;doe&#39;, timestamp: datetime().epochMillis});
CREATE (:TestSource {name: &#39;mary&#39;, surname: &#39;doe&#39;, timestamp: datetime().epochMillis});
CREATE (:TestSource {name: &#39;jack&#39;, surname: &#39;small&#39;, timestamp: datetime().epochMillis});

Now I remove the `ts.timestamp as timestamp` from the return clause.
```
MATCH (ts:TestSource) WHERE ts.timestamp &gt; $lastCheck RETURN ts.name AS name, ts.surname AS surname, $lastCheck as lastCheck
```
The nodes in the database were deleted, and I inserted them only **once**. The messages in the topic look like this:

[![Topic after second query][2]][2]


  [1]: https://i.stack.imgur.com/U58p0.png
  [2]: https://i.stack.imgur.com/DYhyw.png

The screenshot only shows the first seven, but these messages are printed infinitely. Sometimes the `$lastCheck` in the topic is also just returned by the second query as `-1`.","1698851225","","","","https://stackoverflow.com/q/77403628","","","Question","Kafka-Neo4J-Connector: $lastCheck not updating if no timestamp is returned","false","77403628","67",,,,,
"512",":User","","","","","Max ","","","","","","User","","false","11131384","",,,,,
"513",":Question","77403478","1","I am trying to run the following docker-compose file but it always ends up with an error:

    version: &#39;3.9&#39;

	services:
	  neo4j:
	    image: neo4j:5.8
	    container_name: cybersage-neo4j
	    hostname: neo4j
	    user: 501:20 
	    ports:
	      - &#39;0.0.0.0:9001:7474&#39;
	      - &#39;0.0.0.0:9002:7687&#39;
	    volumes:
	      - ./neo4j-config:/config
	      - ./neo4j-data:/data:rw
	      - ./neo4j-plugins:/plugins:rw
	    environment:
	      - NEO4J_server_memory_pagecache_size=1G
	      - NEO4J_AUTH=neo4j/admin12345678
	      - NEO4J_apoc_export_file_enabled=true
	      - NEO4J_apoc_import_file_enabled=true
	      - NEO4J_apoc_import_file_use__neo4j__config=true
	      - NEO4JLABS_PLUGINS=\[\&quot;apoc\&quot;\] \
	      - NEO4J_dbms_security_procedures_unrestricted=apoc.\\\*


My docker-compose version is: **docker-compose version 1.25.0, build 0a186604**. Here is how I am trying to run it: 
    
sudo docker-compose -f neo4j-uat.yaml up -d

    ERROR: Version in &quot;./neo4j-uat.yaml&quot; is unsupported. You might be seeing this error because you&#39;re using the wrong Compose file version. 
    Either specify a supported version (e.g &quot;2.2&quot; or &quot;3.3&quot;) and place your service definitions under the `services` key, or omit the `version` key 
    and place your service definitions at the root of the file to use version 1.
	For more on the Compose file format versions, see https://docs.docker.com/compose/compose-file/

This error appears if I remove the version from my docker-compose file:    
    
    ERROR: The Compose file &#39;./neo4j-uat.yaml&#39; is invalid because:
    Unsupported config option for services: &#39;neo4j&#39;
","1698849495","","","","https://stackoverflow.com/q/77403423","","","Question","Version in &quot;neo4j-uat.yaml&quot; is unsupported. you&#39;re using the wrong Compose file version","false","77403423","21",,,,,
"514",":Question","77415493","1","I have neo4j Community edition installed on Windows, currently version 4.2.4 and need to upgrade it. The neo4j documentation suggests 4.2 -&gt; 4.3 -&gt; 4.4 but the only version 4 available to download is now 4.4.26

The upgrade instructions are the same, can I just follow them but jump from 4.2 to 4.4?

https://neo4j.com/docs/upgrade-migration-guide/current/version-4/understanding-upgrades-migration/

","1698837667","","","","https://stackoverflow.com/q/77402233","","","Question","Can I upgrade Neo4j from version 4.2.4 straight to version 4.4.26?","false","77402233","67",,,,,
"515",":User","","","","","user9759943","","","","","","User","","false","9759943","",,,,,
"516",":Question","","1","I am using langchain and neo4j Libs to convert NL to cypher.
Everything is working, I even get the finish chain and it is clearly not empty
``` 
Full Context:
[{&#39;d&#39;: {&#39;name&#39;: &#39;Quinapril&#39;, &#39;ID&#39;: &#39;CHEMBL1592&#39;}}]

&gt; Finished chain.
```

But the final results is like this
```
I&#39;m sorry, but I don&#39;t have the information.
```
Any Ideas what is happening? And how can i get full context results instead of the final interpretation.
I am following this blog steps [blog-link][1]
```
llm = ChatOpenAI(temperature=0.0, openai_api_key=openai_api_key)

CYPHER_GENERATION_TEMPLATE = &quot;&quot;&quot;Task:Generate Cypher statement to query a graph database.
Instructions:
Use only the provided relationship types and properties in the schema.
{schema}

The question is:
{question}&quot;&quot;&quot;


CYPHER_GENERATION_PROMPT = PromptTemplate(
    input_variables=[&quot;schema&quot;, &quot;question&quot;], template=CYPHER_GENERATION_TEMPLATE
)

chain = GraphCypherQAChain.from_llm(
    llm,
    graph=graph,
    verbose=True,
    cypher_prompt=CYPHER_GENERATION_PROMPT
)

def convert_question_to_cypher(question):
    return (chain.run(question))

#convert_question_to_cypher(&quot;find name of drugs that target gene XYZ&quot;)
```

  [1]: https://neo4j.com/developer-blog/langchain-cypher-search-tips-tricks/","1698766944","","","","https://stackoverflow.com/q/77397307","","","Question","Langchain neo4j integration return no result","false","77397307","131",,,,,
"517",":Question","","1","For example In my case there should be path from sub2 to sub6 and sub2 to sub8, sub2 to tgw2 etc.. But I am not getting any of these paths. 

My data:

```
CREATE 
(s1:Subnet{name:&quot;sub1&quot;}),
(s2:Subnet{name:&quot;sub2&quot;}),
(s3:Subnet{name:&quot;sub3&quot;}),
(s4:Subnet{name:&quot;sub4&quot;}),
(n1:Network{name:&quot;net1&quot;}),
(s1)-[:SUB_OF]-&gt; (n1),
(s3)-[:SUB_OF]-&gt; (n1),
(s2)-[:SUB_OF]-&gt; (n1),
(s4)-[:SUB_OF]-&gt; (n1),
(s5:Subnet{name:&quot;sub5&quot;}),
(s6:Subnet{name:&quot;sub6&quot;}),
(s7:Subnet{name:&quot;sub7&quot;}),
(s8:Subnet{name:&quot;sub8&quot;}),
(n2:Network{name:&quot;net2&quot;}),
(t1:TGW{name:&quot;tgw1&quot;}),
(t2:TGW{name:&quot;tgw2&quot;}),
(s5)-[:SUB_OF]-&gt; (n2),
(s6)-[:SUB_OF]-&gt; (n2),
(s7)-[:SUB_OF]-&gt; (n2),
(s8)-[:SUB_OF]-&gt; (n2),
(s5)-[:CONNECT_TO]-&gt;(t1),
(s3)-[:CONNECT_TO]-&gt;(t1),
(s4)-[:CONNECT_TO]-&gt;(t2),
(s8)-[:CONNECT_TO]-&gt;(t2);
```
my Projection is:
```
MATCH (src:Subnet)-[r:SUB_OF | CONNECT_TO]-&gt;(trg:Network|TGW)
RETURN gds.graph.project(
  &#39;cypherGraph10&#39;,
  src,
  trg,
  {relationshipType: type(r)},
  {undirectedRelationshipTypes: [type(r)]
})
```
I am not getting all y\my answers after trying this:

```
CALL gds.allShortestPaths.stream(&#39;cypherGraph10&#39;) YIELD sourceNodeId, targetNodeId, distance
WHERE gds.util.isFinite(distance) AND sourceNodeId &lt;&gt; targetNodeId
WITH gds.util.asNode(sourceNodeId) AS source, gds.util.asNode(targetNodeId) AS target, distance
WHERE NONE(n IN [source, target] WHERE n:Network|TGW)
RETURN source.name AS source, target.name AS target, distance
ORDER BY distance DESC, source ASC, target ASC
```","1698763633","","","","https://stackoverflow.com/q/77396899","","","Question","Why is All Pairs Shortest Paths not finding some paths between subnets?","false","77396899","45",,,,,
"518",":User","","","","","Sur","","","","","","User","","false","22816114","",,,,,
"519",":Question","","1","I have a database that I created with the following codes. 


```
LOAD CSV WITH HEADERS FROM &#39;FilmData.csv&#39; AS line
MERGE (n:Movie{title:line.Film_Adi_TR,yabanci_isim:coalesce(line.Film_Adi_Yabanci,&quot;Yabancı İsim Yok&quot;),released:line.Vizyon_Tarihi,numberOfAudience:line.Seyirci_Sayisi,TotalRevenue:line.Toplam_Hasilat,IMDb:line.IMDb,Screening_Week:line.Gosterim_Hafta,CountryOfManufacture:line.Yapimci_Ulke}) 
WITH n, split(line.Yapimci,&quot;,&quot;) as manufacturers, split(line.Yonetmen,&quot;,&quot;) as directors,split(line.Film_Turu,&quot;,&quot;) as genres,split(line.Oyuncular,&quot;,&quot;) as players
UNWIND manufacturers as m
UNWIND directors as d
UNWIND genres as g
UNWIND players as p
MERGE (y:Yapimci{title: m}) 
MERGE (yntmn:Yonetmen{title: d})
MERGE (gnrs:Film_Turu{title: g})
MERGE (o:Oyuncular{title: p})
MERGE (n)-[:Yapımcı]-&gt;(y)
MERGE (n)-[:Y&#246;netmen]-&gt;(yntmn)
MERGE (n)-[:FilmT&#252;r&#252;]-&gt;(gnrs)
MERGE (n)-[:Oyuncusu]-&gt;(o)
```

I want to list movies directed by the same director, but I&#39;m getting an error. Can you help me?
```
match (n:Yonetmen)
where n.title=&quot;Stephen King&quot;
match n-[:WRITE]-&gt;Movie
return Movie 
```

Neo.ClientError.Statement.SyntaxError
Invalid input &#39;n&#39;: expected &quot;(&quot;, &quot;ALL&quot;, &quot;ANY&quot; or &quot;SHORTEST&quot; (line 3, column 7 (offset: 54))
&quot;match n-[:WRITE]-&gt;Movie&quot;
       ^


I&#39;m new to Neo4j and I couldn&#39;t solve the problem.","1698761820","","","","https://stackoverflow.com/q/77396698","","","Question","Neo4j Invalid input &#39;n&#39;: expected &quot;(&quot;, &quot;ALL&quot;, &quot;ANY&quot; or &quot;SHORTEST&quot;)","false","77396698","92",,,,,
"520",":User","","","","","gizem tangalay","","","","","","User","","false","21434477","",,,,,
"521",":Question","77398164","1","I am working with Snomed in Neo4j bloom. 
I used the steps from the tutorial https://medium.com/@john.newberry27/populating-a-snomed-ct-property-graph-with-synthetic-patient-data-a43a3a044649 to create the graph database. However, there is a step in the tutorial to change what property nodes use as caption in neo4j bloom that is represented in the following image:
[![enter image description here][1]][1]


However, following the same steps and going into the same location, I find only the option to exclude:[![enter image description here][2]][2]

I am using the neo4j 2.10.1 version. Anybody has any ideas about why this is the case?

  [1]: https://i.stack.imgur.com/9ZkXL.png
  [2]: https://i.stack.imgur.com/OBf5w.png","1698750271","","","","https://stackoverflow.com/q/77395340","","","Question","How to change caption of nodes from nodetype to fully specified name property?","false","77395340","27",,,,,
"522",":User","","","","","Jos&#233; Luis Neves","","","","","","User","","false","18738502","",,,,,
"523",":Question","","2","The following doesn&#39;t finish

    MATCH path = (start:A)-[*]-&gt;(end:A)
    WHERE start.fen = &#39;abc&#39;
    WITH distinct path as distinct_path
    WHERE length(distinct_path) &gt; 3
    return distinct_path
    LIMIT 10

But when removing the WHERE clause, it returns

    MATCH path = (start:A)-[*]-&gt;(end:A)
    WHERE start.fen = &#39;abc&#39;
    WITH distinct path as distinct_path
    return distinct_path
    LIMIT 10

What about the WHERE clause makes it not finish?","1698748502","","","","https://stackoverflow.com/q/77395141","","","Question","Why does this neo4j query not finish?","false","77395141","26",,,,,
"524",":User","","","","","user1099123","","","","","","User","","false","1099123","",,,,,
"525",":Question","","0","I&#39;m new to neo4j and cypher.

My main question is: How to create a copy of an existing graph and perform operations on it?

I have a huge graph that requires modifications. I do not want to mess up the original graph and would like to know how to create a copy of it to test my algorithms on the copy first, and then apply it to the real graph. Maybe there are other alternatives to &#39;copy&#39;.

I also have a few other supportive questions:
1. What is an in-memory graph and its usage? 

   If I have a graph populated with nodes `CREATE (:Node {name: &#39;Node 1&#39;})` will it be an in-memory graph?
2. What is the usage of `graph.project` from the Graph Data Science library? I assume it is used to create sub-graphs. But then can I use `project` to create a copy of a graph?

I was going through neo4j docs, but could not understand the functionality.","1698741126","","","","https://stackoverflow.com/q/77394339","","","Question","How to create a copy of an existing graph and perform operations on it?","false","77394339","30",,,,,
"526",":User","","","","","malcolm.O","","","","","","User","","false","22825304","",,,,,
"527",":Question","","1","I have a custom CSV with movies data with the following strucuture:

    id,title,media_type,original_language,actor
    1002185.0,A Million Miles Away,movie,en,Emma Fassler
    447332.0,A Quiet Place,movie,en,Noah Jupe

and i want to graph in neo4j the actors (names) that share one or more movies (title) between each other, the code where i load the data:

    LOAD CSV WITH HEADERS FROM &quot;file:///movies_neo_graph/part-00000-c5c5507e-5501-4adb-87fc-38be1d908076-c000.csv&quot; AS row
    CREATE (m:Movie)
    SET m = row,
    m.id = toInteger(row.id),
    m.title = toString(row.title),
    m.language = toString(row.original_language);
    
    LOAD CSV WITH HEADERS FROM &quot;file:///movies_neo_graph/part-00000-c5c5507e-5501-4adb-87fc-38be1d908076-c000.csv&quot; AS row
    CREATE (a:Actor)
    SET a = row,
    a.name = toString(row.actor),
    a.movie_id = toInteger(row.id);

Then I setup the relationship between nodes Movie and Actor:

    MATCH (a:Actor),(m:Movie)
    WHERE a.movie_id = m.id
    CREATE (a)-[:ACTED_IN]-&gt;(m);

This is my first time in Neo4J and i don&#39;t know how to perform the query, i tried with

    MATCH (a:Actor)-[:ACTED_IN]-&gt;(m:Movie) 
    RETURN a.name AS actor, COLLECT(DISTINCT m.title) AS movies_acted, COUNT(m.title) AS movies_cnt
    ORDER BY movies_cnt DESC
    LIMIT 50;

And the result is a table but not a graph:

![Neo4J query table][1]

  [1]: https://i.stack.imgur.com/Sa20k.png

Any ideas? really appreciate the help","1698682380","","","","https://stackoverflow.com/q/77390261","","","Question","How to graph relationships between movies and actors (that they performed in common) in Neo4J movies database?","false","77390261","51",,,,,
"528",":User","","","","","Tadeo","","","","","","User","","false","20324642","",,,,,
"529",":Question","77390382","1","When voting on a node, I would like to register the points related to the vote. However, I would also like to keep track, in separate properties, of the amount of negative and positive points.

Here&#39;s a sketch of what I&#39;m trying to achieve, even though it doesn&#39;t work:

```cypher
CREATE   (u:User)
        -[v:VOTES_ON{ points: $points }]
       -&gt;(i:Item)

CASE
  WHEN $points &gt; 0 SET i.points_up = COALESCE(i.points_up, 0) + $points
  ELSE SET i.points_down = COALESCE(i.points_down, 0) + $points

SET i.points = COALESCE(i.points, 0) + $points
       
RETURN u, v, i
```

(I&#39;m using Neo4j&#39;s JavaScript&#39;s driver, that&#39;s the reason for `$points`.)

Is there a way of doing this in Cypher?","1698676214","","","","https://stackoverflow.com/q/77389501","","","Question","How to Conditionally SET in Cypher depending on parameter?","false","77389501","38",,,,,
"530",":Question","","0","I have deployed Neo4j version 5.12.0 on Kubernetes using helm charts in an EC2 server. In neo4j desktop (V 1.5.9) I have created a remote database connection. How to enable all apoc related plugins in the YAML file?

When I run a particular Cypher query I&#39;m facing this error:

&gt; Something went wrong: Neo4jError: Unknown function
&gt; &#39;apoc.map.removeKey&#39; (line 9, column 59 (offset: 490)) [0] &quot;     
&gt; attributes: CASE WHEN ecuProps IS NULL THEN {} ELSE
&gt; apoc.map.removeKey(properties(ecuProps), &#39;name&#39;) END&quot;","1698648542","","","","https://stackoverflow.com/q/77386634","","","Question","How to enable all apoc related plugins in a remote Neo4j database connection?","false","77386634","31",,,,,
"531",":User","","","","","mona","","","","","","User","","false","22238471","",,,,,
"532",":Question","","1","I am now starting approaching Cypher and I have probably a trivial question; so i provide an example query to make you understand what i mean:

    match (p1:Person)-[:works_on]-&gt;(project1:Project), (p2:Person)-[:works_on]-&gt;(project2:Project), (p1)-[:interested_in]-&gt;(interest:Skill)&lt;-[:interested_in]-(p2)
    where id(p1)&gt;id(p2) 
    with p1,p2, interest, count(interest) as conto
    return p1.name, p2.name, count(interest) ,conto,  collect(interest.name) as interessi

results:

    ╒════════╤═════════╤═══════════════╤═════╤══════════════════════════╕
    │p1.name │p2.name  │count(interest)│conto│interessi                 │
    ╞════════╪═════════╪═══════════════╪═════╪══════════════════════════╡
    │&quot;Sarah&quot; │&quot;Charlie&quot;│1              │2    │[&quot;DBMS&quot;]                │
    ├────────┼─────────┼───────────────┼─────┼──────────────────────────┤
    │&quot;Sarah&quot; │&quot;Ben&quot;    │2              │2    │[&quot;DBMS&quot;, &quot;TRAVEL&quot;]        │
    ├────────┼─────────┼───────────────┼─────┼──────────────────────────┤
    │&quot;Ben&quot;   │&quot;Charlie&quot;│1              │1    │[&quot;DBMS&quot;]                │
    ├────────┼─────────┼───────────────┼─────┼──────────────────────────┤
    │&quot;Arnold&quot;│&quot;Sarah&quot;  │3              │2    │[&quot;TRAVEL&quot;, &quot;JAVA&quot;, &quot;DBMS&quot;]│
    ├────────┼─────────┼───────────────┼─────┼──────────────────────────┤
    │&quot;Arnold&quot;│&quot;Ben&quot;    │2              │1    │[&quot;TRAVEL&quot;, &quot;DBMS&quot;]        │
    ├────────┼─────────┼───────────────┼─────┼──────────────────────────┤
    │&quot;Arnold&quot;│&quot;Charlie&quot;│1              │1    │[&quot;DBMSs&quot;]                │

The thing I&#39;d like to understand is why the 2 columns `count(interest)` and `conto` differ. Why? what is the latter actually counting?","1698625736","","","","https://stackoverflow.com/q/77385680","","","Question","Cypher queries: misuse of the with clause","false","77385680","25",,,,,
"533",":User","","","","","Jenny","","","","","","User","","false","12743491","",,,,,
"534",":Question","","1","I have restarted one of the CORE nodes of the cluster and it is unable to join the cluster.
Seeing the following in logs:

&gt; 2023-10-29 13:12:46.904+0000 INFO
&gt; [o.n.c.d.SecureHazelcastCoreTopologyService] Discovering other core
&gt; members in initial members set: [10.195.83.231:5000] 2023-10-29
&gt; 13:12:47.071+0000 INFO [o.n.c.c.c.l.s.RecoveryProtocol] Skipping from
&gt; index -1 to 1. 2023-10-29 13:12:47.089+0000 INFO
&gt; [o.n.c.c.c.l.s.SegmentedRaftLog] log started with recovered state
&gt; State{prevIndex=0, prevTerm=0, appendIndex=26} 2023-10-29
&gt; 13:12:47.093+0000 INFO [o.n.c.c.c.m.RaftMembershipManager] Membership
&gt; state before recovery:
&gt; RaftMembershipState{committed=MembershipEntry{logIndex=26,
&gt; members=[MemberId{f4425d42}, MemberId{eee36e32}, MemberId{456f7b24}]},
&gt; appended=null, ordinal=10} 2023-10-29 13:12:47.093+0000 INFO
&gt; [o.n.c.c.c.m.RaftMembershipManager] Recovering from: 26 to: 26
&gt; 2023-10-29 13:12:47.096+0000 WARN [o.n.c.c.c.m.RaftMembershipManager]
&gt; Appending member set was ignored. Current state:
&gt; RaftMembershipState{committed=MembershipEntry{logIndex=26,
&gt; members=[MemberId{f4425d42}, MemberId{eee36e32}, MemberId{456f7b24}]},
&gt; appended=null, ordinal=10}, Appended set: MemberIdSet{
&gt; members=[MemberId{f4425d42}, MemberId{eee36e32}, MemberId{456f7b24}]},
&gt; Log index: 26
&gt; 
&gt; 2023-10-29 13:12:47.096+0000 INFO [o.n.c.c.c.m.RaftMembershipManager]
&gt; Membership state after recovery:
&gt; RaftMembershipState{committed=MembershipEntry{logIndex=26,
&gt; members=[MemberId{f4425d42}, MemberId{eee36e32}, MemberId{456f7b24}]},
&gt; appended=null, ordinal=10} 2023-10-29 13:12:47.096+0000 INFO
&gt; [o.n.c.c.c.m.RaftMembershipManager] Target membership: [] 2023-10-29
&gt; 13:12:47.233+0000 INFO [o.n.c.n.Server] raft-server: bound to
&gt; 10.195.83.231:7000 2023-10-29 13:12:48.301+0000 INFO [o.n.c.p.h.HandshakeServerInitializer] Installing handshake server
&gt; local /10.195.83.231:7000 remote /10.195.83.187:52944 2023-10-29
&gt; 13:12:48.525+0000 INFO [o.n.c.p.h.HandshakeServerInitializer]
&gt; Installing handshake server local /10.195.83.231:7000 remote
&gt; /10.195.83.187:52956 2023-10-29 13:12:48.560+0000 INFO
&gt; [o.n.c.p.h.HandshakeServerInitializer] Installing handshake server
&gt; local /10.195.83.231:7000 remote /10.195.83.219:44370 2023-10-29
&gt; 13:22:46.907+0000 WARN [o.n.c.d.SecureHazelcastCoreTopologyService]
&gt; The server has not been able to connect in a timely fashion to the
&gt; cluster. Please consult the logs for more details. Rebooting the
&gt; server may solve the problem.

","1698586906","","","","https://stackoverflow.com/q/77383547","","","Question","neo4j ongdb: Member is not getting added to cluster after restart","false","77383547","21",,,,,
"535",":User","","","","","Prathibha Nag","","","","","","User","","false","9543759","",,,,,
"536",":Question","","2","I have done a number of different queries but am trying to copy *all* the relationships between my two nodes `r` to `rn` (where there is a Rel_Office label) but for some reason only the final query here works. I&#39;m using Neo4j Community 5.13.0.

*Doesn&#39;t work*

	MATCH (c:Companies)-[r:Rel_Office]-(o:Companies) 
	MATCH (n:Companies) WHERE c.CompanyID = X AND n.CompanyID = Y
	MERGE (n)-[rn:Props]-(o) 
	SET rn = properties(r)

*Doesn&#39;t work*

	MATCH (c:Companies)-[r:Rel_Office]-(o:Companies) 
	MATCH (n:Companies) WHERE c.CompanyID = X AND n.CompanyID = Y
	MERGE (n)-[rn:Props]-(o) 
	SET rn = r

*Does work but limited to one label!*

	MATCH (c:Companies)-[r:Rel_Office]-(o:Companies) 
	MATCH (n:Companies) WHERE c.CompanyID = 477 AND n.CompanyID = 9045
	MERGE (n)-[rn:Rel_Office]-(o) 


I suspect its something obvious, but please can someone explain how this should be working to do a full copy of all the labels/properties?","1698428006","","","","https://stackoverflow.com/q/77376071","","","Question","Neo4j/cypher - copy relationship labels to another","false","77376071","38",,,,,
"537",":User","","","","","Antony","","","","","","User","","false","3897214","",,,,,
"538",":Question","","0","I am facing an issue with importing multiple values for a property of node from csv file.
For example we have below values in csv file,

| CarDriver   | Passengers |
| -----       | -------    |
| Ganesh      | Rajesh     |
| Ganesh      | Sunil      |
| Ganesh      | Mangesh    |
| Suresh      | Mukesh     |
| Suresh      | Nitesh     |


Can anyone please suggest some solution for this issue?

Thanks,
Santosh

I tried to modify my query as per below two solutions from stackoverflow but it did not work,

It gave me below error, &quot;Cannot merge the following node because of null property value for &#39;id&#39;: (:Person {id: null})&quot;.","1698410150","","","","https://stackoverflow.com/q/77374200","","","Question","How to import multiple values for a property from csv file in Neo4j","false","77374200","25",,,,,
"539",":User","","","","","Santosh Jamale","","","","","","User","","false","22695083","",,,,,
"540",":Question","77366917","1","I wanted to know what is the scope of unwind variable?
Like the unwind variable is accessible till where?
I have this question since there is no marking of END for the unwind.

|e.g|

If I have lengthy query, the below x not accessible where
UNWIND [1, 2, 3] AS x

Thanks.

I want to know where the unwind variable scope ends","1698320855","","","","https://stackoverflow.com/q/77366735","","","Question","What is the scope of unwind in neo4j","false","77366735","46",,,,,
"541",":User","","","","","Trichian","","","","","","User","","false","22807132","",,,,,
"542",":Question","","1","I am using Spring Data Neo4j, and trying to execute the following code:

        @Query(&quot;&quot;&quot;
             MATCH (orders:Order {id:1})
             CALL apoc.path.subgraphAll(orders, {})
             YIELD nodes, relationships
             RETURN  nodes, relationships
            &quot;&quot;&quot;)
    List&lt;Order&gt; getOrders(@Param(&quot;orderId&quot;) Long orderId);

However, it returns only one Order with null fields instead of two with all fields populated.

Before, I was using the following code:

          @Query(&quot;&quot;&quot;
             MATCH path = (orders:Order {id: $orderId})-[*]-(commons)
             RETURN path
            &quot;&quot;&quot;)
    List&lt;Order&gt; getOrders(@Param(&quot;orderId&quot;) Long orderId);

However, it becomes prolonged after adding 10-20 nodes... So I either need to improve this query or somehow make Spring work with APOC procedures.

I really appreciate it if you could helm me on this matter.

Thank you in advance!

","1698235120","","","","https://stackoverflow.com/q/77359271","","","Question","Running APOC subGraphAll() in Spring Data Neo4j","false","77359271","25",,,,,
"543",":User","","","","","Can Cinar","","","","","","User","","false","7316385","",,,,,
"544",":Question","77361712","1","I am using this in Apollo GraphQL server:

    const { Neo4jGraphQL } = require(&#39;@neo4j/graphql&#39;);

And I am getting this error:  `Error  ACCESS on database &#39;neo4j&#39; is not allowed for user myuser`

But I am not referring to the `neo4j` database.  I have specified a different DB to the driver: &quot;mydb_name&quot;

    const driver = neo4j.driver(uri, neo4j.auth.basic(user, password), {
            database: &#39;mydb_name&#39;, // Specify your database name here
        })

I set the the Home DB of that user to &quot;mydb_name&quot;.

Why is th error referring to the `neo4j` DB? How to solve this?

If using directly with driver session query that working... But the  same with schema then getting error ","1698234696","","","","https://stackoverflow.com/q/77359216","","","Question","Error ACCESS on database &#39;neo4j&#39; is not allowed for user on se of neo4j/graphql","false","77359216","53",,,,,
"545",":User","","","","","vetti ","","","","","","User","","false","18560912","",,,,,
"546",":Question","","0","I have performed a consistency check on a Neo4j dump file, which was generated from a Neo4j database (5.8.0 version). I ran the command: 

`sudo neo4j-admin database check --from-path=./ neo4j`

Checking the report, it got errors like this:

...
```
ERROR Index inconsistency: Index has a leaked page that will never be reclaimed, pageId=208.
Index will be excluded from further consistency checks. Index file: /data1/dumps2/4459558985020293571/neo4j/schema/index/range-1.0/75/index-75.

ERROR Index inconsistency: Index has a leaked page that will never be reclaimed, pageId=247.
Index will be excluded from further consistency checks. Index file: /data1/dumps2/4459558985020293571/neo4j/schema/index/range-1.0/75/index-75.
```
...

How can I solve the inconsistency errors?


I have searched for info, but almost none results I got in Google. I was expecting to solve the inconsistencies and then upload the dump into AuraDB remote database for Neo4j.","1698180217","","","","https://stackoverflow.com/q/77355291","","","Question","How to solve ERROR Index inconsistency: Index has a leaked page that will never be reclaimed, pageId=X? Neo4j","false","77355291","23",,,,,
"547",":User","","","","","David Betancourt M.","","","","","","User","","false","9817604","",,,,,
"548",":Question","","1","I am going slightly crazy trying to understand why I can&#39;t push data to my Neo4j database using CYPHER in Python.

I am running basic testing code just to see if I can push data. Here is my testing code:

```py
import logging
from neo4j import GraphDatabase

# Set up logging
logging.basicConfig(level=logging.DEBUG)  # Change the level to ERROR, WARNING, INFO, or DEBUG as needed
log = logging.getLogger(&quot;neo4j&quot;)

class Neo4jService:
    def __init__(self, uri, user, password):
        self._driver = GraphDatabase.driver(uri, auth=(user, password))
        
    def close(self):
        log.debug(&quot;Closing driver.&quot;)
        self._driver.close()
        
    def run_queries(self, queries):
        log.debug(&quot;Running queries.&quot;)
        with self._driver.session() as session:
            for query in queries:
                log.debug(f&quot;Executing query: {query}&quot;)
                session.run(query)

try:
    # Initialize the Neo4j service
    URI = &quot;neo4j+s://838f9df7.databases.neo4j.io&quot;
    AUTH = (&quot;neo4j&quot;, &quot;my_password&quot;)

    log.info(&quot;Initializing driver.&quot;)
    with GraphDatabase.driver(URI, auth=AUTH) as driver:
        log.info(&quot;Verifying connectivity.&quot;)
        driver.verify_connectivity()

    summary = driver.execute_query(
        &quot;MERGE (:Person {name: $name})&quot;,
        name=&quot;Alice&quot;,
        database_=&quot;neo4j&quot;,
    ).summary

    log.info(f&quot;Created {summary.counters.nodes_created} nodes in {summary.result_available_after} ms.&quot;)

except Exception as e:
    log.error(&quot;An error occurred:&quot;, exc_info=True)
```

Whatever I seem to do, I get an error like this:

```
neo4j.exceptions.ServiceUnavailable: Unable to retrieve routing information
```

I have tried manually telling the Neo4j to trust the certificate by saving the certificate as a file and including a trust setting in my code. But this didn&#39;t work. I have tried swithcing from neo4j+s to bolt or just neo4j. I have updated neo4j and python. I feel like I have been debugging for about two days. Whatever I do, nothing happens in my Neo4j database. Help appreciated!","1698165150","","","","https://stackoverflow.com/q/77353888","","","Question","Cannot connect to Neo4j in Python to push data","false","77353888","86",,,,,
"549",":User","","","","","Benjamin Hammond","","","","","","User","","false","18566978","",,,,,
"550",":Question","","2","I have a query that shows the results from my large graph as follows:

[![graph][1]][1]

Here is my query to show the graph

    MATCH p=(parent:FEATURE)-[*]-&gt;(gap:GAP) WHERE parent.name = &quot;Update Profile&quot; 
    and (gap.name contains &quot;CSRF&quot; )  RETURN p

The nodes R11_UP and R12_UP have an incoming edge of type FACT; this query is not displaying that. Here is what the graph looks like if I manually show these incoming edges:

[![enter image description here][2]][2]

I want to update my query to show these FACT nodes along with the other graph shown by this query. I am unable to design a query for it. I tried several queries, but none of them worked. I am always stuck with this graph at the end.

  [1]: https://i.stack.imgur.com/nrhJ0.png
  [2]: https://i.stack.imgur.com/r5ESA.png","1698085429","","","","https://stackoverflow.com/q/77347515","","","Question","Displaying hidden nodes in Neo4j","false","77347515","44",,,,,
"551",":Question","77349202","2","I have several types of node labels (Asset1, Asset2, etc), all of which can be connected to any of the others; each asset has different fields but all have in common an `id` field. I am saving this data in CSV files to be loaded in Neo4j: node data is saved in asset1.csv, asset2.csv, etc, while relationship data is saved in a connection.csv file with the following header: `asset_1_id`, `asset_1_type`, `asset_2_id`, `asset_2_type`.

Loading the nodes is easy:

```cypher
LOAD CSV WITH HEADERS FROM &#39;file:///assetN.csv&#39; AS row
CREATE (n:AssetN {
  id: row.id,
  // other fields for AssetN
})
```

Before loading the nodes, I define separate indexes for each asset type:

```cypher
CREATE INDEX assetN_id IF NOT EXISTS FOR (n:AssetN) ON (n.id);
```

Loading the relationships is a bit trickier, because my first solution never terminates:

```cypher
LOAD CSV WITH HEADERS FROM &#39;file:///connection.csv&#39; AS row
MATCH (asset1 { id: row.asset_1_id })
MATCH (asset2 { id: row.asset_2_id }) 
    
MERGE (asset1)-[:CONNECTED_TO]-(asset2)
```

It seems that if I don&#39;t specify the label type, Neo4j does not look for an index in case it exists. I understand sometimes it may not exist (e.g. let&#39;s say there is another asset type without that index defined), but I would expect it to try and then default to a full scan otherwise.

So my second solution is to try and use APOC to read the labels dynamically from the CSV file:

```cypher
LOAD CSV WITH HEADERS FROM &#39;file:///connection.csv&#39; AS row
CALL apoc.merge.node([row.asset_1_type], { mrid: row.asset_1_id }) YIELD node as asset1
CALL apoc.merge.node([row.asset_2_type], { mrid: row.asset_2_id }) YIELD node as asset2   
 
MERGE (asset1)-[:CONNECTED_TO]-(asset2)
```

But this never terminates either, as it still does not seem to use the indexes.

The only solution I found so far that actually works is defining an additional label for each asset type (called Asset), defining a single index on Asset and then loading the relationship data:

```cypher
LOAD CSV WITH HEADERS FROM &#39;file:///connection.csv&#39; AS row
MATCH (asset1:Asset { id: row.asset_1_id })
MATCH (asset2:Asset { id: row.asset_2_id }) 
    
MERGE (asset1)-[:CONNECTED_TO]-(asset2)
```

This is extremely quick because it actually uses the index, but I don&#39;t like having to add a label to each node just to optimise loading the data.

Are there other solutions I am not seeing?","1698077162","","","","https://stackoverflow.com/q/77346710","","","Question","Neo4j query not making use of indexes","false","77346710","41",,,,,
"552",":User","","","","","Prassi","","","","","","User","","false","2461139","",,,,,
"553",":Question","","0","I have Officer nodes belonging to the same community (property community_probably_same_officer that I created with Graph Data Science). I would like to merge those nodes with apoc.refactor.mergeNodes.
I cannot use the iterate apoc since it has a bug that I reported so this is a workaround.

I wrote this code:

```
match (n:Officer)
with collect(distinct n.community_probably_same_officer) as idcom
unwind idcom as unwidcom
MATCH (n:Officer) where n.community_probably_same_officer=unwidcom
WITH unwidcom, collect(n) AS nodicom
CALL apoc.refactor.mergeNodes(nodicom,{
properties:&quot;discard&quot;, mergeRels:true, preserveExistingSelfRels:false})
yield node
return count(*)
```

and I have this error

Failed to invoke procedure `apoc.refactor.mergeNodes`: Caused by: java.lang.NullPointerException: Cannot invoke &quot;java.lang.Throwable.getMessage()&quot; because the return value of &quot;org.neo4j.graphdb.NotFoundException.getCause()&quot; is null

When I used this code for other communities based on a different property it worked with no problems.

Thanks in advance.","1698004696","","","","https://stackoverflow.com/q/77341501","","","Question","Neo4J: Failed to invoke procedure `apoc.refactor.mergeNodes`","false","77341501","62",,,,,
"554",":User","","","","","SimG","","","","","","User","","false","22352646","",,,,,
"555",":Question","77341642","2","Suppose I had two nodes: A and B. Now suppose I had two relations that are similar:

```
A -r1-&gt; B
A -r2-&gt; B
```

How do I make a query that returns just a path from A -&gt; B? The following query returns two paths that are identical. Can we merge the results?

```
MATCH path = (start:Fen)-[r*]-&gt;(end:Fen)
WHERE start.Name = &#39;A&#39;
RETURN DISTINCT(path)
```

What I am trying to solve is to find the most popular paths between nodes. so given the graph:

```
A -r1-&gt; B
A -r2-&gt; B
A -r3-&gt; C
```
the query should return 
```
A -r-&gt; B
A -r-&gt; C
```
since A -&gt; B is the most popular it appears first
","1697999220","","","","https://stackoverflow.com/q/77341203","","","Question","How do I get the unique paths in a graph in memgraph/cypher?","false","77341203","79",,,,,
"556",":Question","77340950","1","I&#39;m new to Neo4j and I&#39;m working on poc where there are multiple services that can read and write to each other and modeled with &lt;CAN_READ(INCOMING):CAN_WRITE(OUTGOING)&gt; directed relationships as shown in the image below. I want to find all paths from A to F through compute services which can read from A and write to Service F and compute service should also able to write data to Service D. So the query should able to return paths highlighted in green and purple.

I have tried the below query which is giving Compute Services B,C and Storage Service A and Database Service F but Service D is not part of result path

What I&#39;m trying to achieve is, I&#39;m trying to find the services that can read from a service and write to multiple other services with the same relations

    Query : MATCH p= (m:Service WHERE m.name = &quot;A&quot;)-[r1:CAN_READ]-&gt;(n:Service)-[r2:CAN_WRITE]-&gt;(o:Service WHERE o.name = &quot;F&quot;),(n)-[r3:CAN_WRITE]-&gt;(t:Service WHERE t.name = &quot;D&quot;) RETURN p

    Result Output Paths: (A)&lt;-[:CAN_READ]-(B)-[:WRITE_TO]-&gt;(F), (A)&lt;-[:CAN_READ]-(C)-[:WRITE_TO]-&gt;(F)

How to get the node D as part of output path? Will i able to get the node D as part of output or it will be omitted as it not part of the primary MATCH path ? Do I need to use any other functions or features of neo4j to achieve the same
[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/8kvbu.png","1697978777","","","","https://stackoverflow.com/q/77339992","","","Question","How to find paths between different services in Neo4j","false","77339992","45",,,,,
"557",":User","","","","","basic","","","","","","User","","false","9165128","",,,,,
"558",":Question","","0","I&#39;m using testcontainer to test the neo4j-related functionalities in the application with Grails 3.3.2 and Spock.

The grails application config for Neo4j:

    environments {
       development {
        grails {
            neo4j {
                url=&quot;bolt://dev-host:7687&quot;
                username=&#39;xxx&#39;
                password=&#39;xxx&#39;
            }
        }
    }

The setup for Neo4j Spock integration test
```
@Testcontainers
class Test extends Specification {
    static Neo4jContainer&lt;?&gt; container = new Neo4jContainer&lt;&gt;(&quot;neo4j:3.5&quot;)
            .withoutAuthentication()

    void setupSpec() {
        container.start()
        System.setProperty(&quot;grails.neo4j.url&quot;, container.getBoltUrl())
    }
    
    void &quot;1. test something&quot;() {neo4jService.save(dummyData)}

}
```
I have to change the application property source during the container setup so that the neo4j driver can find the correct database. In Spring/SpringBoot, we can use ```@DynamicPropertySource```. However, in Grails, I have to set the property manually.

**Current Problem:**

Only when I don&#39;t have any neo4j configs in the application config, the test can find the right URL created by the testcontainer. If I use the config above, even though I set the system property and let it point to the testcontainer, the test is still going to use the ```bolt://dev-host:7687``` defined in the config file.


Any idea on this? Thanks a lot.","1697930101","","","","https://stackoverflow.com/q/77338120","","","Question","Using Neo4j Testcontainers With Grails and Spock, can&#39;t find correct neo4j datasource","false","77338120","34",,,,,
"559",":Question","","1","I am trying to import data from multiple csv files by matching regex pattern into neo4j database instance by neo4j admin import method, which is probably the fastest way to import data in neo4j. 

I am trying to use the below command to import the data in my neo4j database instance:
 

    neo4j-admin database import full --nodes import/data_header.csv,import/data_\d+\.csv --overwrite-destination=true

But I am getting error something like this:

    Invalid nodes file: import/data_header.csv,import/data_\d+\.csv (java.lang.IllegalStateException: Directory C:\Program Files\neo4j-community-5.12.0-windows\neo4j-community-5.12.0\import\data_\d+ of import/data_\d+\.csv doesn&#39;t exist)

I am trying to import the data from all files that start with data_ and have any number after it.
For example, a valid file would be `data_1.csv`.

I even tried with absolute path but that too did not yield any result.

Thanks for the help in advance.","1697880643","","","","https://stackoverflow.com/q/77335429","","","Question","bulk Neo4j admin import from csv using regex","false","77335429","44",,,,,
"560",":User","","","","","Mudit Shukla","","","","","","User","","false","22774573","",,,,,
"561",":Question","","0","I am following this tutorial right here:https://github.com/elementsinteractive/flask-graphql-neo4j

When I spin up the container everything seems to work fine and I am able to access localhost:7474, but I am not able to access localhost:8080. Also when I look at my docker container says this:
```none
2023-10-20 14:49:04 /bin/sh: /app/wait-for.sh: not found
2023-10-20 14:49:04 Waiting for :...
```","1697827807","","","","https://stackoverflow.com/q/77333185","","","Question","Flask container can&#39;t access localhost:8080, but can access localhost:7474","false","77333185","40",,,,,
"562",":User","","","","","pythonmd661","","","","","","User","","false","20401213","",,,,,
"563",":Question","","2","I ran a Cypher query with the clause:

&gt; ORDER BY xxx DESC

where `xxx` is a string, like `[&quot;Coyote&quot;,&quot; Eastern Coyote&quot;]`. I want it ordered with first alphabet ASC, like this: `[&quot; Eastern Coyote&quot;,&quot;Coyote&quot;]`.
but the outcome is still this: `[&quot;Coyote&quot;,&quot; Eastern Coyote&quot;]`.

FYI: i asked chatgpt,it said order in neo4j is depends on alphabet&#39;s unicode, but it still not make sense, cause &quot;E&quot; is Larger than &quot;C&quot;","1697807745","","","","https://stackoverflow.com/q/77331216","","","Question","How string item order in neo4j","false","77331216","43",,,,,
"564",":User","","","","","Frank.H","","","","","","User","","false","15858616","",,,,,
"565",":Question","77333022","2","I have this cypher query that I had written:

    MATCH (SubjectUserNode:User:Transaction {NodeID: &quot;2547:12109:000:381864&quot;})-[dimensionRelation:LegalEntity
        WHERE dimensionRelation.Status = &quot;1&quot;
    ]-&gt;(dimension:LegalEntity:Transaction)&lt;-[udimensionRelation:LegalEntity
        WHERE udimensionRelation.Status = &quot;1&quot;
    ]-(User:User:Transaction)-[RoleRelationship:Role
        WHERE RoleRelationship.Status = &quot;1&quot;
    ]-&gt;(Role:Role:Transaction {NodeID: &quot;2547:12122:000:70163&quot;})
    RETURN User.TransactionID as UserID

In this query, I&#39;m trying to get all those User nodes that are related to a given Role node(NodeID given) and are also related to the LegalEntity node which has a relation to the given User node(NodeID given).

Example:

[![Node image][1]][1]

The query profile is:

[![Query Profile][2]][2]

The query is taking between 4-5 seconds to return the data and the number of nodes being returned is about 150.

Is there anyway to improve this query like by using any apoc procedure? I can&#39;t think of any other way as according to me this is a simple query in itself. Also, indices are already created on the nodeID of each node type.


  [1]: https://i.stack.imgur.com/jnxtf.png
  [2]: https://i.stack.imgur.com/XUgH7.png","1697778950","","","","https://stackoverflow.com/q/77328455","","","Question","How to Optimize this Neo4j Query","false","77328455","60",,,,,
"566",":User","","","","","Garv","","","","","","User","","false","22523452","",,,,,
"567",":Question","77311131","1","Is it possible to return `count()` from Cypher pattern comprehension ?

The following query doesn&#39;t work:

    [ (:Vacancy)&lt;-[rpp:POTENTIAL_PROFILE]-(childD) | count(rpp) ] AS potentialJobablesCount

with the following error:

    Aggregation column contains implicit grouping expressions. For example, in &#39;RETURN n.a, n.a + n.b + count(*)&#39; the aggregation expression &#39;n.a + n.b + count(*)&#39; includes the implicit grouping key &#39;n.b&#39;. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): rpp
","1697564138","","","","https://stackoverflow.com/q/77311116","","","Question","Return count() from Cypher pattern comprehension","false","77311116","47",,,,,
"568",":Question","77310912","1","I want to design a database in neo4j where I want to make nodes and relationships between other nodes. To explain it neatly please consider following scenario:

From given csv file one column represents unique IDs and another column represents classes, where in some class column there is only one class whereas in many column there are many classes. 

i.e.

    ---------------------
    |  ID   |  Class    |
    ---------------------
    |  ID1  |  Class-A  |
    ---------------------
    |  ID2  |  Class-A  |
    |       |  Class-B  |
    |       |  Class-C  |
    ---------------------

From the above example data, the query must generate `(ID1)` node and `(Class-A)` node with HAS relationship. Same with `ID2`. `(ID2)--[HAS]--&gt;(Class-A)` , `(ID2)--[HAS]--&gt;(Class-B)` and so on. 




I was able to write following query.

```
load csv with headers from &#39;path&#39; as line
match(id:ID{id:line.ID}), (temp:TEMP{id:line.Class})
    with temp, split(temp.id, &quot; &quot;) as ids
    unwind range(0,size(ids)-1) as i
merge(id)-[n:HAS]-&gt;(class:CLASS{id:ids[i]})
delete temp
return n
```

I am able to create individual nodes from Class column, but it creates relationships with empty nodes and not with associated IDs.

Any lead would be great help. 

I am new to database design.
Thanks","1697552779","","","","https://stackoverflow.com/q/77309885","","","Question","How to make nodes and form n to m relationship in neo4j when given &#39;m&#39; data is constructed in one csv column?","false","77309885","33",,,,,
"569",":User","","","","","Duda Validator","","","","","","User","","false","9240633","",,,,,
"570",":Question","","3","I am using neovis.js version 2.1.0 with neo4j version 5.12.0. When I tried accessing according to the examples, the neo4j server returned the following error:

```
Neo4jError: The property existence syntax `... exists(variable.property)` is no longer supported. Please use `variable.property IS NOT NULL` instead. (line 1, column 17 (offset: 16))
&quot;MATCH (n) WHERE exists(n.pagerank)&quot;

```

Is there a known incompatibility between these versions?

My vue3.js code is as follows:

```
&lt;template&gt;
  &lt;h3&gt;graph demo&lt;/h3&gt;
  &lt;div id=&quot;graph&quot;&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import NeoVis from &quot;neovis.js&quot;;
import { onMounted } from &quot;vue&quot;;

const config = ref({
  containerId: &quot;graph&quot;,
  neo4j: {
    serverUrl: &quot;bolt://localhost:7687&quot;,
    serverUser: &quot;neo4j&quot;,
    serverPassword: &quot;neo4j_password&quot;,
  },
  labels: {},
  relationships: {},
  initialCypher: &quot;MATCH (n) return n&quot;,
});

nMounted(() =&gt; {
  const vis = new NeoVis(config);
  vis.render();
});
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;
```","1697455742","","","","https://stackoverflow.com/q/77301601","","","Question","Is neovis.js version 2.1.0 incompatible with neo4j version 5.12.0?","false","77301601","120",,,,,
"571",":User","","","","","user2182284","","","","","","User","","false","2182284","",,,,,
"572",":Question","","0","In my quarkus application, I want to have some data inserted in my database for each user.

Database uses neo4j. As a consequence, I would like to have some code in my application which creates the various datas and send them in database.

Currently, I use the `RolesAugmentor`, as described in [Security Tips and Tricks][1]. Unfortunatly, as it is invoked for each request, we have multiple nodes generated for each new user.
How can I have data inserted only once for each user ?

**EDIT 1** More clearly, I have a RolesAugmentor class containing the following code

```java
@ApplicationScoped
public class RolesAugmentor implements SecurityIdentityAugmentor {

    @Override
    public Uni&lt;SecurityIdentity&gt; augment(SecurityIdentity identity, AuthenticationRequestContext context) {
        return Uni.createFrom().item(build(identity));
        // Do &#39;return context.runBlocking(build(identity));&#39;
        // if a blocking call is required to customize the identity
    }
    private Supplier&lt;SecurityIdentity&gt; build(SecurityIdentity identity) {
        if (identity.isAnonymous()) {
        	return () -&gt; identity;
        } else {
	        // create a new builder and copy principal, attributes, credentials and roles
	        // from the original identity
	        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder(identity);
	
	        JWTCallerPrincipal caller = (JWTCallerPrincipal) identity.getPrincipal();
	        String email = caller.getClaim(&quot;email&quot;);
	        if (!isUserAlreadyInDB(email)) {
		        synchronized(RolesAugmentor.class) {
			        if (!isUserAlreadyInDB(email)) {
			            String name = caller.getClaim(&quot;given_name&quot;);
			            String famillyName = caller.getClaim(&quot;family_name&quot;);
			            addUserToDB(email, name, famillyName);
			        }
		        }
	        }
	
	        // add custom role source here
	        builder.addRoles(extractUserRoles(email));
	
	        return builder::build;
        }
    }

```

And I&#39;m 99% sure it&#39;s not the good place to add user creation code. Am I right? What is the correct way?

  [1]: https://quarkus.io/guides/security-customization#security-identity-customization","1697449506","","","","https://stackoverflow.com/q/77300926","","","Question","What is the best way to create user config at first user login?","false","77300926","52",,,,,
"573",":User","","","","","Riduidel","","","","","","User","","false","15619","",,,,,
"574",":Question","","1","Using this query:
```cypher
OPTIONAL MATCH (n {id: &quot;does-not-exist&quot;})
CALL {
    RETURN &quot;test&quot; as inner
}
RETURN inner
```
I would expect the subquery not to be executed and the outer `RETURN` to return no results. Instead, the subquery is executed once and the return value is `&quot;test&quot;`. I suppose it being `OPTIONAL` causes the whole query to continue with one empty row.  
My actual query looks more like this:
```cypher
MATCH (n {id: &quot;exists&quot;})
CALL {
    WITH n
    OPTIONAL MATCH (n)--(m {id: &quot;mightExist&quot;})
    CALL {
        WITH m
        MATCH (m)--(o {id: &quot;does-not-exist&quot;})
        RETURN &quot;test&quot; as inner
    }
    RETURN inner
}
RETURN inner
```  
This causes the query to return nothing as the deepest subquery does not `MATCH` anything. The deepest subquery is still called once because the behavior of `OPTIONAL MATCH`. I can&#39;t change the `OPTIONAL MATCH` to be `MATCH` because then the whole query would not return anything when that relation does not exist, even though it should.


**Essentially, I&#39;m trying to return a nested relation of a node which may or may not exist as a relation to the root node. How can I do that?**


*Note: I&#39;m trying to stay away from APOC as much as I can to reduce vendor lock-in, but if I absolutely must use something like `apoc.when`, I could.*","1697449260","","","","https://stackoverflow.com/q/77300899","","","Question","How do I prevent a subquery from executing when an `OPTIONAL MATCH` does not return any rows","false","77300899","60",,,,,
"575",":User","","","","","Nils","","","","","","User","","false","10806063","",,,,,
"576",":Question","77298404","3","I have a graph projected from nodes and relationships &quot;(n1:Place)-[r:COST]-&gt;(n2:Place)&quot;.
To find the cheapest path between two nodes with names &#39;a&#39; and &#39;z&#39; I use [Dijkstra&#39;s shortest path algorithm][1]:

    MATCH (start:Place) where &#39;a&#39; = start.name
    MATCH (end:Place) where &#39;z&#39; = end.name
    CALL gds.shortestPath.dijkstra.stream(&#39;my-graph&#39;,{
        sourceNode: id(start),
        targetNode: id(end),
        relationshipWeightProperty: &#39;cost&#39;
    })
    YIELD nodeIds

It works perfectly, but I read that [id(node):int is deprecated][2] and in Neo4j 1.5.8 I should use the new [elementId(node):string][3] function instead. 


    MATCH (start:Place) where &#39;a&#39; = start.name
    MATCH (end:Place) where &#39;z&#39; = end.name
    CALL gds.shortestPath.dijkstra.stream(&#39;my-graph&#39;,{
        sourceNode: elementId(start),
        targetNode: elementId(end),
        relationshipWeightProperty: &#39;cost&#39;
    })
    YIELD nodeIds

However, since elementId() returns a string instead of an int, it causes an exception:

    Failed to invoke procedure `gds.shortestPath.dijkstra.stream`: Caused by: java.lang.IllegalArgumentException: Expected a node or a node id for `sourceNode`. Got String. 

 

Is there another option that supports pathfinding using elementId() instead of id()? 


  [1]: https://neo4j.com/docs/graph-data-science/current/algorithms/dijkstra-source-target/
  [2]: https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-id
  [3]: https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-elementid","1697215438","","","","https://stackoverflow.com/q/77289431","","","Question","How to use Neo4j&#39;s gds.shortestPath.dijkstra.stream for nodes with elementId(node) intead of id(node)?","false","77289431","49",,,,,
"577",":Question","","1","I&#39;m moving a database from Neo4j AURA to a Neo4j community edition instance hosted in AWS EC2.

**The problem:**
I export one of the AURA snapshots, it downloads a `neo4j.dump` file. When using the next command on the EC2 instance to **import / load** the file `neo4j-admin database load --from-path=/root neo4j --overwrite-destination=true` the process is okay but after that, I can&#39;t connect to the database using the browser or any driver anymore, the browser connects via `bolt` but it gives me an error that *neo4j database is no available use command* `:sysinfo` *for more information*

[![enter image description here][1]][1]

Also when running `neo4j-admin database check neo4j`

Get:
[![enter image description here][2]][2]
[![enter image description here][3]][3]

**Notes:**
- I have repeated the process by creating new EC2 Neo4j instances and the result is the same, I also tried in the Enterprise edition with no luck
- If anyone is wondering why I&#39;m moving from AURA, the reason is the latency/connection time, our server is in Heroku, and with aura, every query takes up to &gt;300ms even just doing a simple MATCH, in the EC2 instance takes &lt;10ms.


  [1]: https://i.stack.imgur.com/CTUYJ.png
  [2]: https://i.stack.imgur.com/Gvszp.png
  [3]: https://i.stack.imgur.com/lyOzr.png","1697164325","","","","https://stackoverflow.com/q/77284758","","","Question","Neo4j export from Aura to AWS EC2 community instance corrupts database","false","77284758","30",,,,,
"578",":User","","","","","Makarov","","","","","","User","","false","3234217","",,,,,
"579",":Question","","1","I&#39;m trying to start my neo4j server but I ran into this issue below; yes my gds license is good and  I made sure to &quot;chown&quot; the file so neo4j is the owner.

    neo4j.service - Neo4j Graph Database
         Loaded: loaded (/usr/lib/systemd/system/neo4j.service; disabled; preset: disabled)
         Active: failed (Result: exit-code) since Wed 2023-10-11 13:41:14 UTC; 6s ago
       Duration: 1.666s
        Process: 29539 ExecStart=/usr/share/neo4j/bin/neo4j console (code=exited, status=1/FAILURE)
       Main PID: 29539 (code=exited, status=1/FAILURE)
            CPU: 3.944s
    
    Oct 11 13:41:14 ip-172-31-2-140.us-gov-east-1.compute.internal neo4j[29539]: Validating Neo4j configuration: /etc/neo4j/neo4j.conf
    Oct 11 13:41:14 ip-172-31-2-140.us-gov-east-1.compute.internal neo4j[29539]: 1 issue found.
    Oct 11 13:41:14 ip-172-31-2-140.us-gov-east-1.compute.internal neo4j[29539]: Error: Unrecognized setting. No declared setting with name: gds.enterprise.license_file. Cleanup the conf&gt;
    Oct 11 13:41:14 ip-172-31-2-140.us-gov-east-1.compute.internal neo4j[29539]: Skipping Log4j validation due to previous issues.
    Oct 11 13:41:14 ip-172-31-2-140.us-gov-east-1.compute.internal neo4j[29539]: Configuration file validation failed.
    Oct 11 13:41:14 ip-172-31-2-140.us-gov-east-1.compute.internal neo4j[29539]: Configuration contains errors. This validation can be performed again using &#39;neo4j-admin server validate-&gt;
    Oct 11 13:41:14 ip-172-31-2-140.us-gov-east-1.compute.internal neo4j[29539]: Run with &#39;--verbose&#39; for a more detailed error message.
    Oct 11 13:41:14 ip-172-31-2-140.us-gov-east-1.compute.internal systemd[1]: neo4j.service: Main process exited, code=exited, status=1/FAILURE
    Oct 11 13:41:14 ip-172-31-2-140.us-gov-east-1.compute.internal systemd[1]: neo4j.service: Failed with result &#39;exit-code&#39;.
    Oct 11 13:41:14 ip-172-31-2-140.us-gov-east-1.compute.internal systemd[1]: neo4j.service: Consumed 3.944s CPU time.

I double checked my file in the neo4j.conf and it looks good to me:

![enter image description here](https://i.stack.imgur.com/ELppM.png)
","1697032599","","","","https://stackoverflow.com/q/77273741","","","Question","NEO4J issues with gds.enterprise.license.file","false","77273741","86",,,,,
"580",":User","","","","","William Hardison","","","","","","User","","false","17265089","",,,,,
"581",":Question","77275116","2","I have a database of architectural style periods, imported from a csv. Each `Style` has a `styId`, and an `infId` which shows the previous styles that have influenced it.

I would like to create relationships between the styles if they are mentioned as an influence, like so:

#### Anglo-saxon style influenced by Roman style

![Anglo-saxon style influenced by Roman style](https://i.stack.imgur.com/f6WR5.png)

#### styId and infId with matching values

![styId and infId with matching values](https://i.stack.imgur.com/eUgyT.png)

I know that this will be a case of matching the `styId` to the `infId` but I am not a data scientist and very new to NEO4j. I can do this by manually specifying relationships, but I&#39;m building this dataset myself and plan to add more entries later, so if there is a best practice to creating these relationships by going off of the `styId` and `infId` alone I&#39;d much prefer that option.

Thanks for any help, let me know if anything is unclear.","1697025443","","","","https://stackoverflow.com/q/77272847","","","Question","Creating relationships between nodes of the same label?","false","77272847","44",,,,,
"582",":User","","","","","anji","","","","","","User","","false","22671757","",,,,,
"583",":Question","77272821","1","I&#39;m trying to configure Liquibase to work with our neo4j Aura instance. The first time I run it, it   works fine, but every subsequent time I am getting this error:


```
[ERROR] Failed to execute goal org.liquibase:liquibase-maven-plugin:4.24.0:update (default) on project liquibase: 
[ERROR] Error setting up or running Liquibase:
[ERROR] java.lang.ClassCastException: class java.time.ZonedDateTime cannot be cast to class java.sql.Timestamp (java.time.ZonedDateTime is in module java.base of loader &#39;bootstrap&#39;; java.sql.Timestamp is in module java.sql of loader &#39;platform&#39;)

```

The version of liquibase and the neo4j extension is 4.24.0, the plugin configuration in maven is like this:

```
            &lt;plugin&gt;
                &lt;groupId&gt;org.liquibase&lt;/groupId&gt;
                &lt;artifactId&gt;liquibase-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;${liquibase.version}&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;changeLogFile&gt;liquibase/changelog.xml&lt;/changeLogFile&gt;
                    &lt;url&gt;jdbc:neo4j:neo4j+s://MYAURAURL:7687&lt;/url&gt;
                    &lt;driver&gt;org.neo4j.jdbc.boltrouting.BoltRoutingNeo4jDriver&lt;/driver&gt;
                    &lt;username&gt;neo4j&lt;/username&gt;
                    &lt;password&gt;MYAURAPASS&lt;/password&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;phase&gt;process-resources&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;update&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
```

I&#39;m guessing it&#39;s trying to cast these that show up in the database:
dateCreated: 2023-10-11T10:32:17.024000000Z
dateUpdated: 2023-10-11T10:33:24.253000000Z
But that isn&#39;t anything that I&#39;ve defined explicitly. 

I&#39;ve tried running with previous versions of the liquibase plugin. It either gives the same message or doesn&#39;t run at all.","1697020894","","","","https://stackoverflow.com/q/77272286","","","Question","Why am I getting ClassCastException when running Liquibase?","false","77272286","79",,,,,
"584",":User","","","","","Sabi Franjo","","","","","","User","","false","22331646","",,,,,
"585",":Question","77270610","2","Unfortunately due to some internal politics within neo4j, the py2neo project is now EOL and was deleted from pypi. See this [twitter thread](https://twitter.com/technige/status/1659452229659643906).

Is there anyone who might have forked the GitHub repository? ","1697003456","","","","https://stackoverflow.com/q/77270468","","","Question","Looking for a Py2neo fork","false","77270468","246",,,,,
"586",":User","","","","","Tinashe Muchabaiwa","","","","","","User","","false","7864196","",,,,,
"587",":Question","","0","I&#39;m building a website with Gatsby. It will be fully static.
I use a Neo4J base hosted (aka an AuraDB free instance) to store data needed for the website.

I&#39;m trying to get things working together but I end up with a 403 when trying to get some data from the DB.

Beginning of my gatsby-node.js

    const neo4j = require(&#39;neo4j-driver&#39;);
    const neo4jUri = &#39;neo4j+s://myurl.io&#39;;
    const neo4jUser = &#39;myneo4juser&#39;;
    const neo4jPassword = &#39;mypassword&#39;;
    const driver = neo4j.driver(neo4jUri, 
    neo4j.auth.basic(neo4jUser, neo4jPassword));
    const session = driver.session();
    session
      .run(&#39;MATCH (n:Node) RETURN n&#39;)
      .then((result) =&gt; {
        result.records.forEach((record) =&gt; {
          const nodeData = record.get(&#39;n&#39;).properties;
          console.log(&quot;DEALING WITH A NODE&quot;);
          const node = {
            ...nodeData,
            // Define required fields such as id, parent, children, etc.
            id: `${nodeData.id}`,
            parent: null,
            children: [],
            internal: {
              type: &#39;Neo4jNodeTEST&#39;, // Define your node type
              content: JSON.stringify(nodeData),
              contentDigest: createContentDigest(nodeData),
            },
          };
        
          // Create the Gatsby node
          createNode(node);
        });
      })
      .catch((error) =&gt; {
        console.error(&#39;Error executing Neo4j query&#39;, error);
      })
      .finally(() =&gt; {
        console.log(&#39;closing neo4j session&#39;);
        session.close();
      });
    (...)

And the plugin part of gatsby-config.js if it&#39;s helping

    plugins: [
        &quot;gatsby-plugin-sitemap&quot;,
        &quot;gatsby-plugin-sass&quot;,
        `gatsby-transformer-yaml`,
        {
          resolve: `gatsby-source-filesystem`,
          options: {
            path: `${__dirname}/content/`,
          },
        },
        {
          resolve: &quot;gatsby-source-graphql&quot;,
          options: {
            // Arbitrary name for the remote schema Query type
            typeName: &quot;allCompanyRepoYaml&quot;,
            // Field under which the remote schema will be accessible. You&#39;ll use this in your Gatsby query
            fieldName: &quot;edges&quot;,
            // Url to query from
            url: &quot;https://api.neo4j.io&quot;,
          },
        },
      ]


Any idea on when I should investigate to make things work?","1696953445","","","","https://stackoverflow.com/q/77267313","","","Question","How to connect to AuraDB from a Gatsby-based pages","false","77267313","30",,,,,
"588",":User","","","","","Aur&#233;lien B","","","","","","User","","false","424953","",,,,,
"589",":Question","77260862","1","Sorry if this is difficult to parse, have only been using NEO4j for a few days.
I&#39;m trying to build a database from multiple csv files. &#39;styles.csv&#39; includes notable architects and buildings. The architect and buildings csv files have additional info on their respective entries.

### Examples of data structures

#### Styles csv
![Styles csv snapshot][1]

#### Buildings csv
![Buildings csv snapshot][2]

#### Architects csv
![Architects csv snapshot][3]

However, when I import the csv files sequentially it creates duplicate nodes for each node with the same name value. For example, [here it is creating a node for the &#39;roman&#39; style.][4]

I am loading each csv sequentially and unwinding where there are cells with multiple values.


```
LOAD CSV WITH HEADERS FROM &#39;file:///restructured_data_styles.csv&#39; AS stylesheet
MERGE (s:Style {Style: stylesheet.Style, Dates: stylesheet.`Dates`, Location: stylesheet.Location})
WITH s, stylesheet
UNWIND split(stylesheet.`Examples`, &#39;;&#39;) AS stylebuildings
MERGE (buildings:Building{name:stylebuildings})
MERGE (s)-[rbs:BUILT_IN_STYLE]-&gt;(buildings)
```

```
LOAD CSV WITH HEADERS FROM &#39;file:///restructured_data_architects.csv&#39; AS architectsheet
MERGE (a:Architect {Architect: architectsheet.Name, Born: architectsheet.Born, Died: architectsheet.Died, Description: architectsheet.Description})
WITH a, architectsheet
UNWIND split(architectsheet.`Buildings`, &#39;;&#39;) AS architectbuildings
MERGE (buildings:Building{name:architectbuildings})
MERGE (a)-[rab:NOTABLE_PROJECTS]-&gt;(buildings)

```

What I want is to load each csv and have neo4j add the additional information provided by each csv file, but also merge the duplicate nodes created while maintaining the relationships already present.
As it stands, the relationships built within files are fine, but I&#39;m having trouble linking these nodes and relationships *between* the csvs. Does that make sense? Will clarify further if not! Thanks!

Nodes are being created, but they don&#39;t merge based on their name values. Have looked into APOC refactoring but I am very new to this (and also not a data scientist!) - a dumbed down explanation would be very helpful.


  [1]: https://i.stack.imgur.com/ea5oP.png
  [2]: https://i.stack.imgur.com/g71dM.png
  [3]: https://i.stack.imgur.com/a5Yms.png
  [4]: https://i.stack.imgur.com/J5RN1.png","1696869145","","","","https://stackoverflow.com/q/77260454","","","Question","How do I merge duplicate nodes as I load them in from multiple csv files?","false","77260454","39",,,,,
"590",":Question","","1","I keep getting
```
neo4j.exceptions.ServiceUnavailable: Couldn&#39;t connect to localhost:7687 (resolved to ()):
Connection to 127.0.0.1:7687 closed without handshake response
```
without a proper explanation why the service is considered to be unavailable. I am using the official neoj4:latest docker image as outlined below. The check for the port to be available is positive and the web environment works fine at port 7474 happily connecting to port 7687. Just the python driver complains.

Interestingly the CI test works of github fine - just the test in my Jenkins environment on a local ubuntu server reports the problem. 

**What might be the cause of this misbehavior?**


**My Environment**
Python Version: Python 3.10.12 (main, Jun 11 2023, 05:26:28) [GCC 11.4.0]
Driver Version: Name: neo4j Version: 5.10.0
Summary: Neo4j Bolt driver for Python
Server Version and Edition: neo4j:latest docker images
Operating System:Distributor ID:	Ubuntu
Description:	Ubuntu 22.04.3 LTS
Release:	22.04
Codename:	jammy

Issue to be addressed: https://github.com/WolfgangFahl/pyCEURmake/issues/84.
You&#39;ll  also find the source code of the snippets below in the above project.

**Script to start neo4j**
see https://github.com/WolfgangFahl/pyCEURmake/blob/main/scripts/neo4j
```bash
#!/bin/bash
# WF 2023-07-15

# Stop and remove any existing Neo4j container
docker stop neo4j-instance
docker rm neo4j-instance

# Run the Neo4j container
# https://neo4j.com/developer/docker-run-neo4j/
docker run -d --name neo4j-instance \
  --publish=7474:7474 --publish=7687:7687 \
  --env NEO4J_AUTH=neo4j/password \
  --volume=$HOME/neo4j/data:/data \
  neo4j:latest

# Function to display a progress bar
display_progress() {
  local progress=$1
  local max_progress=$2
  local bar_length=40
  local filled_length=$((progress * bar_length / max_progress))
  local empty_length=$((bar_length - filled_length))

  # Build the progress bar string
  local bar=&quot;[&quot;
  bar+=&quot;$(printf &quot;%${filled_length}s&quot; | tr &#39; &#39; &#39;#&#39;)&quot;
  bar+=&quot;$(printf &quot;%${empty_length}s&quot; | tr &#39; &#39; &#39;-&#39;)&quot;
  bar+=&quot;]&quot;

  # Print the progress bar
  printf &quot;\r%s %d%%&quot; &quot;$bar&quot; $((progress * 100 / max_progress))
}

# Wait for Neo4j to start
progress=0
max_progress=20
sleep_duration=0.5
while [ &quot;$(docker inspect -f &#39;{{.State.Running}}&#39; neo4j-instance 2&gt;/dev/null)&quot; != &quot;true&quot; ] &amp;&amp; [ $progress -lt $max_progress ]; do
  display_progress $progress $max_progress
  ((progress++))
  sleep $sleep_duration
done

# Clear the progress bar line
printf &quot;\r%${COLUMNS}s\r&quot;

if [ &quot;$(docker inspect -f &#39;{{.State.Running}}&#39; neo4j-instance 2&gt;/dev/null)&quot; == &quot;true&quot; ]; then
  echo &quot;Neo4j is running.&quot;
else
  echo &quot;Failed to start Neo4j.&quot;
fi

# Display the logs to check the status
docker logs neo4j-instance
```

**neo4j wrapper class**
```python
import argparse
import json
import os
import re
import requests
import socket
import sys

from typing import List, Optional
from dataclasses import dataclass, field
from neo4j import GraphDatabase
from neo4j.exceptions import ServiceUnavailable, AuthError, ConfigurationError


class Neo4j:
    &quot;&quot;&quot;
    Neo4j wrapper class
    &quot;&quot;&quot;
    def __init__(self,host:str=&quot;localhost&quot;,bolt_port:int=7687,auth=(&quot;neo4j&quot;, &quot;password&quot;),encrypted:bool=False):
        &quot;&quot;&quot;
        constructor
        &quot;&quot;&quot;
        self.driver = None
        self.error = None
        self.host=host
        self.bolt_port=bolt_port
        self.encrypted=encrypted
        try:
            uri=f&quot;bolt://{host}:{bolt_port}&quot;      
            if not Neo4j.is_port_available(host,bolt_port):
                raise ValueError(f&quot;port at {uri} not available&quot;)
            self.driver = GraphDatabase.driver(uri, auth=auth,encrypted=encrypted)
        except (ServiceUnavailable, AuthError, ConfigurationError) as e:
            self.error = e
         
    @classmethod   
    def is_port_available(cls,host, port:int)-&gt;bool:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)  # 1 Second Timeout
        try:
            sock.connect((host, port))
        except socket.error:
            return False
        return True

    def close(self):
        if self.driver is not None:
            self.driver.close()

@dataclass
class Volume:
    &quot;&quot;&quot;
    Represents a volume with its attributes.
    &quot;&quot;&quot;

    acronym: str
    title: str
    loctime: str
    editors: List[&#39;Editor&#39;] = field(default_factory=list)

    @classmethod
    def from_json(cls, json_data):
        &quot;&quot;&quot;
        Create a Volume instance from JSON data.

        Args:
            json_data (dict): The JSON data representing the volume.

        Returns:
            Volume: The Volume instance created from the JSON data.
        &quot;&quot;&quot;
        editor_names = json_data.get(&#39;editors&#39;)
        if editor_names:
            editor_names = editor_names.split(&quot;,&quot;)
        else:
            editor_names = []
        editors = [Editor(name=name.strip()) for name in editor_names]
        return cls(
            acronym=json_data.get(&#39;acronym&#39;),
            title=json_data.get(&#39;title&#39;),
            loctime=json_data.get(&#39;loctime&#39;),
            editors=editors
        )

    def create_node(self, tx) -&gt; int:
        &quot;&quot;&quot;
        Create a Volume node in Neo4j.
    
        Args:
            tx: The Neo4j transaction.
    
        Returns:
            int: The ID of the created node.
        &quot;&quot;&quot;
        query = &quot;&quot;&quot;
        CREATE (v:Volume {acronym: $acronym, title: $title, loctime: $loctime})
        RETURN id(v) as node_id
        &quot;&quot;&quot;
        parameters = {
            &quot;acronym&quot;: self.acronym,
            &quot;title&quot;: self.title,
            &quot;loctime&quot;: self.loctime
        }
        result = tx.run(query, parameters)
        record = result.single()
        if record is not None:
            return record[&quot;node_id&quot;]
        else:
            return None


    @staticmethod
    def load_json_file(source: str) -&gt; List[&#39;Volume&#39;]:
        &quot;&quot;&quot;
        Load volumes from the source JSON file.

        Args:
            source (str): Path to the source JSON file.

        Returns:
            List[Volume]: The list of loaded volumes.
        &quot;&quot;&quot;
        with open(source, &#39;r&#39;) as file:
            json_data = json.load(file)

        volumes = [Volume.from_json(volume_data) for volume_data in json_data]
        return volumes
    
    @classmethod
    def default_source(cls)-&gt;str:
        &quot;&quot;&quot;
        get the default source
        &quot;&quot;&quot;
        default_source = os.path.expanduser(&#39;~/.ceurws/volumes.json&#39;)
        return default_source
    
    @classmethod
    def parse_args(cls,argv:list=None):
        &quot;&quot;&quot;
        Parse command line arguments.
        
        Args:
            argv(list): command line arguments

        Returns:
            argparse.Namespace: The parsed command line arguments.
        &quot;&quot;&quot;
        
        default_source = cls.default_source()
        parser = argparse.ArgumentParser(description=&quot;Volume/Editor/Location Information&quot;)
        parser.add_argument(&#39;--source&#39;, default=default_source, help=&quot;Source JSON file path&quot;)
        # Add progress option
        parser.add_argument(&#39;--progress&#39;, action=&#39;store_true&#39;, help=&quot;Display progress information&quot;)
  
        return parser.parse_args(argv)

    @staticmethod
    def main(argv=None):
        if argv is None:
            argv=sys.argv[1:]
        args = Volume.parse_args(argv)
        volumes = Volume.load_json_file(args.source)

        # Connect to Neo4j
        driver = GraphDatabase.driver(&quot;bolt://localhost:7687&quot;, auth=(&quot;neo4j&quot;, &quot;password&quot;))
        with driver.session() as session:
            for volume in volumes:
                volume_node_id = volume.create_node(session)
                for editor in volume.editors:
                    editor.search_by_name()
                    editor.create_node(session, volume_node_id)


@dataclass
class Editor:
    &quot;&quot;&quot;
    Represents an editor with their name and ORCID.
    &quot;&quot;&quot;

    name: str
    orcid: str = None
    likelihood: float = None

    @classmethod
    def from_json(cls, json_data):
        &quot;&quot;&quot;
        Create an Editor instance from JSON data.

        Args:
            json_data (dict): The JSON data representing the editor.

        Returns:
            Editor: The Editor instance created from the JSON data.
        &quot;&quot;&quot;
        return cls(
            name=json_data.get(&#39;name&#39;),
            orcid=json_data.get(&#39;orcid&#39;)
        )

    def search_by_name(self):
        &quot;&quot;&quot;
        Search the editor by name using the ORCID API and calculate the likelihood.
        &quot;&quot;&quot;
        if self.name:
            url = f&quot;https://pub.orcid.org/v3.0/search/?q={self.name}&quot;
            headers = {
                &quot;Accept&quot;: &quot;application/json&quot;
            }
            response = requests.get(url, headers=headers)
            if response.status_code == 200:
                data = response.json()
                num_results = data.get(&quot;num-found&quot;, 0)
                self.likelihood = num_results / 10  # Arbitrary calculation, adjust as needed

    def create_node(self, tx, volume_node_id: int) -&gt; int:
        &quot;&quot;&quot;
        Create an Editor node in Neo4j and establish a relationship with a Volume node.
    
        Args:
            tx: The Neo4j transaction.
            volume_node_id (int): The ID of the volume node.
    
        Returns:
            int: The ID of the created Editor node.
        &quot;&quot;&quot;
        query = &quot;&quot;&quot;
        MATCH (v:Volume)
        WHERE id(v) = $volume_node_id
        CREATE (v)-[:HAS_EDITOR]-&gt;(e:Editor {name: $name, orcid: $orcid, likelihood: $likelihood})
        RETURN id(e) as node_id
        &quot;&quot;&quot;
        parameters = {
            &quot;volume_node_id&quot;: volume_node_id,
            &quot;name&quot;: self.name,
            &quot;orcid&quot;: self.orcid,
            &quot;likelihood&quot;: self.likelihood
        }
        result = tx.run(query, parameters)
        record = result.single()
        if record is not None:
            return record[&quot;node_id&quot;]
        else:
            return None



@dataclass
class Location:
    city: str
    country: str
    date: str

    @staticmethod
    def parse(location_str: str) -&gt; Optional[&#39;Location&#39;]:
        &quot;&quot;&quot;
        Parse a location string of the format &quot;City, Country, Date&quot;

        Args:
            location_str: The location string to parse.

        Returns:
            A Location object or None if the string could not be parsed.
        &quot;&quot;&quot;
        match = re.match(r&#39;^(.*), (.*), (.*)$&#39;, location_str)
        if match:
            city, country, date = match.groups()
            return Location(city, country, date)
        else:
            return None

if __name__ == &quot;__main__&quot;:
    Volume.main()
```

**unittest**
```python
import json
from ceurws.volume_neo4j import Neo4j,Volume, Editor
from ceurws.location import LocationLookup
from tests.basetest import Basetest

class TestVolumeEditorLocation(Basetest):
    &quot;&quot;&quot;
    Unit tests for Volume, Editor, and Location classes.
    &quot;&quot;&quot;
    
    def setUp(self, debug=False, profile=True):
        Basetest.setUp(self, debug=debug, profile=profile)
        self.neo4j=Neo4j()
        
    def tearDown(self):
        Basetest.tearDown(self)
        self.neo4j.close()
        
    def test_neo4j_available(self):
        &quot;&quot;&quot;
        test the port availability
        &quot;&quot;&quot;
        for service,port in [(&quot;bolt&quot;,self.neo4j.bolt_port),(&quot;http&quot;,7474)]:
            available=Neo4j.is_port_available(self.neo4j.host, port)
            self.assertTrue(available,f&quot;{service} service at {port}&quot;)
            
    def create_test_volume(self, year: int=2023) -&gt; int:
        &quot;&quot;&quot;
        Creates a test Volume node for the given year.
    
        Args:
            year (int): The year for which to create the Volume.
    
        Returns:
            int: The ID of the created Volume node.
        &quot;&quot;&quot;
        with self.neo4j.driver.session() as session:
            with session.begin_transaction() as tx:
                acronym = f&quot;CILC {year}&quot;
                title = f&quot;Proceedings of the {year-1985}th Italian Conference on Computational Logic&quot;
                loctime = f&quot;Some City, Italy, June 21-23, {year}&quot;
                volume = Volume(acronym=acronym, title=title, loctime=loctime)
                volume_id = volume.create_node(tx)
            return volume_id

    def test_volume_create_node(self):
        &quot;&quot;&quot;
        Test the create_node method of the Volume class.
        &quot;&quot;&quot;
        volume_id=self.create_test_volume()
        self.assertIsNotNone(volume_id)
        
    def test_editor_create_editor_node(self):
        &quot;&quot;&quot;
        Test the create_editor_node method of the Editor class.
        &quot;&quot;&quot;
        volume_id_2023 = self.create_test_volume(2023)
        volume_id_2024 = self.create_test_volume(2024)
    
        with self.neo4j.driver.session() as session:
            with session.begin_transaction() as tx:
                # Test creating one editor for multiple volumes
                editor = Editor(name=&quot;John Doe&quot;, likelihood=0.8)
                editor_id_2023 = editor.create_node(tx, volume_id_2023)
                editor_id_2024 = editor.create_node(tx, volume_id_2024)
        
                self.assertIsNotNone(editor_id_2023)
                self.assertIsNotNone(editor_id_2024)
            
    def test_location_lookup(self):
        &quot;&quot;&quot;
        Test the lookup method of the LocationLookup class.
        &quot;&quot;&quot;
        location_lookup = LocationLookup()
        location = location_lookup.lookup(&quot;Amsterdam, Netherlands&quot;)
        self.assertIsNotNone(location)
        self.assertEqual(location.name, &quot;Amsterdam&quot;)
        self.assertEqual(location.country.iso, &quot;NL&quot;)

    def test_parse_args(self):
        &quot;&quot;&quot;
        Test the parse_args function.
        &quot;&quot;&quot;
        source=Volume.default_source()
        args = Volume.parse_args([&quot;--source&quot;, source])
        self.assertEqual(args.source, source)

    def test_json_loading(self):
        &quot;&quot;&quot;
        Test the JSON loading from a file.
        &quot;&quot;&quot;
        with open(Volume.default_source()) as file:
            json_data = json.load(file)
        self.assertIsNotNone(json_data)
        pass
```
","1696863811","","","","https://stackoverflow.com/q/77259921","","","Question","neo4j.exceptions.ServiceUnavailable Connection to 127.0.0.1:7687 closed without handshake response","false","77259921","220",,,,,
"591",":User","","","","","Wolfgang Fahl","","","","","","User","","false","1497139","",,,,,
"592",":Question","","0","How do I query my projected graph? Ideally, I want to be able to do this:

```
# We put this simple graph in our database
gds.run_cypher(
  &quot;&quot;&quot;
  CREATE
    (m: City {name: &quot;Malm&#246;&quot;}),
    (l: City {name: &quot;London&quot;}),
    (s: City {name: &quot;San Mateo&quot;}),

    (m)-[:FLY_TO]-&gt;(l),
    (l)-[:FLY_TO]-&gt;(m),
    (l)-[:FLY_TO]-&gt;(s),
    (s)-[:FLY_TO]-&gt;(l)
  &quot;&quot;&quot;
)

# We estimate required memory of the operation
res = gds.graph.project.estimate(
    [&quot;City&quot;],                   #  Node projection
    &quot;FLY_TO&quot;,                   #  Relationship projection
    readConcurrency=4           #  Configuration parameters
)
assert res[&quot;bytesMax&quot;] &lt; 1e12

G, result = gds.graph.project(
    &quot;offices&quot;,                  #  Graph name
    [&quot;City&quot;],                   #  Node projection
    &quot;FLY_TO&quot;,                   #  Relationship projection
    readConcurrency=4           #  Configuration parameters
)

res = gds.run_cypher(&lt;some cypher on G&gt;)
```

According to [GDS documentation][1], it looks like I need to use gds.alpha.create.cypherdb(), but I only have read-only access.

What is a good way to run cypher queries on a projected graph? The other methods have the mutate mode where it takes in the projected graph object as an argument, but I don&#39;t see such documentation for just running cypher via run_cypher().


  [1]: https://neo4j.com/docs/graph-data-science/current/management-ops/create-cypher-db/","1696834234","","","","https://stackoverflow.com/q/77256767","","","Question","gds.run_cypher() on a projected graph","false","77256767","66",,,,,
"593",":User","","","","","matlibplotter","","","","","","User","","false","2744662","",,,,,
"594",":Question","77261015","1","I have a series of comments and replies, each comment can have multiple replies and each reply can in turn have any number of nested or immediate replies.

Here is some sample data graphed:
[![][1]][1]

Here I have one post with 4 comments, each replied to the previous comment
I would like to write a query so I can get them returned as nested lists like so
```JSON
Post = {
   ...
   comments: [
      comment: {
          ...
          replies: [
              comment: {
                  ...
                  replies: [
                      comment : {
                         etc
                  ]
              }
          ]
      }
   ]
}
```
Where each comment has a list of replies and each of those replies has replies you get the point

I&#39;m very new to using cypher I&#39;m more familiar with mongoDB so this is the query I have so far
```
MATCH tree1 = (post:POST)&lt;-[:COMMENTED_ON]-(comment:COMMENT)
OPTIONAL MATCH tree2 = (comment)&lt;-[replied_to:REPLIED_TO *]-(reply:COMMENT)
WHERE ID(post) = 5
RETURN nodes(tree1), nodes(tree2)
```
Which gets all the nodes, but it&#39;s just the list of nodes, with a lot of repeats
I&#39;ve done a lot of googling, and I looked at the FOREACH functionality but I&#39;m not sure how I would properly apply it here. I can almost definitely write a query that I can then use code to turn into the structure I need it to be in but it would be nice if I could write a query to do that for me or at least one that returns the nodes in a format where it&#39;s easier to do that 

  [1]: https://i.stack.imgur.com/1yWhz.png","1696822048","","","","https://stackoverflow.com/q/77256130","","","Question","Cypher Query to get a nested array of nodes at each level of a tree of nodes","false","77256130","24",,,,,
"595",":User","","","","","snakebite-382","","","","","","User","","false","13685040","",,,,,
"596",":Question","","0","I am having an error when trying to use APOC library function apoc.nodes.cycles. It says that there is no procedure found with that name. When listing the procedures found I get the following [![List of procedures][1]][1]

As you can see there is no procedure called apoc.nodes.cycles even tho the [documentation][2] says otherwise. When calling apoc.version() I get version 5.12.0 and my neo4j version is 5.3.0. I am using Neo4j Desktop 1.5.9. What am I doing wrong? Please help!


**EDIT**

Now I am a bit confused. When I said I am running Neo4J version 5.3.0 I was referring to this: ![picture][3].

But now that I found another one saying I am running version 5.12.0: ![New pic][4][4].

This means I am running compatible as per @cybersam comment. But still not able to find the procedure. 

  [1]: https://i.stack.imgur.com/ecpsz.png
  [2]: https://neo4j.com/docs/apoc/current/overview/apoc.nodes/
  [3]: https://i.stack.imgur.com/vgbkn.png
  [4]: https://i.stack.imgur.com/4QArM.png","1696797973","","","","https://stackoverflow.com/q/77255284","","","Question","Neo.ClientError.Procedure.ProcedureNotFound &quot;apoc.nodes.cycles&quot;","false","77255284","70",,,,,
"597",":User","","","","","Mohammed","","","","","","User","","false","14479366","",,,,,
"598",":Question","","1","I am using express with Neo4j graphql. 

Seeing this exception without specific line indications in my code. 

    node:internal/process/promises:289
                triggerUncaughtException(err, true /* fromPromise */);
                ^
    
    [UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason &quot;[object Array]&quot;.] {   code: &#39;ERR_UNHANDLED_REJECTION&#39; }
    
    Node.js v20.3.0


1. I have graph data models defined in **&quot;graph-data-models.js&quot;**

        ...        
        const driver = neo4j.driver(
        ...
        );
    
        const ObjectGraphMap = new OGM({ typeDefs, driver });
        const Challenge = ObjectGraphMap.model(&quot;Challenge&quot;);
        ...
2. Express Server on **&quot;app.js&quot;**. Server should start from here. I run ```node app.js```.

    ```
    ...
    try {
        await ObjectGraphMap.init();
        app.listen(port, () =&gt; {
            logger.info(`Data API App listening at http://localhost:${port}`);
        });
    } catch(e) {
        logger.error(&quot;OGM init failed&quot;,e);
    }
    ```
 3. API Definitions in **&quot;api.js&quot;**
```
...
app = express()
...
app.get(&quot;/challenges&quot;, getChallenges);
...
```
4. Data Models used in **&quot;api-impl.js&quot;**
```
...
const getChallenges = async (req, res) =&gt; {
    try {
      ...  
      Challenge.find({
            ... }
        })
        .then((challenge) =&gt; {
           ...
        })
        .catch((err) =&gt; {
        ...
        });
    } catch (error) {
        ...
    } 
}
...
```

It looks to me like something more than just wrapping around a try-catch at all places. How can I debug and find out the issue? OGM init needs some change but then-catch model on **&quot;app.js&quot;** like.
```
...
ObjectGraphMap.init()
    .then(() =&gt; {
    ...
    }) 
    .catch(() =&gt; {
    ...
    })
...
```
does not cut it.  ","1696778777","","","","https://stackoverflow.com/q/77254191","","","Question","UnhandledPromiseRejection while OGM initialize on Neo4j GraphQL Express Server","false","77254191","65",,,,,
"599",":User","","","","","Naveen Karnam","","","","","","User","","false","2477612","",,,,,
"600",":Question","","0","How can I return all documents from a neo4j vector store in langchain?
Is there a wildcard I can use with the neo4jVector.search() function to return a list of all document objects?

I want to be able to know which documents were already added before I add more pdfs in the vectorstore from a folder that contains pdfs added already in the store previously.

thank you!","1696778059","","","","https://stackoverflow.com/q/77254152","","","Question","How to return all documents from a neo4j vector store in langchain?","false","77254152","136",,,,,
"601",":User","","","","","Paris Char","","","","","","User","","false","814044","",,,,,
"602",":Question","","0","neo4j 5 provides HTTP API here https://neo4j.com/docs/http-api/current/transactions/
it can execute multiple queries, but in the description, the multiple queries runs in sequence.
I want to run 20 read queries, it will be slow, is there any way to run them coroutine or parallel? 


Use Golang HTTP to run 20 queries in a http request, it is slowly.","1696658929","","","","https://stackoverflow.com/q/77248582","","","Question","neo4j 5 HTTP API how to send multiple queries coroutine?","false","77248582","20",,,,,
"603",":User","","","","","Reid","","","","","","User","","false","17989452","",,,,,
"604",":Question","77246728","2","So I have this graph structure where many &quot;Top level&quot; and subspaces spaces can exist like this:
[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/kOPCH.png

I have the next cypher query:

    MATCH (user:User {auth_token: $auth_token}) 
          MATCH (space:Space)
          WHERE (
            (NOT (space)&lt;-[:PARENT_OF]-(:Space) AND (user)-[:MEMBER_OF]-&gt;(space) AND space.pod_state IN [&#39;active&#39;, &#39;pending&#39;] AND space.pod_type IN [&#39;standard&#39;, &#39;readonly&#39;])
            OR
            (EXISTS {MATCH (parent:Space)-[:PARENT_OF*]-&gt;(space)&lt;-[:MEMBER_OF]-(user) WHERE NOT (user)-[:MEMBER_OF]-&gt;(parent) AND space.pod_state IN [&#39;active&#39;, &#39;pending&#39;] AND space.pod_type IN [&#39;standard&#39;, &#39;readonly&#39;]})
          )
          RETURN space
    
What I need in this case is the list of spaces (blue) that a user can see (yellow) 
So:
 - Simon DDD should only see &quot;TOP LEVEL SPACE&quot; even when he is also a member of &quot;LEVEL 2 SPACE&quot; he should see the space with the highest level in every hierarchy.
 - Simon LALALA on the other hand should see &quot;LEVEL 2 SPACE&quot; since he is only a member of that space.

In the query provided SIMON DDD is getting both &quot;TOP LEVEL SPACE&quot; and &quot;LEVEL 2 SPACE&quot;
SIMON LALALA is okay since he is only a member of one space in the path

Also, the query works fine if, for example, SIMON DDD is a member of the &quot;LEVEL 1 SPACE A&quot; because the &quot;NOT&quot; clause on the query will work, which means if the user is a MEMBER OF every space in the path only shows the top level space","1696612280","","","","https://stackoverflow.com/q/77246324","","","Question","NEO4J query clause in a tree like membership graph","false","77246324","34",,,,,
"605",":Question","","1","I&#39;m using Neo4j to relate data extracted from official government documents, and I&#39;m developing a Python program to automate this process. However, there are cases where a more general entity is extracted, like `(:Position {symbol: &quot;xxx&quot;, name: &quot;yyy&quot;, effective: false})`. When I attempt to insert it into the database using a query like:

```cypher
MERGE (c:Position {symbol: &quot;xxx&quot;, name: &quot;yyy&quot;, effective: false})
RETURN ID(c)
```

The `MERGE` clause ends up matching a node of the type `(:Position {symbol: &quot;xxx&quot;, name: &quot;yyy&quot;, location:&quot;zzz&quot;, effective: false})`.

How can I modify my Cypher query to ensure that the node `(c:Position {symbol: &quot;xxx&quot;, name: &quot;yyy&quot;, effective: false})` is inserted into the database? In this case, using `CREATE` alone is not sufficient, as similar nodes might be extracted again.

I encountered a similar issue in [this post](https://stackoverflow.com/questions/38190061/merge-node-with-null-property-neo4j). However, the provided solution doesn&#39;t work in my case because the `WHERE` clause returns nothing.","1696601281","","","","https://stackoverflow.com/q/77245127","","","Question","Inserting General Entities in Neo4j Using MERGE: Matching Issue with Similar Nodes","false","77245127","26",,,,,
"606",":User","","","","","Gabriel Nogueira","","","","","","User","","false","22695803","",,,,,
"607",":Question","77244356","2","I have a query as follows which returns account holder with their monthly average transaction amount.

```
MATCH (mt:MoneyTransfer)&lt;-[s:SEND]-(:BankAccount)&lt;-[hba:HAS_BANKACCOUNT]-(ah:AccountHolder)
WHERE (mt.TransactionDate &lt;= date(&quot;2023-09-30&quot;) AND mt.TransactionDate &gt;= date(&quot;2023-09-01&quot;))
RETURN ah.Name as AccountHolder, AVG(mt.MoneyTransferAmount);
```

How to apply condition on above output so that I will get account holders whose average monthly money transfer amount (`AVG(mt.MoneyTransferAmount)`) is greater or less than any certain amount?

I tried multiple things but nothing worked for me.","1696592412","","","","https://stackoverflow.com/q/77244145","","","Question","How to apply conditions on return values in Neo4j cypher","false","77244145","36",,,,,
"608",":Question","77247307","1","I&#39;ve a project where I can successfully test my user procedure written using the neo4j traversal framework based on example testing projects.

The relevant part of the pom file is


```
...
  &lt;neo4j.version&gt;5.12.0&lt;/neo4j.version&gt;
  &lt;neo4j-java-driver.version&gt;5.3.0&lt;/neo4j-java-driver.version&gt;
&lt;/properties&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.neo4j&lt;/groupId&gt;
      &lt;artifactId&gt;neo4j&lt;/artifactId&gt;
      &lt;version&gt;${neo4j.version}&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.neo4j.test&lt;/groupId&gt;
      &lt;artifactId&gt;neo4j-harness&lt;/artifactId&gt;
      &lt;version&gt;${neo4j.version}&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.neo4j.driver&lt;/groupId&gt;
      &lt;artifactId&gt;neo4j-java-driver&lt;/artifactId&gt;
      &lt;version&gt;${neo4j-java-driver.version}&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- https://mvnrepository.com/artifact/org.neo4j.procedure/apoc --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.neo4j.procedure&lt;/groupId&gt;
      &lt;artifactId&gt;apoc&lt;/artifactId&gt;
      &lt;version&gt;4.4.0.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
...
```

I&#39;ve set up the embeddedDatabaseServer like this

```
@BeforeEach
void initializeNeo4j() throws IOException {
    
    var sw = new StringWriter();
    try (var in = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(&quot;/getNode/tvlike_test_data.cypher&quot;)))) {
        in.transferTo(sw);
        sw.close();
    }
    //split into each statement so can be run one by one
    List&lt;String&gt; statements = Arrays.asList(sw.toString().split(&quot;;\r\n&quot;));

    var builder = Neo4jBuilders.newInProcessBuilder()
            .withDisabledServer()
            .withProcedure(GetNode.class);

    for (String statement : statements) {
        builder.withFixture(statement);
    }
    
    this.embeddedDatabaseServer = builder.build();
}
```
and the tests run successfully e.g.

```
@Test
void TryIt() {
            try (
                    var driver = GraphDatabase.driver(embeddedDatabaseServer.boltURI());
                    var session = driver.session()
    
            ) {
    
                var results = session.run(&quot;&quot;&quot;
                                match(u:User{userId:&#39;u1&#39;})
                                where u.isEnabled = true
                                match(n:Trial{id: &#39;tr1&#39;})
                                call cctc.getNode(n, u, { includeFoundPermissions : true }) 
                                    yield allNodePerms, allPropPerms
                                return allNodePerms, allPropPerms&quot;&quot;&quot;)
                        .single();
                var resMap = results.asMap();
    
                //
                var allNodePerms = (List&lt;Map&lt;String, Object&gt;&gt;) resMap.get(&quot;allNodePerms&quot;);
                assertThat(allNodePerms.size()).isEqualTo(1);
            }
        }
```

I&#39;d like to include apoc procs and functions in my testing, but I can&#39;t add the necessary infrastructure successfully. For example, running this

```
@Test
void TryIt2() {
    try (
            var driver = GraphDatabase.driver(embeddedDatabaseServer.boltURI());
            var session = driver.session()

    ) {

        var results = session.run(&quot;&quot;&quot;
                        return apoc.text.code(103) AS output&quot;&quot;&quot;)
                .single();

        assertThat(results.get(&quot;output&quot;)).isEqualTo(&quot;g&quot;);
    }}
```

gives the error 

&gt; org.neo4j.driver.exceptions.ClientException: Unknown function
&gt; &#39;apoc.text.code&#39; (line 1, column 8 (offset: 7)) &quot;return
&gt; apoc.text.code(102) AS output&quot;

as you&#39;d expect.

The question is how do I add the apoc library into the embedded server in the set up step? I&#39;ve tried many examples found in various samples but without success.

The pom file already includes the dependency for the apoc procedures. I&#39;ve tried amending the @BeforeEach method in various ways, 
e.g.

 - https://github.com/Lukasmp3/neo4j-apoc-testing/commit/6ff0b3e92c4ca1b04f190638a6dcf280270a5f50
 - https://github.com/michael-simons/neo4j-examples-and-tips/blob/master/examples/testing-ogm-against-embedded-with-apoc/src/test/java/org/neo4j/tips/testing/testing_ogm_against_embedded_with_apoc/ApplicationTests.java
 - https://github.com/neo4j-contrib/rabbithole/blob/3.0/src/main/java/org/neo4j/community/console/Neo4jService.java#L55

but without success.

How can I amend this
```
        var builder = Neo4jBuilders.newInProcessBuilder()
                .withDisabledServer()
                .withProcedure(GetNode.class);
``` 
in my initializeNeo4j method to include apoc?
","1696581087","","","","https://stackoverflow.com/q/77242976","","","Question","neo4j procedure testing with apoc does not compile","false","77242976","77",,,,,
"609",":User","","","","","pilsdumps","","","","","","User","","false","310423","",,,,,
"610",":Question","","1","I&#39;m very new for neo4j.

Need to get output as array for already grouped nodes.[![enter image description here](https://i.stack.imgur.com/O8Y1j.png)](https://i.stack.imgur.com/O8Y1j.png)

In attached image having 13 node groups.

For example,

\[&#39;img8&#39;,&#39;img9&#39;,&#39;img47&#39;,&#39;img50&#39;,&#39;img51&#39;\] is one set

\[&#39;img20&#39;, &#39;img21&#39;\] is another set.

Like this we are having 13 node sets in attached image.

I need output like.

\[\[set1\],\[set2\],.....,\[set13\]\]","1696577166","","","","https://stackoverflow.com/q/77242556","","","Question","How do you return clusters in Neo4j?","false","77242556","76",,,,,
"611",":User","","","","","svk003","","","","","","User","","false","11299860","",,,,,
"612",":Question","","0","I want to run a neo4j database in docker and import data with the use of `neo4j-admin import` tool. I created a docker container with neo4j community edition with the following command:

 ``` 
     docker run --publish=7474:7474 --publish=7687:7687 \
     --volume=C:/mydir/import:/import \
     --env NEO4J_AUTH=neo4j/password \
     neo4j:5.11.0-community \
     bin/neo4j-admin database import full --id-type=INTEGER --nodes=NodeA=/import/nodesa.csv --nodes=NodeB=/import/nodesb.csv --relationships=RELA=/import/rels.csv --multiline-fields=true
```

This created the container and populated the database (the import finished succesfully):
 ``` 
IMPORT DONE in 13s 945ms.
Imported:
  75650 nodes
  95438 relationships
  255509 properties
Peak memory usage: 547.9MiB
 ``` 

But when I checked in the docker desktop the container was not running. I cannot strat the container, because it wants to re-import the data and I get the following error:

    java.lang.RuntimeException: java.nio.file.DirectoryNotEmptyException: /data/databases/neo4j already contains data, cannot do import here

Why is this so and how can I run neo4j in docker and use the import tool. Or start the container after executing the above mentioned command.
I am using community edition of the database, is this maybe the problem; see: [The neo4j-admin database import command: command-line tool useful for straightforward loading of large datasets. Works with Neo4j Desktop, Neo4j EE Docker image and local installations.](https://neo4j.com/docs/getting-started/data-import/csv-import/)
But I find it kind of odd that in the console I get the message that the database was imported.


Edit (logs from docker desktop after re-starting the container):
 ``` 
2023-10-05 19:47:47 Neo4j version: 5.11.0
2023-10-05 19:47:47 Importing the contents of these files into /data/databases/neo4j:
2023-10-05 19:47:47 Nodes:
2023-10-05 19:47:47   [NodeA]:
2023-10-05 19:47:47   /import/nodea.csv
2023-10-05 19:47:47 
2023-10-05 19:47:47   [NodeB]:
2023-10-05 19:47:47   /import/nodeb.csv
2023-10-05 19:47:47 
2023-10-05 19:47:47 Relationships:
2023-10-05 19:47:47   RELA:
2023-10-05 19:47:47   /import/rels.csv
2023-10-05 19:47:47 
2023-10-05 19:47:47 
2023-10-05 19:47:47 Available resources:
2023-10-05 19:47:47   Total machine memory: 11.70GiB
2023-10-05 19:47:48   Free machine memory: 10.06GiB
2023-10-05 19:47:48   Max heap memory : 2.601GiB
2023-10-05 19:47:48   Max worker threads: 8
2023-10-05 19:47:48   Configured max memory: 6.760GiB
2023-10-05 19:47:48   High parallel IO: true
2023-10-05 19:47:48 
2023-10-05 19:47:52 
2023-10-05 19:47:52 IMPORT FAILED in 0ms. 
2023-10-05 19:47:52 Data statistics is not available.
2023-10-05 19:47:52 Peak memory usage: 0B
2023-10-05 19:47:52 Database already exist. Re-run with `--overwrite-destination` to remove the database prior to import
2023-10-05 19:47:52 Caused by:/data/databases/neo4j already contains data, cannot do import here
2023-10-05 19:47:52 
2023-10-05 19:47:52 WARNING Import failed. The store files in /data/databases/neo4j are left as they are, although they are likely in an unusable state. Starting a database on these store files will likely fail or observe inconsistent records so start at your own risk or delete the store manually
2023-10-05 19:47:52 java.lang.RuntimeException: java.nio.file.DirectoryNotEmptyException: /data/databases/neo4j already contains data, cannot do import here
2023-10-05 19:47:52 at org.neo4j.importer.CsvImporter.andPrintError(CsvImporter.java:358)
2023-10-05 19:47:52 at org.neo4j.importer.CsvImporter.doImport(CsvImporter.java:268)
2023-10-05 19:47:52 at org.neo4j.importer.CsvImporter.doImport(CsvImporter.java:181)
2023-10-05 19:47:52 at org.neo4j.importer.ImportCommand$Base.doExecute(ImportCommand.java:405)
2023-10-05 19:47:52 at org.neo4j.importer.ImportCommand$Full.execute(ImportCommand.java:531)
2023-10-05 19:47:52 at org.neo4j.cli.AbstractCommand.call(AbstractCommand.java:92)
2023-10-05 19:47:52 at org.neo4j.cli.AbstractCommand.call(AbstractCommand.java:37)
2023-10-05 19:47:52 at picocli.CommandLine.executeUserObject(CommandLine.java:2041)
2023-10-05 19:47:52 at picocli.CommandLine.access$1500(CommandLine.java:148)
2023-10-05 19:47:52 at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461)
2023-10-05 19:47:52 at picocli.CommandLine$RunLast.handle(CommandLine.java:2453)
2023-10-05 19:47:52 at picocli.CommandLine$RunLast.handle(CommandLine.java:2415)
2023-10-05 19:47:52 at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273)
2023-10-05 19:47:52 at picocli.CommandLine$RunLast.execute(CommandLine.java:2417)
2023-10-05 19:47:52 at picocli.CommandLine.execute(CommandLine.java:2170)
2023-10-05 19:47:52 at org.neo4j.cli.AdminTool.execute(AdminTool.java:94)
2023-10-05 19:47:52 at org.neo4j.cli.AdminTool.main(AdminTool.java:82)
2023-10-05 19:47:52 Caused by: java.nio.file.DirectoryNotEmptyException: /data/databases/neo4j already contains data, cannot do import here
2023-10-05 19:47:52 at org.neo4j.internal.batchimport.store.BatchingNeoStores.assertDatabaseIsNonExistent(BatchingNeoStores.java:230)
2023-10-05 19:47:52 at org.neo4j.internal.batchimport.store.BatchingNeoStores.createNew(BatchingNeoStores.java:203)
2023-10-05 19:47:52 at org.neo4j.internal.batchimport.ParallelBatchImporter.doImport(ParallelBatchImporter.java:131)
2023-10-05 19:47:52 at org.neo4j.importer.CsvImporter.doImport(CsvImporter.java:264)
2023-10-05 19:47:52 ... 15 more

 ``` ","1696525318","","","","https://stackoverflow.com/q/77239190","","","Question","Neo4j docker - admin import - cannot start container","false","77239190","42",,,,,
"613",":User","","","","","iuhztr tzhjzuk","","","","","","User","","false","22659125","",,,,,
"614",":Question","77233591","1","I am trying to load some csv data with the help of the `neo4j-admin import` command into neo4j running in docker.
First I ran the following docker run command:
```
docker run \
    --publish=7474:7474 --publish=7687:7687 \
    --volume=C:/my_dir:/import \
    --env NEO4J_AUTH=neo4j/password \
    neo4j:5.11.0-community \
```

After the container was created and started I executed the import command in the docker desktop&#39;s neo4j container terminal.
```
bin/neo4j-admin database import full --id-type=INTEGER --nodes=NodeA=import/nodes.csv --nodes=NodeB=import/nodesB.csv --relationships=RELA=import/rels.csv --multiline-fields=true
```
But I get the following error:

```
Invalid value for option &#39;--nodes&#39; at index 0 ([&lt;label&gt;[:&lt;label&gt;]...=]&lt;files&gt;): Invalid nodes file: NodeA=import/nodes.csv (java.lang.IllegalArgumentException: File &#39;import/nodes.csv&#39; doesn&#39;t exist)
```



I checked the import folder of the docker container and the folder is mounted and all the csv files are in it. So I do not know why the import is not working.

I have also installed the same neo4j version locally (windows), where I could successfully import the database with the same `neo4j-admin import` command mentioned above and the same csv files. But I could not make it work using docker.


","1696458810","","","","https://stackoverflow.com/q/77233349","","","Question","neo4j-admin import command not working in docker (java.lang.IllegalArgumentException: File &#39;import/nodes.csv&#39; doesn&#39;t exist)","false","77233349","99",,,,,
"615",":Question","","1","![screen capture](https://i.stack.imgur.com/alI7e.png)

While installing Neo4j Desktop Setup 1.5.9 in windows 11 i have facing this issue. Not able to go thru this step.


![enter image description here](https://i.stack.imgur.com/fNV7P.png)
![enter image description here](https://i.stack.imgur.com/QiBlm.png)

I have added Path to environ variable. I have added PowerShell path. but still not able to resolve the issue. please guide me to resolve it .
Thank you 

[This is log.log file](https://drive.google.com/file/d/1hYT_Ar8xfAzPkTbY86s5TXm84QwbiklK/view?usp=drive_link) 
","1696455946","","","","https://stackoverflow.com/q/77233161","","","Question","installation issue with Neo4j Desktop Setup 1.5.9 in windows 11","false","77233161","72",,,,,
"616",":User","","","","","Ajit Singh Yadav","","","","","","User","","false","22685620","",,,,,
"617",":Question","77224777","1","I want to perform this query in neo4j but i&#39;m not getting proper.

NOT((service provid_by Adani Transmission Limited AND service address_in Formosa) OR service depen_on Video interview data)

#### Cypher query  

```
MATCH (node:service )-[provid_by]-&gt;(dst:provider)
WITH DISTINCT node, COLLECT(DISTINCT TOLOWER(dst.name)) AS names
WHERE NONE(name IN names WHERE name IN [&quot;adani transmission limited&quot;]) OR size(names) = 0
WITH DISTINCT node
RETURN DISTINCT node
UNION
MATCH (node:service )-[address_in]-&gt;(dst:Address)
WITH DISTINCT node, COLLECT(DISTINCT TOLOWER(dst.name)) AS names
WHERE NONE(name IN names WHERE name IN [&quot;formosa&quot;]) OR size(names) = 0
WITH DISTINCT node
MATCH (node:service)-[depen_on]-&gt;(dst:res)
WITH DISTINCT node, COLLECT(DISTINCT TOLOWER(dst.name)) AS names
WHERE NONE(name IN names WHERE name IN [&quot;video interview data&quot;]) OR size(names) = 0
WITH DISTINCT node
WITH DISTINCT node
ORDER BY node.createdAt DESC
RETURN DISTINCT node
UNION
MATCH (node:service) WHERE NOT (node)-[:provid_by]-&gt;(:Participant)
WITH DISTINCT node
RETURN DISTINCT node
UNION
MATCH (node:service)
WHERE NOT (node)-[:address_in]-&gt;(:Address)
WITH DISTINCT node
RETURN DISTINCT node
UNION
MATCH (node:service)
WHERE NOT (node)-[:depen_on]-&gt;(:res)
WITH DISTINCT node
RETURN DISTINCT node
```","1696330947","","","","https://stackoverflow.com/q/77221688","","","Question","How to write or with not query in neo4j","false","77221688","48",,,,,
"618",":User","","","","","Mittal Vaghela","","","","","","User","","false","20630792","",,,,,
"619",":Question","","2","Let&#39;s say i have two different nodes in my DB:

```none
(p:person {name: &quot;Claudia&quot;})-[:likes]-&gt;(h:hobby {name: &quot;football&quot;, experience: &quot;2 years&quot;})
```

My goal is to make each person&#39;s hobby unique by its `name` attribute, but at the same time I want to be able to create another `(h:hobby {name: &quot;football&quot;})` node, related to some other `person` and it would be 2 different nodes (it&#39;s important!).

How can I do that?

I tried:
```
CREATE CONSTRAINT FOR (h:hobby),(p:person) REQUIRE (p:person)-[:likes]-&gt;(h.name) IS UNIQUE
```
but it doesn&#39;t even work, giving me:

```none
Invalid input &#39;(&#39;: expected &quot;)&quot; or an identifier (line 2, column 6 (offset: 24))
&quot;FOR ((h:hobby),(p:person))&quot;
```

**SOLUTION:**

In [Finbar&#39;s Good answer](https://stackoverflow.com/a/77215248/20132179) I found useful statement: `WHERE NOT EXISTS`.

I can guarantee each `person` has only one related `(h:hobby {name: &quot;football&quot;})` node using this statement and I can add `uuid` property for each `hobby` node I create to make sure it&#39;s unique  within the database:
```cypher
MATCH (p:Person { name: &quot;Claudia&quot; })
WHERE NOT EXISTS { (p)-[:LIKES]-&gt;(:Hobby {name: &quot;football&quot;}) }
CREATE (p)-[:LIKES]-&gt;(:Hobby {name: &quot;football&quot;, experience: &quot;2 years&quot;, id: apoc.create.uuid()})
```","1696244277","","","","https://stackoverflow.com/q/77215052","","","Question","How can I create a constraint on pairs of nodes based on their labels and attributes?","false","77215052","52",,,,,
"620",":User","","","","","Boris Buklov","","","","","","User","","false","20132179","",,,,,
"621",":Question","","0","I have a requirement to write a Python code that fetches neo4j graphical output and show it in my web browser. I have used API and wrote a Python code that display the neo4j output as JSON but I would like to have it as a graph visual output in my web browser.

Can you please help on this?","1696238911","","","","https://stackoverflow.com/q/77214504","","","Question","Rendering Neo4j graph output in my web browser","false","77214504","19",,,,,
"622",":User","","","","","Jegatheesan","","","","","","User","","false","12753662","",,,,,
"623",":Question","","1","I have the following Cypher query:

    PROFILE MATCH (p:Profile)  MATCH (v:Vacancy:Decision {id: 17210})
    WHERE NOT exists((v)&lt;-[:POSSIBLE_PROFILE]-(p))
    RETURN p, v;

and only 5000 Profiles in my test DB.

The plan:

[![enter image description here][1]][1]

I&#39;m concerned about the number of DB hits highlighted in the green rectangle. Could you please show me how to optimize this query?


  [1]: https://i.stack.imgur.com/dz2FS.png","1696190251","","","","https://stackoverflow.com/q/77212102","","","Question","Neo4j Cypher query DB hits optimization","false","77212102","39",,,,,
"624",":Question","","0","I&#39;m running Ubuntu 22.04 on the VirtualBox, and when I try to log into the neo4j browser and create a new password, I get an error that says 

&quot;Neo.DatabaseError.General.UnknownError: Could not initialize class org.eclipse.collections.impl.utility.LazyIterate&quot;

I have downloaded java via &quot;sudo apt-get install openjdk-17-jdk, and I have also tried manally downloading a package from Oracle, but it didn&#39;t help.

I would deeply appreciate any guidance on fixing this problem.

Thank you
","1696132133","","","","https://stackoverflow.com/q/77209159","","","Question","Neo.DatabaseError.General.UnknownError: Could not initialize class org.eclipse.collections.impl.utility.LazyIterate","false","77209159","24",,,,,
"625",":User","","","","","joon4620","","","","","","User","","false","22664342","",,,,,
"626",":Question","","3","I&#39;ve successfully managed to display and create nodes in Neo4j using Python, but I&#39;m struggling to update nodes in Neo4j using Python. I&#39;ve attempted to seek assistance from ChatGPT, but I&#39;m still unable to figure out how to update nodes in Neo4j
This is the python code
```
from neo4j import GraphDatabase


class Neo4jConnector:
    def __init__(self, uri, user, password):
        self._driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        self._driver.close()

    @property
    def driver(self):
        return self._driver


def create_node(neo4j_conn, sender, receiver, message, profile_id, rule_type, processing_flag, return_name):
    query = (
        &quot;CREATE (n:Message {sender: $sender, receiver: $receiver, &quot;
        &quot;message: $message, profile_id: $profile_id, rule_type: $rule_type, &quot;
        &quot;processing_flag: $processing_flag,return_name:$return_name})&quot;
    )

    with neo4j_conn._driver.session() as session:
        session.write_transaction(lambda tx: tx.run(query, sender=sender, receiver=receiver,
                                                    message=message, profile_id=profile_id,
                                                    rule_type=rule_type, processing_flag=processing_flag,
                                                    return_name=return_name))


def display_nodes(neo4j_conn):
    query = &quot;MATCH (n:Message) RETURN n&quot;

    with neo4j_conn._driver.session() as session:
        result = session.run(query)
        for record in result:
            node = record[&quot;n&quot;]
            print(node)


def get_nodes_by_processing_flag(tx, processing_flag):
    query = (
        &quot;MATCH (node:Message) &quot;
        &quot;WHERE node.processing_flag = $processing_flag &quot;
        &quot;RETURN node&quot;
    )
    result = []
    for record in tx.run(query, processing_flag=processing_flag):
        result.append(record[&quot;node&quot;])
    return result


def update_node(tx, new_profile_id, new_message, new_processing_flag, return_name):
    query = (
        &quot;MATCH (n) WHERE return_name(n) = $return_name&quot;
        &quot;SET n.profile_id = $new_profile_id, &quot;
        &quot;    n.message = $new_message, &quot;
        &quot;    n.processing_flag = $new_processing_flag &quot;
    )
    tx.run(query,  new_profile_id=new_profile_id, new_message=new_message,
           new_processing_flag=new_processing_flag, return_name=return_name)


def main():
    uri = &quot;bolt://localhost:7687&quot;  # Update with your Neo4j server URI
    user = &quot;admin&quot;  # Update with your Neo4j username
    password = &quot;password&quot;  # Update with your Neo4j password

    connector = Neo4jConnector(uri, user, password)

    while True:
        print(&quot;1. Create Node&quot;)
        print(&quot;2. Display Nodes&quot;)
        print(&quot;3. Get Nodes by Processing Flag&quot;)
        print(&quot;4. Update Node&quot;)
        print(&quot;5. Quit&quot;)

        choice = input(&quot;Enter your choice: &quot;)

        if choice == &quot;1&quot;:
            sender = input(&quot;Enter sender: &quot;)
            receiver = input(&quot;Enter receiver: &quot;)
            message = input(&quot;Enter message: &quot;)
            profile_id = input(&quot;Enter profile_id: &quot;)
            rule_type = input(&quot;Enter rule_type: &quot;)
            processing_flag = input(&quot;Enter processing_flag: &quot;)
            return_name = sender + rule_type + receiver
            create_node(connector, sender, receiver, message, profile_id, rule_type, processing_flag, return_name)

        elif choice == &quot;2&quot;:
            display_nodes(connector)

        elif choice == &quot;3&quot;:
            user_input = input(&quot;Enter the processing flag: &quot;)
            with connector._driver.session() as session:
                nodes = session.read_transaction(get_nodes_by_processing_flag, user_input)

            if nodes:
                print(f&quot;Nodes with processing flag &#39;{user_input}&#39;:&quot;)
                for node in nodes:
                    print(node)
            else:
                print(f&quot;No nodes found with processing flag &#39;{user_input}&#39;.&quot;)

        elif choice == &quot;4&quot;:
            return_name = input(&quot;Enter return name: &quot;)
            new_profile_id = input(&quot;Enter new profile_id: &quot;)
            new_message = input(&quot;Enter new message: &quot;)
            new_processing_flag = input(&quot;Enter new processing_flag: &quot;)
            with connector.driver.session() as session:
                session.write_transaction(update_node,  new_profile_id, new_message,
                                          new_processing_flag, return_name)
            print(&quot;Node updated successfully.&quot;)

        elif choice == &quot;5&quot;:
            connector.close()
            break


if __name__ == &quot;__main__&quot;:
    main()

```


This was the error from the code

```
Traceback (most recent call last):
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\main.py&quot;, line 120, in &lt;module&gt;
    main()
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\main.py&quot;, line 110, in main
    session.write_transaction(update_node,  new_profile_id, new_message,
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\venv\Lib\site-packages\neo4j\_meta.py&quot;, line 209, in inner
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\venv\Lib\site-packages\neo4j\_sync\work\session.py&quot;, line 791, in write_transaction
    return self._run_transaction(
           ^^^^^^^^^^^^^^^^^^^^^^
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\venv\Lib\site-packages\neo4j\_sync\work\session.py&quot;, line 550, in _run_transaction
    result = transaction_function(tx, *args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\main.py&quot;, line 59, in update_node
    tx.run(query,  new_profile_id=new_profile_id, new_message=new_message,
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\venv\Lib\site-packages\neo4j\_sync\work\transaction.py&quot;, line 164, in run
    result._tx_ready_run(query, parameters)
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\venv\Lib\site-packages\neo4j\_sync\work\result.py&quot;, line 116, in _tx_ready_run
    self._run(query, parameters, None, None, None, None, None, None)
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\venv\Lib\site-packages\neo4j\_sync\work\result.py&quot;, line 166, in _run
    self._attach()
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\venv\Lib\site-packages\neo4j\_sync\work\result.py&quot;, line 274, in _attach
    self._connection.fetch_message()
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\venv\Lib\site-packages\neo4j\_sync\io\_common.py&quot;, line 180, in inner
    func(*args, **kwargs)
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\venv\Lib\site-packages\neo4j\_sync\io\_bolt.py&quot;, line 851, in fetch_message
    res = self._process_message(tag, fields)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\venv\Lib\site-packages\neo4j\_sync\io\_bolt5.py&quot;, line 376, in _process_message
    response.on_failure(summary_metadata or {})
  File &quot;C:\Users\kevin\PycharmProjects\pyneo4j\venv\Lib\site-packages\neo4j\_sync\io\_common.py&quot;, line 247, in on_failure
    raise Neo4jError.hydrate(**metadata)
neo4j.exceptions.CypherSyntaxError: {code: Neo.ClientError.Statement.SyntaxError} {message: Invalid input &#39;n&#39;: expected
  &quot;!=&quot;
  &quot;%&quot;
  &quot;*&quot;
  &quot;+&quot;
  &quot;-&quot;
  &quot;.&quot;
  &quot;/&quot;
  &quot;:&quot;
  &quot;&lt;&quot;
  &quot;&lt;=&quot;
  &quot;&lt;&gt;&quot;
  &quot;=&quot;
  &quot;=~&quot;
  &quot;&gt;&quot;
  &quot;&gt;=&quot;
  &quot;AND&quot;
  &quot;CALL&quot;
  &quot;CONTAINS&quot;
  &quot;CREATE&quot;
  &quot;DELETE&quot;
  &quot;DETACH&quot;
  &quot;ENDS&quot;
  &quot;FOREACH&quot;
  &quot;IN&quot;
  &quot;IS&quot;
  &quot;LOAD&quot;
  &quot;MATCH&quot;
  &quot;MERGE&quot;
  &quot;OPTIONAL&quot;
  &quot;OR&quot;
  &quot;REMOVE&quot;
  &quot;RETURN&quot;
  &quot;SET&quot;
  &quot;STARTS&quot;
  &quot;UNION&quot;
  &quot;UNWIND&quot;
  &quot;USE&quot;
  &quot;WITH&quot;
  &quot;XOR&quot;
  &quot;[&quot;
  &quot;^&quot;
  &lt;EOF&gt; (line 1, column 50 (offset: 49))
&quot;MATCH (n) WHERE return_name(n) = $return_nameSET n.profile_id = $new_profile_id,     n.message = $new_message,     n.processing_flag = $new_processing_flag&quot;
                                                  ^}
```
 ","1696060493","","","","https://stackoverflow.com/q/77206137","","","Question","How to update the existing nodes in neo4j using python","false","77206137","80",,,,,
"627",":Question","77197477","2","I am encountering errors when including a function to split a string inside apoc.periodic.iterate in Neo4j. Namely, here is my query which runs fine:

```
WITH collect(file.URL) AS fileURLs
UNWIND fileURLs AS fileURL
CALL apoc.periodic.iterate(
&#39;
CALL apoc.load.csv($url) YIELD map AS csv
RETURN csv
&#39;,
&#39;
WITH round(toFloat(csv.dendrogram_height),3,&quot;HALF_UP&quot;) as height, csv.gene_name as gene, csv.event_no as event, csv.samples as sp, round(toFloat(csv.median_ge),3,&quot;HALF_UP&quot;) as me, csv.no_of_samples as no_s, csv.leaf_status as leaf, csv.patients as pts, csv.no_of_uniq_patients as no_pt, round((toFloat(csv.log2fc)),3,&quot;HALF_UP&quot;) as log2, round(toFloat(csv.padj_deseq2),3,&quot;HALF_UP&quot;) as padj, csv.up_or_down as up
CREATE (:Expression:Primary {name: gene, event_no: event, dendrogram_height: height, samples: sp, median_exp: me, no_of_samples: no_s, leaf_status: leaf, patients: pts, no_of_unique_patients: no_pt, log2fc: log2, padj_deseq2: padj, up_or_down: up});
&#39;,
{batchSize:10000,parallel:true,params:{url:fileURL}}) YIELD batches, total
RETURN batches, total;
```

But when I include the function ```split``` (or ```apoc.text.split``` for that matter) in the ```WITH``` statement, namely,

```
MATCH (file:File) WITH file
WITH collect(file.URL) AS fileURLs
UNWIND fileURLs AS fileURL
CALL apoc.periodic.iterate(
&#39;
CALL apoc.load.csv($url) YIELD map AS csv
RETURN csv
&#39;,
&#39;
WITH round(toFloat(csv.dendrogram_height),3,&quot;HALF_UP&quot;) as height, csv.gene_name as gene, csv.event_no as event, csv.samples as sp, round(toFloat(csv.median_ge),3,&quot;HALF_UP&quot;) as me, csv.no_of_samples as no_s, csv.leaf_status as leaf, split(csv.patients,&#39;,&#39;) as pts, csv.no_of_uniq_patients as no_pt, round((toFloat(csv.log2fc)),3,&quot;HALF_UP&quot;) as log2, round(toFloat(csv.padj_deseq2),3,&quot;HALF_UP&quot;) as padj, csv.up_or_down as up
CREATE (:Expression:Primary {name: gene, event_no: event, dendrogram_height: height, samples: sp, median_exp: me, no_of_samples: no_s, leaf_status: leaf, patients: pts, no_of_unique_patients: no_pt, log2fc: log2, padj_deseq2: padj, up_or_down: up});
&#39;,
{batchSize:10000,parallel:true,params:{url:fileURL}}) YIELD batches, total
RETURN batches, total;

```
I get an error saying:

```

Procedure call provides too many arguments: got 4 expected no more than 3.

Procedure apoc.periodic.iterate has signature: apoc.periodic.iterate(cypherIterate :: STRING?, cypherAction :: STRING?, config :: MAP?) :: batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, wasTerminated :: BOOLEAN?, failedParams :: MAP?, updateStatistics :: MAP?
meaning that it expects at least 3 arguments of types STRING?, STRING?, MAP?
Description: Runs the second statement for each item returned by the first statement.
This procedure returns the number of batches and the total number of processed rows. (line 4, column 1 (offset: 90))
&quot;CALL apoc.periodic.iterate(&quot;
 ^
```

The only difference is the ```split``` function in ```split(csv.patients,&#39;,&#39;)``` than ```csv.patients``` in the second query chunk.

How to resolve this? Thanks.","1695919180","","","","https://stackoverflow.com/q/77196825","","","Question","Splitting string with apoc.periodic.iterate","false","77196825","41",,,,,
"628",":User","","","","","user2167741","","","","","","User","","false","2167741","",,,,,
"629",":Question","77130068","3","In Neo4j Graph Data Science (GDS), each graph can have a corresponding projection. How can I obtain detailed information about the actual nodes and relationships stored within a specific projection? Is there a method to access specific node and relationship data within a projection?

For a specific graph catalog projection, `graph_0`, I can use `CALL gds.graph.list(&#39;graph_0&#39;)` to retrieve basic information about the projection, such as the number of nodes and relationships. However, no detailed information about nodes and relations is listed.


------- add an example to explain more detail -----------

 1. create a simple graph with following cypher command:
```
CREATE
  (alice:Buyer {name: &#39;Alice&#39;}),
  (instrumentSeller:Seller {name: &#39;Instrument Seller&#39;}),
  (bob:Buyer {name: &#39;Bob&#39;}),
  (carol:Buyer {name: &#39;Carol&#39;}),
  (alice)-[:PAYS { amount: 1.0}]-&gt;(instrumentSeller),
  (alice)-[:PAYS { amount: 2.0}]-&gt;(instrumentSeller),
  (alice)-[:PAYS { amount: 3.0}]-&gt;(instrumentSeller),
  (alice)-[:PAYS { amount: 4.0}]-&gt;(instrumentSeller),
  (alice)-[:PAYS { amount: 5.0}]-&gt;(instrumentSeller),
  (alice)-[:PAYS { amount: 6.0}]-&gt;(instrumentSeller),

  (bob)-[:PAYS { amount: 3.0}]-&gt;(instrumentSeller),
  (bob)-[:PAYS { amount: 4.0}]-&gt;(instrumentSeller),
  (carol)-[:PAYS { amount: 5.0}]-&gt;(bob),
  (carol)-[:PAYS { amount: 6.0}]-&gt;(bob)
```
[example graph][1]

2. project it.

```
MATCH (source)
OPTIONAL MATCH (source)-[r]-&gt;(target)
WITH gds.graph.project(
&#39;graph_0&#39;,
source,
target,
{
sourceNodeLabels: labels(source),
targetNodeLabels: labels(target),
relationshipType: type(r)
}
) AS g
RETURN g.graphName AS graph, g.nodeCount AS nodes, g.relationshipCount AS rels

// return: 
//graph	    nodes	rels
//&quot;graph_0&quot;	4	    10
```

3. run a random walk algorithm on the example graph
```
MATCH (start:Buyer {name: &#39;Alice&#39;})
CALL gds.graph.sample.rwr(&#39;mySample&#39;, &#39;graph_0&#39;, { samplingRatio: 0.66, startNodes: [id(start)] })
YIELD nodeCount, relationshipCount
RETURN nodeCount, relationshipCount
// return:
// nodeCount	relationshipCount
// 3	        8
```

4. In this example, there are multiple relations with the same type between two nodes, e.g. `PAYS` between `Alice` and `Instrument Seller`. I want to know which relationships (identified with relationship ID) are sampled in this sampling process. However, the current provided methods can only figure out which type of relations are sampled, instead of exact relationship IDs.


  [1]: https://i.stack.imgur.com/UQIV6.png","1694745757","","","","https://stackoverflow.com/q/77109331","","","Question","Is there a method to access specific node and relationship data within a graph catalog in neo4j GDS?","false","77109331","166",,,,,
"630",":User","","","","","Hao Chen","","","","","","User","","false","22475005","",,,,,
"631",":Question","77077498","1","Let&#39;s say I have a Decision base node with a defined ID:

    @NodeEntity
    public class Decision {
    
        @Id
        @Index(unique = true)
        private Long id;
    
    }

I have defined a `UNIQUE INDEX on Decision.id`. 

Additionally, I have two nodes derived from Decision:

    @NodeEntity
    public class Profile extends Decision {
    }
    
    @NodeEntity
    public class Notification extends Decision{
    }


Let&#39;s consider a scenario where I have `1000 Profiles` in my database and `1 billion Notifications`. Will querying Profiles by a Cypher query be significantly affected by the presence of 1 billion Notification nodes because they share the same common label &#39;Decision&#39;?

Should I also add a UNIQUE INDEX on &#39;Profile.id&#39; and &#39;Notification.id,&#39; even if they inherit it from the &#39;Decision&#39; node?","1694360142","","","","https://stackoverflow.com/q/77076783","","","Question","Neo4j multilabel modes and query performance","false","77076783","28",,,,,
"632",":Question","77080535","1","Here&#39;s a cypher that finds a pattern, creates a virtual node, and then creates a relationship with the real node.

```
MATCH (account:Account:Iam)-[:DATE]-&gt;(date:Date)-[:ACTED]-(start_log:Log)-[:ACTED*1..]-&gt;(end_log:Log)-[:DETECTED]-&gt;(rule:Rule)
WHERE account.name = &#39;ar_hk&#39;

WITH account, date, start_log, end_log, rule

MATCH path=(start_log)-[:ACTED*]-&gt;(end_log)

WITH account, date, start_log, end_log, rule, path

WITH account, date, start_log, end_log, rule, path,
     nodes(path) AS all_nodes

WITH account, date, start_log, end_log, rule, path, all_nodes,
     all_nodes[0] AS virtual_start,
     all_nodes[-1] AS virtual_end

WITH account, date, start_log, end_log, rule, virtual_start, virtual_end, length(path) AS path_length

CALL apoc.create.vNode([&#39;Analysis&#39;], {path_length: path_length}) YIELD node AS virtual_analysis

CREATE (virtual_start)-[:VIRTUAL_START]-&gt;(virtual_analysis)
CREATE (virtual_analysis)-[:VIRTUAL_END]-&gt;(virtual_end)

RETURN account, date, start_log, end_log, rule, virtual_analysis
```

The error &#39;Unable to load NODE 4:db8c4fa9-255d-4df3-a0e1-0818e92d3b53:-2369&#39; occurs.

Here is my second cypher :

```
MATCH (account:Account:Iam)-[:DATE]-&gt;(date:Date)-[:ACTED]-(start_log:Log)-[:ACTED*1..]-&gt;(end_log:Log)-[:DETECTED]-&gt;(rule:Rule)
WHERE account.name = &#39;ar_hk&#39;

WITH account, date, start_log, end_log, rule

MATCH path=(start_log)-[:ACTED*]-&gt;(end_log)

WITH account, date, start_log, end_log, rule, path

WITH account, date, start_log, end_log, rule, path,
     nodes(path) AS all_nodes

WITH account, date, start_log, end_log, rule, path, all_nodes,
     all_nodes[0] AS virtual_start,
     all_nodes[-1] AS virtual_end

CALL apoc.create.vNode([&#39;Analysis&#39;], {path_length: length(path)}) YIELD node as virtual_analysis

WITH account, date, start_log, end_log, rule, virtual_start, virtual_analysis, virtual_end

CREATE (virtual_start)-[:START]-&gt;(virtual_analysis)-[:END]-&gt;(virtual_end)

RETURN account, date, start_log, end_log, rule, virtual_analysis
```

but, The error &#39;Unable to load NODE 4:db8c4fa9-255d-4df3-a0e1-0818e92d3b53:-2369&#39; still occurs.

What did I do wrong?

Similar questions have been created before, but I don&#39;t think there are any questions about virtual nodes and virtual relationships.","1694256119","","","","https://stackoverflow.com/q/77071847","","","Question","Unable to load NODE 4:db8c4fa***.. error when i using CALL apoc.create.vNode","false","77071847","35",,,,,
"633",":User","","","","","nan yoo","","","","","","User","","false","20800420","",,,,,
"634",":Question","","0","Is there a way to get a relationships of specific node only in **neovis.js**. From the **Movie** sample limited the node to **2**. Now we have two movie nodes **The Matrix** and **The Matrix Reloaded**, want to show the relationship of the **The Matrix** node only, not for **The Matrix Reloaded**.

    MATCH (n:Movie) WITH n limit 2 OPTIONAL MATCH (n:Movie{title:&#39;The Matrix&#39;})-[r]-(b) RETURN n,r,b

**Expecting a relationship like this image.**

[![Expected Result][1]][1]


But my query return relationship for both nodes.

[![enter image description here][2]][2]


  [1]: https://i.stack.imgur.com/lr3Jy.png
  [2]: https://i.stack.imgur.com/X8rfQ.png

How to achive this in neovis.js?","1694091225","","","","https://stackoverflow.com/q/77059791","","","Question","How to show Relationship for specific node in cypher neo4j with neovis.js?","false","77059791","83",,,,,
"635",":User","","","","","Yugesh","","","","","","User","","false","2090784","",,,,,
"636",":Question","","1","    create (a:Class {name:&#39;A&#39;})-[:subClassOf]-&gt;(b:Class {name:&#39;B&#39;}) 
    create (b)-[:subClassOf]-&gt;(c:Class {name:&#39;C&#39;}) 
    create (rule:Rule {name:&#39;Rule1&#39;,
           condition:&#39;exists( (a:Class)-[:subClassOf]-&gt;(b:Class) ) AND exists(  (b:Class)-[:subClassOf]-&gt;(c:Class) )&#39;, 
           action:&#39;create (a)-[:subClassOf]-&gt;(c)&#39;})
 


I try to save the rule data as a string in the node properties, not in the backend program, and then create a query, read the conditions in the rule, and if it returns true, execute the action, for example:
    if exists any A-[:subClassOf]-&gt;B AND B-[:subClassOf]-&gt;C, then create A-[:subClassOf]-&gt;C.

I wrote a query like follows:

    MATCH (rule:Rule)
    WHERE rule.name = &#39;Rule1&#39;
    WITH rule, toBoolean(rule.condition) AS condition
    WHERE condition
    CALL apoc.cypher.run(rule.action) YIELD value
    RETURN value
    
But this query doesn&#39;t seem to return any results, how should I do it correctly?   Thanks for help!
","1694077271","","","","https://stackoverflow.com/q/77058102","","","Question","How to store and use rules as string in neo4j node property","false","77058102","68",,,,,
"637",":User","","","","","joylix","","","","","","User","","false","16125604","",,,,,
"638",":Question","77053626","3","I have created a graph in neo4j community edition running in a docker container in my local using below cypher.

    create (a:Account{name:&#39;account.a&#39;}),
    (b:Account{name:&#39;account.b&#39;}),
    (c:Account{name:&#39;account.c&#39;}),
    (d:Account{name:&#39;account.d&#39;}),
    (e:Account{name:&#39;account.e&#39;}),
    (f:Account{name:&#39;account.f&#39;}),
    (x:Account{name:&#39;account.x&#39;}),
    (y:Account{name:&#39;account.y&#39;}),
    (cas:Calculation{name:&#39;account.a:simple_interest&#39;}),
    (cac:Calculation{name:&#39;account.a:compound_interest&#39;}),
    (cbs:Calculation{name:&#39;account.b:simple_interest&#39;}),
    (cbc:Calculation{name:&#39;account.b:compound_interest&#39;}),
    (cxs:Calculation{name:&#39;account.x:simple_interest&#39;}),
    (cxc:Calculation{name:&#39;account.x:compound_interest&#39;}),
    (a)-[:RESULTS_FROM]-&gt;(cas),
    (a)-[:RESULTS_FROM]-&gt;(cac),
    (b)-[:RESULTS_FROM]-&gt;(cbs),
    (b)-[:RESULTS_FROM]-&gt;(cbc),
    (x)-[:RESULTS_FROM]-&gt;(cxs),
    (x)-[:RESULTS_FROM]-&gt;(cxc),
    (cas)-[:DEPENDS_ON]-&gt;(d),
    (cas)-[:DEPENDS_ON]-&gt;(e),
    (cbs)-[:DEPENDS_ON]-&gt;(c),
    (cbc)-[:DEPENDS_ON]-&gt;(y),
    (cac)-[:DEPENDS_ON]-&gt;(f),
    (cac)-[:DEPENDS_ON]-&gt;(d),
    (cxs)-[:DEPENDS_ON]-&gt;(d),
    (cxc)-[:DEPENDS_ON]-&gt;(d)

There are two kinds of nodes in the graph - **Account** and **Calculation**.
**Account** node has a &quot;RESULTS_FROM&quot; relation to **Calculation** node with the same name + interest type. A **Calculation** node has a &quot;DEPENDS_ON&quot; relation with &#39;n&#39; number of other **Account** nodes.

Below is how the graph looks like.

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/rtlY4.png

I need to write a cypher which starts at an Account node and finds all it&#39;s dependencies in the entire graph. A dependency in this context is the Calculation node(s) it &quot;RESULTS_FROM&quot; and the Account nodes that those Calculation node(s) &quot;DEPENDS_ON&quot;. It should do this recursively in all direction until it finds an Account node which doesn&#39;t have any &quot;RESULTS_FROM&quot; relation to any other Calculation nodes.

In the snapshot, if I start at &quot;account.b&quot;, it will follow both &quot;RESULTS_FROM&quot; relation (via blue Calculation nodes) which then point to &quot;account.y&quot; and &quot;account.c&quot; via &quot;DEPENDS_ON&quot;.

So the output should be - account.y and account.c

Similarly, the output for &quot;account.x&quot; should be &quot;account.d&quot;. We stop when any Account doesn&#39;t &quot;RESULT_FROM&quot; any Calculation.

I tried different things like below but I am not sure what&#39;s the ideal way to do this.

    MATCH (startNode:YourLabel {name: &#39;account.a&#39;})
    CALL {
      WITH [startNode] AS nodes, [] AS rels
      UNWIND nodes AS node
      FOREACH(ignoreMe IN [1] |
        MATCH (node)-[r]-&gt;(relatedNode)
        WHERE NOT relatedNode IN nodes
        SET nodes = nodes + relatedNode
        SET rels = rels + r
      )
    }
    RETURN DISTINCT nodes AS reachableNodes

ps- the data here is just a sample and in reality, the graph will have 100s of Account and Calculation nodes. The Relations between the nodes remain the same though. And no Calculation node will depend on a Account node with the same name + interest_type","1694013093","","","","https://stackoverflow.com/q/77053234","","","Question","How to write a cypher query which recursively traverses a graph in Neo4j to find all the nodes visited","false","77053234","74",,,,,
"639",":User","","","","","Naxi","","","","","","User","","false","2092445","",,,,,
"640",":Question","77053916","1","    create (bird:Class {name:&#39;bird&#39;})-[:isSubClassOf]-&gt;(animal:Class {name:&#39;animal&#39;})
    create (animal)-[:hasOrgan {condition:&#39;Exists (({x})-[:isInstanceOf]-&gt;(bird))&#39;}]-&gt;(wing:organ {name:&#39;wing&#39;})
    create (x:bird:instance {name:&#39;pigeon_1&#39;})-[:isInstanceOf]-&gt;(bird)

How to create a query to read the value of the condition expression and decide whether to create (pigeon_1)-[:hasOrgan]-&gt;(:wing) based on its value
MATCH (bird:Class {name:&#39;bird&#39;})-[:isSubClassOf]-&gt;(animal:Class {name:&#39;animal&#39;})

I created the following query but got an error, how should I fix it?

    MATCH (animal)-[hasOrgan:hasOrgan]-&gt;(wing:organ)
    WHERE hasOrgan.condition IS NOT NULL
    WITH x, hasOrgan, wing, hasOrgan.condition AS condition
    CALL apoc.cypher.doIt(&#39;RETURN &#39; + condition + &#39; AS value&#39;, {x: x, wing: wing})
    YIELD value
    WITH x, hasOrgan, wing, value AS conditionValue
    WHERE conditionValue
    CREATE (x)-[:hasOrgan]-&gt;(wing)","1693992225","","","","https://stackoverflow.com/q/77050646","","","Question","How to store a condition as a string in node property or relationship property and use it in a query?","false","77050646","43",,,,,
"641",":Question","77046822","2","I&#39;m using NeoDash, and I want to generate a graph report where each node size is weighted by the number of neighbors.

So this count must become a property of the node to be analyzed by NeoDash properly.

Now, after 4 hours, I finally succeeded with the following query, but I&#39;m pretty sure there should be a more elegant and concise way to do the same, right?

```
  MATCH path=(n)-[r]-&gt;(c) //n is already from a subset, and here we exclude _events
    WHERE NOT c:_event

WITH collect(distinct n) as listN, collect(distinct c) as listC
  UNWIND listN as n
    MATCH (n)-[r]-&gt;(c) WHERE c in listC

WITH listN, listC, n, count(c) as countC
  SET n.counter=countC

WITH collect(n) as listN, listC
  UNWIND listC as c
    MATCH (n)-[r]-&gt;(c) WHERE n in listN

WITH c, count(n) as countN, listN
  SET c.counter=countN

WITH collect(c) as listC, listN
  MATCH (n)-[r]-&gt;(c)
    WHERE n in listN 
      and c in listC

RETURN n,r,c
```

or is there an apoc shortcut for that?
","1693920338","","","","https://stackoverflow.com/q/77044901","","","Question","Concise way to Add virtual property with neighbour count to each result node in Cypher","false","77044901","61",,,,,
"642",":User","","","","","Myoch","","","","","","User","","false","2231299","",,,,,
"643",":Question","77042079","1","In my DB, my connections between item nodes are done through a three-way node-connection, like the one highlighted below. I chose it this way because I don&#39;t think there&#39;s a way to do a three-way arrow or relationship.

[![example graph][1]][1]

Anyways, I don&#39;t think this modeling is a problem in itself. But I would like to query this graph in a way that I ditch the `CONNECTED_BY` relationship and collapse the connection path (e.g. the higlighted node in the picture) down to a simple relationship. How do I do it with Cypher in Neo4j?

I know there&#39;s the [`apoc.refactor.collapseNode` procedure](https://neo4j.com/labs/apoc/4.4/graph-updates/graph-refactoring/collapse-node-to-relationship/), but, as far as I know, it actually mutates the database? Is there a way to use solely as a query? Not to mention that, in my case, I would have to omit the other relationships on the collapsed node somehow.

Here&#39;s an example of how to reproduce what I have:

```cypher
// Users

// #1
CREATE (:User{name: &quot;philippe_fanaro&quot;});
CREATE (:User{name: &quot;john_doe&quot;});

// Items

// #1
MATCH  (u:User{name: &quot;john_doe&quot;})
CREATE (u)-[:CREATED]-&gt;(:Item{title: &quot;Designing Data-Intensive Applications&quot;});

// #2
MATCH  (u:User{name: &quot;philippe_fanaro&quot;})
CREATE (u)-[:CREATED]-&gt;(:Item{title: &quot;System Design Interview – An insider&#39;s guide&quot;});

// Connections

// #1
MATCH  (i1:Item), (i2:Item), (u:User{name: &quot;philippe_fanaro&quot;})
WHERE  i1.title CONTAINS &quot;Designing&quot;
  AND  i2.title CONTAINS &quot;System&quot;
CREATE (i1)- [:CONNECTION_ORIGIN]
           -&gt;(c:Connection{title: &quot;Relation&quot;})
           - [:CONNECTION_DESTINATION]-&gt;(i2),
       (c)-[:CONNECTED_BY]-&gt;(u);
```


  [1]: https://i.stack.imgur.com/DSVuv.png
","1693862940","","","","https://stackoverflow.com/q/77040693","","","Question","Query for Collapsing Node in Path with Multiple Relationships","false","77040693","99",,,,,
"644",":Question","","1","I have code that successfully does the following:

	MATCH (c:Companies) WHERE c.CompanyID = &quot;1234&quot; SET c.Contacts = [&#39;{&quot;Name&quot;:&quot;Test&quot;,&quot;Email&quot;:&quot;t1@test.com&quot;,&quot;Main&quot;:&quot;0&quot;}&#39;,&#39;{&quot;Name&quot;:&quot;Test 2&quot;,&quot;Email&quot;:&quot;t2@test.com&quot;}&#39;]

This works perfectly fine. My concern however is over how can I secure the values of the Array from being hacked/injected?

The typical response would be to use parameters such as:

	MATCH (c:Companies) WHERE c.CompanyID = &quot;1234&quot; SET c.Contacts = [&#39;$Element1&#39;,&#39;$Element2&#39;]

However this would only replace the values with the JSON I&#39;ve already received from the user. Is there any way *apart from* sanitising the input myself to secure this through Neo4j? Would sub-parameters be possible::

	MATCH (c:Companies) WHERE c.CompanyID = &quot;1234&quot; SET c.Contacts = [&#39;$Element1&#39;,&#39;$Element2&#39;]
	&#39;Element1&#39;	=&gt; &#39;{&quot;Name&quot;:&quot;$Name1&quot;,&quot;Email&quot;:&quot;$Email1&quot;,&quot;Main&quot;:&quot;0/1&quot;}&#39;

I just want to make sure I&#39;m on the right track and secure.

","1693566269","","","","https://stackoverflow.com/q/77022572","","","Question","Security of JSON in Neo4j array property","false","77022572","35",,,,,
"645",":Question","","1","The scenario is to get the sum of values of the nodes matched using multiple optional matches and then the value is selected based on the matching case

    MATCH (a:Type1 {id: &#39;1234&#39;})-[:REL_W]-&gt;(parentNode:Type2)
    OPTIONAL MATCH (parentNode)&lt;-[:REL_P]-(:Type2:Type3)-[:REL_W]-&gt;(qnode:Type1)
    WITH qnode AS qwt
    OPTIONAL MATCH (parentNode)&lt;-[:REL_P]-(:Type2:Type4)-[:REL_I]-(:Type2)&lt;-[:REL_W]-(lnode:Type1)
    WITH qwt, lnode AS lwt
    WITH qwt, lwt,
         CASE
             WHEN qwt IS NOT NULL AND &#39;Static&#39; IN labels(qwt)
             THEN toFloat(qwt.value)
             WHEN lwt IS NOT NULL AND &#39;Static&#39; IN labels(lwt)
             THEN toFloat(lwt.value)
             ELSE 0
         END AS childWeight
    RETURN sum(childWeight) AS weight;

The problem with this code is always the second CASE is not executed. The optional match is retuning qwt and lwt nodes and then data is also correct. If we make the &#39;lwt&#39; case the first one then it is executing but &#39;qwt&#39; case will not execute. 

","1693397417","","","","https://stackoverflow.com/q/77007909","","","Question","Neo4j Cypher query Optional match with multiple CASE WHEN THEN","false","77007909","78",,,,,
"646",":User","","","","","Nithin A","","","","","","User","","false","4985560","",,,,,
"647",":Question","","0","I&#39;m trying to migrate from Neo4j `5.5.0` to `5.11.0` (also tried 5.10.0)

The following query works fine on Neo4j `5.5.0`:

    MATCH  ( childD:Vacancy )  WITH collect({`childD`: childD}) as childDDgRdgd  
    CALL apoc.cypher.mapParallel2(&quot; WITH _.childD as childD 
    WHERE  ( coalesce(size(childD.employmentIds), 0) &lt;= 0  
    OR  exists { MATCH (childD)-[:EMPLOYMENT_AS]-(req0:Requirable) 
    WHERE req0.id IN $reqParam0}  )  AND  ( coalesce(size(childD.locationIds), 0) &lt;= 0  
    OR  exists { MATCH (childD)-[:LOCATED_IN]-(req1:Requirable) 
    WHERE req1.id IN $reqParam1}  )  AND  (childD.`status` = $status5)  
    AND  (childD.`active` = $active4)  AND ( (childD.`hourlyRateUsd` &gt;= $hourlyRateUsd2)  
    OR  (childD.`salaryUsd` &gt;= $salaryUsd3) ) 
    WITH childD RETURN childD  &quot;, {`reqParam1`:[6, 7], `reqParam0`:[26], `active4`:true, `salaryUsd3`:13088, `hourlyRateUsd2`:96, `status5`:&#39;APPROVED&#39;}, childDDgRdgd, 6, 100) YIELD value as value   
    WITH value.childD as childD  
    return childD

But fails on Neo4j `5.11.0` with:

    Failed to invoke procedure `apoc.cypher.mapParallel2`: Caused by: java.lang.RuntimeException: Error polling, timeout of 10 seconds reached.

I also tried to extend the timeout to 100, but with the same result.

Has anything changed between Neo4j `5.5.0` and Neo4j `5.11.0`? Maybe some additional configurations are required or something like that?

For my tests, I&#39;m running Neo4j in Docker with:                           

&lt;NEO4J_db_memory_transaction_total_max&gt;0&lt;/NEO4J_db_memory_transaction_total_max&gt;                               &lt;NEO4J_server_memory_pagecache_size&gt;2G&lt;/NEO4J_server_memory_pagecache_size&gt;                                 &lt;NEO4J_server_memory_heap_initial__size&gt;5G&lt;/NEO4J_server_memory_heap_initial__size&gt;                                     &lt;NEO4J_server_memory_heap_max__size&gt;5G&lt;/NEO4J_server_memory_heap_max__size&gt;

Please help, thanks!","1693056641","","","","https://stackoverflow.com/q/76983191","","","Question","Neo4j migration from 5.5.0 to 5.11.0 - Failed to invoke procedure `apoc.cypher.mapParallel2`: Caused by:RuntimeException: Error polling, timeout","false","76983191","52",,,,,
"648",":Question","76980193","1","**Case:**

I&#39;ve nodes `Categories` that looks like below and i created a relation from category to parent.

```cypher
CREATE(p1:Categorie {
  id: 2,
  parent_id: 1,
  name: &quot;Kids&quot;,
  is_active: true ,
  position: 1,
  level: 1,
})
CREATE(c1:Categorie {
  id: 5,
  parent_id: 2,
  name: &quot;Toys&quot;,
  is_active: true ,
  position: 1,
  level: 2,
})

//New root category
CREATE(p2:Categorie {
  id: 9,
  parent_id: 1,
  name: &quot;Holiday&quot;,
  is_active: true ,
  position: 1,
  level: 1,
})
CREATE(c2:Categorie {
  id: 12,
  parent_id: 9,
  name: &quot;Water&quot;,
  is_active: true ,
  position: 1,
  level: 2,
})


CREATE(c1)-[:CHILD_OF]-&gt;(p1)
CREATE(c2)-[:CHILD_OF]-&gt;(p2)
```

Then I have products that hase an array of `categorie_ids` like this:

```json
{
    &quot;sku&quot;: &quot;abc&quot;,
    &quot;name&quot;: &quot;Electric boot&quot;,
    &quot;categorie_ids&quot;: [ 
        1,
        5,
        9,
        12
    ]
}
```

The API gives all the ids back that the product is &quot;in&quot;. For me this so much clutter in all the relationships. This example is minimum but in reality this could be up to twenty relations per product.

**Question/Problem:**

I would like to create a relation to the lowest node(s) in the categories. In this case the product has two main categories and thus two bottom categories. So I would like to create a relation to id 12 and 5.

I just can&#39;t wrap my head around the cypher query. Can someone shine some light on this?","1692990537","","","","https://stackoverflow.com/q/76979959","","","Question","Cypher to find (multiple) &quot;lowest&quot; nodes","false","76979959","45",,,,,
"649",":User","","","","","RemcoE33","","","","","","User","","false","13461183","",,,,,
"650",":Question","","0","I&#39;m attempting to upgrade from `Neo4j 5.5.0` to Neo4j `5.10.0`, but currently my tests on this version are failing with the following error:

    org.neo4j.driver.exceptions.DatabaseException: Access to record Node[79841,used=false,created=false,rel=-1,prop=-1,labels=Inline(0x0:[]),light,fixedRefs=false] went out of bounds of the page. The record size is 15 bytes, and the access was at offset 1875 bytes into page 146, and the pages have a capacity of 8192 bytes. The mapped store file in question is /data/databases/neo4j/neostore.nodestore.db
	at org.neo4j.driver.internal.util.Futures.blockingGet(Futures.java:110) ~[neo4j-java-driver-5.11.0.jar:5.11.0-ea56edc8c126b032c4a7dd8c4c571ec35419ca44]
	at org.neo4j.driver.internal.InternalResult.blockingGet(InternalResult.java:111) ~[neo4j-java-driver-5.11.0.jar:5.11.0-ea56edc8c126b032c4a7dd8c4c571ec35419ca44]
	at org.neo4j.driver.internal.InternalResult.list(InternalResult.java:87) ~[neo4j-java-driver-5.11.0.jar:5.11.0-ea56edc8c126b032c4a7dd8c4c571ec35419ca44]
	at org.neo4j.ogm.drivers.bolt.response.RestModelResponse.&lt;init&gt;(RestModelResponse.java:49) ~[neo4j-ogm-bolt-driver-4.0.6.jar:4.0.6]
	at org.neo4j.ogm.drivers.bolt.request.BoltRequest.execute(BoltRequest.java:169) ~[neo4j-ogm-bolt-driver-4.0.6.jar:4.0.6]
	at org.neo4j.ogm.session.delegates.ExecuteQueriesDelegate.lambda$query$0(ExecuteQueriesDelegate.java:147) ~[neo4j-ogm-core-4.0.6.jar:4.0.6]
	at org.neo4j.ogm.session.Neo4jSession.doInTransaction(Neo4jSession.java:600) ~[neo4j-ogm-core-4.0.6.jar:4.0.6]
	at org.neo4j.ogm.session.Neo4jSession.doInTransaction(Neo4jSession.java:574) ~[neo4j-ogm-core-4.0.6.jar:4.0.6]
	at org.neo4j.ogm.session.delegates.ExecuteQueriesDelegate.query(ExecuteQueriesDelegate.java:145) ~[neo4j-ogm-core-4.0.6.jar:4.0.6]
	at org.neo4j.ogm.session.Neo4jSession.query(Neo4jSession.java:445) ~[neo4j-ogm-core-4.0.6.jar:4.0.6]

What may be wrong and how to fix/configure it? On `Neo4j 5.5.0` everything is working fine.

**UPDATED**

Found another issue - I&#39;m using the Neo4j Docker image with the docker-maven-plugin:

    &lt;image&gt;
        &lt;name&gt;neo4j:${neo4j.version}&lt;/name&gt;
        &lt;alias&gt;neo4j&lt;/alias&gt;
        &lt;run&gt;
            &lt;ports&gt;
                &lt;port&gt;${neo4j.http.port}:7474&lt;/port&gt;
                &lt;port&gt;${neo4j.bolt.port}:7687&lt;/port&gt;
            &lt;/ports&gt;
            &lt;volumes&gt;
                &lt;bind&gt;
                    &lt;volume&gt;
                        ${project.basedir}/../docs/graphaware/plugins/${neo4j.version}:/plugins
                    &lt;/volume&gt;
                &lt;/bind&gt;
            &lt;/volumes&gt;
            &lt;env&gt;
                &lt;NEO4J_AUTH&gt;${neo4j.username}/${neo4j.password}&lt;/NEO4J_AUTH&gt;
                &lt;NEO4J_db_memory_transaction_total_max&gt;0&lt;/NEO4J_db_memory_transaction_total_max&gt;
                &lt;NEO4J_server_memory_pagecache_size&gt;2G&lt;/NEO4J_server_memory_pagecache_size&gt;
                &lt;NEO4J_server_memory_heap_initial__size&gt;5G&lt;/NEO4J_server_memory_heap_initial__size&gt;
                &lt;NEO4J_server_memory_heap_max__size&gt;5G&lt;/NEO4J_server_memory_heap_max__size&gt;
    
                &lt;NEO4J_dbms_security_procedures_unrestricted&gt;apoc.*&lt;/NEO4J_dbms_security_procedures_unrestricted&gt;
            &lt;/env&gt;
            &lt;wait&gt;
                &lt;http&gt;
                    &lt;url&gt;http://${docker.host.address}:${neo4j.http.port}/browser&lt;/url&gt;
                &lt;/http&gt;
                &lt;time&gt;1200000&lt;/time&gt;
            &lt;/wait&gt;
        &lt;/run&gt;
    &lt;/image&gt;


When I use Neo4j version `5.5.0`, the following query works fine:

    MATCH  ( childD:Vacancy )  
    WITH collect({`childD`: childD}) as childDDgRdgd  
    CALL apoc.cypher.mapParallel2(&quot; 
    WITH _.childD as childD WHERE  (childD.`active` = $active0)  AND  (childD.`status` = $status1)  
    WITH childD 
    RETURN childD  &quot;, {`status1`:&#39;APPROVED&#39;, `active0`:true}, childDDgRdgd, 6, 10) 
    YIELD value as value   
    WITH value.childD as childD   
    return childD

However, when I switch the Neo4j version to `5.10.0` for the Docker plugin, the query fails with the following exception:

    Failed to invoke procedure `apoc.cypher.mapParallel2`: Caused by: java.lang.RuntimeException: Error polling, timeout of 10 seconds reached.

I also added it to the plugins directory:

    apoc-5.10.0-extended.jar
    apoc-5.10.1-core.jar

What am I doing wrong?
","1692949125","","","","https://stackoverflow.com/q/76975204","","","Question","Neo4j Access to record went out of bounds of the page. Migration Neo4j 5.5.0 to 5.10.0","false","76975204","68",,,,,
"651",":Question","77494339","2","I am using Neo4j 5.9.0 community

**Problem description** :
My graph only has one type of relationship [:Relationship], and one type of node (:Node).
I want to find the shortest path between two nodes, but I do not want the shortest path returned to contain this pattern : **(:Node)&lt;-[:Relationship]-(:Node)-[:Relationship]-&gt;(:Node)**

I have read [here](https://neo4j.com/docs/cypher-manual/current/patterns/concepts/) that
&gt; If the MATCH clause of the shortestPath function includes a WHERE clause, a shortest path that satisfies the WHERE clause conditions is returned if one exists.

so this should be possible, and I have tested without using the shortestPath function that paths that verify this requirement indeed exist in my graph.

**What I have tried:**
I have tested mutliple ways to filter the shortest path returned, but none of them were successful.
I tried using the **exists{}** subquery:

```
match p = shortestPath((startNode:Node {id : 1})-[:Relationship*]-(endNode:Node {id : 2})) 
where none(pathNode in nodes(p) where exists{
match (n1:Node)&lt;-[:Relationship]-(pathNode)-[:Relationship]-&gt;(n2:Node)
where ((n1 in nodes(p)) and (n2 in nodes(p)))
}) 
return p
```
which returns &#39;Unknown expression type during transformation (class org.neo4j.cypher.internal.ir.ast.ExistsIRExpression)&#39;,

as well as using **isEmpty()** predicate function :

```
match p = shortestPath((startNode:Node {id : 1})-[:Relationship*]-(endNode:Node {id : 2}))
where isEmpty ([(n1)&lt;-[:Relationship]-(n2)-[:Relationship]-&gt;(n3) where ((n1 in nodes(p)) and (n2 in nodes(p)) and (n3 in nodes(p))) | n2.id])
return p
```
which returns &#39;Unknown expression type during transformation (class org.neo4j.cypher.internal.ir.ast.ListIRExpression)&#39;

I do not understand why the queries above do not work properly. Any help would be appreciated, thank you.
","1692867799","","","","https://stackoverflow.com/q/76967760","","","Question","How to find the shortest path not containing a pattern?","false","76967760","61",,,,,
"652",":User","","","","","oneStoic","","","","","","User","","false","22439757","",,,,,
"653",":Question","","1","The following query from the [GDS documentation](https://neo4j.com/docs/graph-data-science/current/management-ops/projections/graph-project-cypher-projection/#graph-project-cypher-projection-filtered) shows how to create a GDS projection via Cypher:

```
MATCH (source) OPTIONAL MATCH (source)-[r:READ]-&gt;(target)
WHERE r.numberOfPages IS NOT NULL
WITH gds.graph.project(&#39;existingNumberOfPages&#39;, source, target, { relationshipProperties: r { .numberOfPages } }) AS g
RETURN
  g.graphName AS graph, g.nodeCount AS nodes, g.relationshipCount AS rels
```

This is my code and i want to create a customized projection:

```neo4j
MATCH (n)-[r]-(m) 
WHERE type(r) IN [
    &#39;Environment_related_eQTL&#39;,
    &#39;GO term\&#39;s relationshipbiological_process&#39;,
    &#39;GO term\&#39;s relationshipcellular_component&#39;,
    &#39;GO term\&#39;s relationshipmolecular_function&#39;,
    &#39;Gene and GO\&#39;s biological_process term relationship&#39;,
    &#39;Gene and GO\&#39;s cellular_component term relationship&#39;,
    &#39;Gene and GO\&#39;s molecular_function term relationship&#39;,
    &#39;Genes_regulated_by_methylation&#39;,
    &#39;Phenotypes_affected_by_snp&#39;,
    &#39;SNP_belongTo_Gene&#39;,
    &#39;TF_regulates&#39;,
    &#39;TranseQTL_belongTo_Gene&#39;,
    &#39;TranseQTL_to_gene&#39;,
    &#39;ciseQTL_belongTo_Gene&#39;,
    &#39;ciseQTL_influence_Gene&#39;,
    &#39;environmenteqtl_id_on&#39;,
    &#39;gene_to_TFfamily&#39;,
    &#39;subaloaction&#39;,
    &#39;Gene_Phenotypes_affected_by_Gene_from_twas_araPhenotype&#39;
]
WITH COLLECT(DISTINCT id(n)) + COLLECT(DISTINCT id(m)) AS allNodeIDs
MATCH (source)-[r]-&gt;(target) WHERE  id(source) IN allNodeIDs AND id(target) IN allNodeIDs AND type(r) IN [
    &#39;Environment_related_eQTL&#39;,
    &#39;GO term\&#39;s relationshipbiological_process&#39;,
    &#39;GO term\&#39;s relationshipcellular_component&#39;,
    &#39;GO term\&#39;s relationshipmolecular_function&#39;,
    &#39;Gene and GO\&#39;s biological_process term relationship&#39;,
    &#39;Gene and GO\&#39;s cellular_component term relationship&#39;,
    &#39;Gene and GO\&#39;s molecular_function term relationship&#39;,
    &#39;Genes_regulated_by_methylation&#39;,
    &#39;Phenotypes_affected_by_snp&#39;,
    &#39;SNP_belongTo_Gene&#39;,
    &#39;TF_regulates&#39;,
    &#39;TranseQTL_belongTo_Gene&#39;,
    &#39;TranseQTL_to_gene&#39;,
    &#39;ciseQTL_belongTo_Gene&#39;,
    &#39;ciseQTL_influence_Gene&#39;,
    &#39;environmenteqtl_id_on&#39;,
    &#39;gene_to_TFfamily&#39;,
    &#39;subaloaction&#39;,
    &#39;Gene_Phenotypes_affected_by_Gene_from_twas_araPhenotype&#39;,
    &#39;PPI&#39;,
    &#39;TF_regulates&#39;
]
WITH gds.graph.project(
  &#39;graphdealj&#39;,
  source,
  target,
  {
    sourceNodeLabels: labels(source),
    targetNodeLabels: labels(target),
    relationshipType: type(r)
  }
) AS g
RETURN g.graphName AS graph, g.nodeCount AS nodes, g.relationshipCount AS rels
```

But I get this error:

```
Unknown function &#39;gds.graph.project&#39; (line 47, column 6 (offset: 1700))
&quot;    &#39;TF_regulates&#39;&quot;
                   ^
```




I am absolutely certain that I have installed GDS, as I&#39;m able to successfully execute other methods of projection and various algorithms. Also, the part of the query before the final GDS section executes without any issues:

![](https://i.stack.imgur.com/MEINZ.png)

I tried adding a `call` after `with`, but it didn&#39;t work, but I can guarantee that the code is executed normally before the last `with`. You can see that the picture has output","1692757209","","","","https://stackoverflow.com/q/76957864","","","Question","Neo4j GDS: Cannot use Cypher to make a complex projection","false","76957864","89",,,,,
"654",":User","","","","","熊湘毅","","","","","","User","","false","22432309","",,,,,
"655",":Question","76952360","2","I have a problem with the execution of the following code:

    public static void create(final Session session, final String nodeName, final Map&lt;String, List&lt;Object&gt;&gt; attributes) {
            final String create = getCreate(nodeName, attributes);
            Logger.getLogger(&quot;Neo4jCommands&quot;).log(Level.FINE, &quot;Creating node &quot; + nodeName);
            try {
                session.executeWriteWithoutResult(tx -&gt; {
                    var query = new Query(create);
                    tx.run(query);
                }, TransactionConfig.builder().withTimeout(Duration.of(30, ChronoUnit.SECONDS)).build());
            } catch (final Exception e) {
                if (create.length() &gt; 3000) {
                    Logger.getLogger(&quot;Neo4jCommands&quot;).log(Level.SEVERE, &quot;Failed create: &quot; + create.substring(0, 3000));
                    ;
                } else {
                    Logger.getLogger(&quot;Neo4jCommands&quot;).log(Level.SEVERE, &quot;Failed create: &quot; + create);
                }
                throw new RuntimeException(e);
            } finally {
                session.close();
            }
        }

The following cypher query runs endless:

    UNWIND [6432013617038820698, 6432013617038820698, 6432013617038820698, 6432013617038820698, 6432013617038820698, 6432013617038820698, 6432013617038820698, 6432013617038820698, 6432013617038820698, 6432013617038820698, 6432013617038820698, 6432013617038820698, 6432013617038820698] AS A
    UNWIND [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13] AS B
    UNWIND [&#39;1000000&#39;, &#39;1000000&#39;, &#39;1000000&#39;, &#39;1000000&#39;, &#39;1000000&#39;, &#39;1000000&#39;, &#39;1000000&#39;, &#39;1000000&#39;, &#39;1000000&#39;, &#39;1000000&#39;, &#39;1000000&#39;, &#39;1000000&#39;, &#39;1000000&#39;] AS C
    UNWIND [&#39;Attribute101&#39;, &#39;Attribute102&#39;, &#39;Attribute103&#39;, &#39;Attribute104&#39;, &#39;Attribute105&#39;, &#39;Attribute106&#39;, &#39;Attribute107&#39;, &#39;Attribute108&#39;, &#39;Attribute109&#39;, &#39;Attribute110&#39;, &#39;Attribute111&#39;, &#39;Attribute112&#39;, &#39;Attribute113&#39;] AS D
    UNWIND [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4] AS E
    UNWIND [&#39;1000161&#39;, &#39;1000162Text&#39;, &#39;1000163&#39;, &#39;1000164Text&#39;, &#39;1000165&#39;, &#39;1000166Text&#39;, &#39;1000167&#39;, &#39;1000168Text&#39;, &#39;1000169&#39;, &#39;1000170Text&#39;, &#39;1000171&#39;, &#39;1000172Text&#39;, &#39;1000173&#39;] AS F
    UNWIND [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] AS G
    CREATE (:CT11000000 {VA: A, VB: B, VC: C, VD: D, VE: E, VF: F, VG: G})

Thank you for help!","1692697773","","","","https://stackoverflow.com/q/76952071","","","Question","NEO4J UNWIND CREATE runs endless","false","76952071","37",,,,,
"656",":User","","","","","BeatEngine","","","","","","User","","false","10570318","",,,,,
"657",":Question","76948661","1","I need to add to my Cypher query&#39;s return statement the following  Pattern comprehension:

    [ (rc:Criterion) WHERE rc.id IN childD.replaceableCriterionIds | {entity: rc} ] AS decisionReplaceableCriteria

but it fails with the following exception:

    Caused by: org.neo4j.driver.exceptions.ClientException: Invalid input &#39;WHERE&#39;: expected &quot;-&quot;, &quot;&lt;&quot;, &lt;ARROW_LEFT_HEAD&gt; or &lt;ARROW_LINE&gt; 

It only works when I&#39;m adding the redundant relationship with another node

    [ (rc:Criterion)-[:CREATED_BY]-&gt;(:User) WHERE rc.id IN childD.replaceableCriterionIds | {entity: rc} ] AS decisionReplaceableCriteria

The following part is absolutely redundant for my needs:

    -[:CREATED_BY]-&gt;(:User)

Is it possible to rewrite my pattern comprehension to avoid such redundant syntax?","1692649787","","","","https://stackoverflow.com/q/76948545","","","Question","Neo4j Cypher Pattern comprehension in return statement","false","76948545","39",,,,,
"658",":Question","76947841","1","I have the following Cypher query:

    UNWIND childD.detailedCriterionIds as dCId
    WITH childD, childDStat, dCId + coalesce(childDStat[&#39;replaceableCriterionIds.&#39; + dCId],[]) as cGroup
    WITH childD, childDStat, cGroup
    WHERE NOT AlL(x IN cGroup WHERE x IN $zeroCriterionIds )
    WITH childD, childDStat, collect(cGroup) as cGroups
    WHERE size(cGroups) &gt;= size(childD.detailedCriterionIds)
    
    WITH childD, childDStat, cGroups
    UNWIND cGroups as cGroup
    WITH childD, childDStat, cGroup
    WHERE ANY(x IN cGroup WHERE x IN $detailedCriterionIds)
    WITH childD, childDStat, collect(cGroup) as cGroups
    WHERE size(cGroups) &gt; 0

As you can see, I use 2 UNWINDs there. Is it possible to optimize this query to avoid the second UNWIND? If so, could you please show how?

I tried the following, but it produced a different result:

    UNWIND childD.detailedCriterionIds as dCId
    WITH childD, childDStat, dCId + coalesce(childDStat[&#39;replaceableCriterionIds.&#39; + dCId],[]) as cGroup
    WITH childD, childDStat, cGroup
    WHERE NOT AlL(x IN cGroup WHERE x IN $zeroCriterionIds )
    AND ANY(x IN cGroup WHERE x IN $detailedCriterionIds)
    WITH childD, childDStat, collect(cGroup) as cGroups
    WHERE size(cGroups) &gt; 0

Where is my mistake?","1692575912","","","","https://stackoverflow.com/q/76941753","","","Question","Neo4j Cypher reduce UNWINDs calls","false","76941753","63",,,,,
"659",":Question","76947709","2","Question:

I&#39;m working on a Neo4j Cypher query that aims to update or create relationships between a store and articles. The goal is to update an existing relationship if its date is older than a new date, and if the relationship does not exist, create a new TempArticle node and establish a relationship. However, the code I&#39;ve written doesn&#39;t seem to be working as expected.

        :param { store_id: 22, article_name: &quot;Candy shop&quot;, new_date: &quot;2023-12-14&quot;, new_price: 32, article_description: &quot;&quot; };
    
    MERGE (s:Store {store_id: $store_id, name: &quot;STORE DEMO NAME&quot;}); // testing store
    
    MATCH (store:Store {store_id: $store_id})
    OPTIONAL MATCH (store)-[rel:HAS_ARTICLE {article_name: $article_name}]-&gt;(article)
    WITH store, rel, article,
         CASE
             WHEN rel IS NOT NULL AND rel.date &lt; date($new_date) THEN true
             ELSE false
         END AS shouldUpdateRel,
         CASE
             WHEN rel IS NULL THEN true
             ELSE false
         END AS shouldCreateTempArticle
    WITH store, rel, article, shouldUpdateRel, shouldCreateTempArticle
    WHERE shouldUpdateRel
    SET rel.date = date($new_date)
    SET rel.prev_price = rel.price
    SET rel.price = $new_price 
    SET rel.article_name =  $article_name
    
    WITH store, article, shouldCreateTempArticle
    WHERE shouldCreateTempArticle
    CREATE (tempArticle:TempArticle {article_name: $article_name, article_description: $article_description})
    MERGE (store)-[newRel:HAS_ARTICLE]-&gt;(tempArticle)
    SET newRel.date = date($new_date)
    SET newRel.price = $new_price
    SET newRel.article_name =  $article_name
    RETURN store, article, shouldCreateTempArticle

Problem:

The code is expected to update existing relationships and create a TempArticle node with a new relationship when necessary. However, I&#39;ve noticed that while the relationship update part seems to work correctly, the TempArticle creation part doesn&#39;t behave as expected. Despite the logic suggesting that it should create a TempArticle when shouldCreateTempArticle is true, it doesn&#39;t.

Expected Outcome:

When shouldCreateTempArticle is true, a new TempArticle node should be created along with a relationship to the store.

Current Outcome:
Despite the logic and conditions being set, the TempArticle node is not being created as expected.

I would appreciate any insights or suggestions on what might be causing this issue and how to resolve it. Thank you in advance for your assistance!","1692482978","","","","https://stackoverflow.com/q/76937217","","","Question","Issue Creating TempArticle in Neo4j Cypher Query","false","76937217","47",,,,,
"660",":User","","","","","Learn on hard way","","","","","","User","","false","7249598","",,,,,
"661",":Question","76930320","1","I was going through docs and a 2-month-old youtube video on neo4j for beginners. 
I want to find a user from the database using his name. So here are two way of doing this:

Docs way: `MATCH (u:USER {name:&quot;abcd&quot;}) RETURN u`.

Youtube video way: `MATCH (u:USER} WHERE u.name = &quot;abcd&quot; RETURN u`

Both ways do the job but I am confused about which one to use when or not. May anyone tell me when to use which one and what the fundamental difference is in them? Are both methods safe to use?","1692368824","","","","https://stackoverflow.com/q/76930230","","","Question","When to use WHERE in Cypher Neo4j?","false","76930230","35",,,,,
"662",":User","","","","","Rishabh Raghwendra","","","","","","User","","false","12051334","",,,,,
"663",":Question","76930122","1","Given a node with several types of outbound edges, let&#39;s say of types `[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]`, how would I use cypher to query a neo4j database to return the counts of every edge. 

E.g. if I have a graph like 

    (n0:NODE) -[:A]- (n1:NODE)
    (n0:NODE) -[:A]- (n2:NODE)
    (n0:NODE) -[:B]- (n3:NODE)
    (n1:NODE) -[:B]- (n2:NODE)
    (n4:NODE) // No edges

Assuming these edges are all bidirectional, I would want the query to return  

    Node, count(A), count(B), count(C) 
    n0,   2,        1,        0
    n1,   1,        1,        0
    n2,   1,        1,        0
    n3,   0,        1,        0 
    n4,   0,        0,        0

For all nodes with label `NODE`. 

I&#39;m using this right now, which is okay, but it puts all the different edge types on different rows, so I have to iterate through all of them in post processing to build out the table that I want: 

    MATCH (n:NODE) -[r]- ()
    WHERE 
        type(r) in [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
    RETURN 
        id(n) as nid,
        type(r) as rtype, 
        count(r) as cnt

Is there a way to get these all in one row like in my example?","1692366289","","","","https://stackoverflow.com/q/76929932","","","Question","Return a count of every edge type leaving a node in neo4j","false","76929932","43",,,,,
"664",":User","","","","","Zaya","","","","","","User","","false","6136888","",,,,,
"665",":Question","","1","
    LOAD CSV WITH HEADERS FROM &quot;file:///‪C:/Users/SESA472806/Desktop/CustomerTagDB_IOAssgiment_M91_with_IO_Allocation_LAST_4.csv&quot; as line
    with line, line.`Plant Name` as plnt

    Call{    
         with line, plnt
         merge(p:Plant{Name : plnt})
         SET p.validCount =&#39;null&#39;, p.projectName = &#39;Null&#39;, p.projectId = &#39;Null&#39;, p.progress =&#39;Null&#39;, p.modelValidCount = &#39;Null&#39;,     p.modelinstabceCount = &#39;Null&#39;, p.modelBadCount = &#39;Null&#39;, p.isPropagated = &#39;Null&#39; , p.isCustomerLoaded = &#39;Null&#39;, p.isControlLoaded = &#39;Null&#39;, p.instanceCount = &#39;Null&#39;, p.CutomerDbPath = &#39;Null&#39;, p.ControlDbPath = &#39;Null&#39;, p.badCount = &#39;Null&#39;, p.AmlPath = &#39;Null&#39; , p.allProjectPath = &#39;Null&#39;
         return p
    }
    return p


#### ERROR


    Illegal char &lt;:&gt; at index 3: /‪C:/Users/SESA472806/Desktop/CustomerTagDB_IOAssgiment_M91_with_IO_Allocation_LAST_4.csv ? What is the error in neo4j


I don&#39;t understand the error. I have used the same code before.
","1692340044","","","","https://stackoverflow.com/q/76926899","","","Question","What causes Neo4j error: Illegal char &lt;:&gt; at index 3","false","76926899","56",,,,,
"666",":Question","76923616","2","I want to calculate percentage of how much each type of skill is present for each occupation. 
I made a have different nodes occupation and Soft_skills they have an relationship [r:MAPS_TO] the relationship has two property type(&#39;essentieel&#39;, &#39;optioneel&#39;)and b (this kind of weight essentieel =1.0 and optioneel =0.5)

see below een example of the file that i&#39;m using 

|occupation|code_occupation|skill_code|name |type    |b
|----------|----------------|---------|---- |--------|---
|dokter    | sk_565         |sk_687   |leren|optioneel|0.5
|dokter    | sk_565         |sk_687   |leren|optioneel|0.5
|dokter    | sk_565         |sk_687   |leren|essentieel|1.0
|dokter    | sk_565         |sk_687   |leren|essentieel|1.0


i made a query where i can calculate what the sum is for each occupation see below my query:

```
match (b:BOC_beroep)-[r:MAPS_TO]-(s:Soft_Skill)                                                     
return b.beroepstitel as beroep,                             
sum(toFloat(r.b)) as sum order by sum desc                         
limit 10
```
this is my output 

|beroep|sum
|------|----
|Doker | 5
|Kapper| 7

know i want to achieve what the percentage is of the type of skill my calculation will be 
```
Dokter have in total 4 skills en the percentage of each skill is 
2/4 * 100 = 50% essentieel 
1/4 * 100 = 25% optioneel 

i was trying to make a new calculation with this query:

  MATCH (b:BOC_beroep)-[r:MAPS_TO]-&gt;(s:Soft_skill)
  WITH SUM(toFloat(r.b)) As total
  MATCH (b:BOC_beroep)-[r:MAPS_TO]-&gt;(s:Soft_Skill)
  RETURN b.beroepstitel  AS beroep, 
  (toFloat(total/(r.b)))*100 AS percent
  order by percent desc
```

My output is Cannot divide &#39;Long&#39; by &#39;string&#39;
I don&#39;t understand the erorr 


i was inspired by this question and answer
Here&#39;s an inline link to [stackoverflow](https://stackoverflow.com/questions/37902749/how-to-group-by-and-calculate-percentage-using-cypher-queries-in-neo4j).


","1692276702","","","","https://stackoverflow.com/q/76921714","","","Question","calculation of percentage from a column is table neo4j/Cypher","false","76921714","76",,,,,
"667",":User","","","","","Leyla Elkhamlichi","","","","","","User","","false","11359133","",,,,,
"668",":Question","76913801","3","When I run this query:
```
MATCH (n:test) with n limit 100
WITH DISTINCT n, keys(n) AS allKeys
UNWIND allKeys AS key
with n, 
    CASE
        WHEN key STARTS WITH &#39;prop.title&#39; THEN {column: &#39;title&#39;, value: collect(n[key])}
        WHEN key STARTS WITH &#39;prop.keywords&#39; THEN {column: &#39;keywords&#39;, value: collect(n[key])}
    END AS data
with n, data, collect(data.value) as values
RETURN n.id, apoc.map.fromPairs(COLLECT([data.column, values]))
```
This query purpose is to find all the property with given prefix and group their value into an object with apoc. An example result would be like so: [![Correct result][1]][1]

My issue start when Cypher give me this warning: `This feature is deprecated and will be removed in future versions.` with status code `Neo.ClientNotification.Statement.FeatureDeprecationWarning`
[![This is the warning that I get when running the previous query][2]][2]
Then I try to fix the query by adding the `key` to the `WITH` keyword, like so: `WITH n, key, CASE ...`
But now the value in my object (`collect(n[key])`) does not return all of the value anymore and only the last one. I guess the rest have been overrides. [![Wrong result][3]][3]

Does anyone knows how to fix this but still remove the warning?

EDIT: I found out that by changing `n` to `*` in the first query without the `key` added, I get the same wrong result. Also add pictures.


  [1]: https://i.stack.imgur.com/ffCF3.png
  [2]: https://i.stack.imgur.com/IvsrR.png
  [3]: https://i.stack.imgur.com/yhPPA.png","1692161500","","","","https://stackoverflow.com/q/76910603","","","Question","Cypher query warning give inconsistent result when fix","false","76910603","162",,,,,
"669",":User","","","","","Thinh Tran","","","","","","User","","false","11399551","",,,,,
"670",":Question","","2","My Query should create a Connection from A to B if this doesn&#39;t lead to a cycle. This means I can&#39;t connect A to B if there is already a connection from B to A.

I have following query:

```

1   MATCH (a:User) WHERE ID(a) = 0 
2   MATCH (b:User) WHERE ID(b) = 1
3   WITH a, b, NOT EXISTS{(b)-[*]-&gt;(a)} as A
4   WHERE A
5   MERGE (a)-[:has_connection]-&gt;(:Connection)-[:supports]-&gt;(b);
6   RETURN 
7   CASE A
8       WHEN TRUE THEN &#39;success&#39;
9       ELSE &#39;error&#39;
10  END 
```

1, 2 -\&gt; I just find 2 nodes and name them a and b  
3 -\&gt; I want to check if there is no connection from b to a and save the result in the variable A  
4,5 -\&gt; if A is true I want to create a connection from a to b  
6 - 10 -\&gt; I return a debug string by the condition A

I thought this syntax is correct but I am getting following error:

```
Neo.ClientError.Statement.SyntaxError: Variable `A` not defined (line 2, column 10 (offset: 18))
&quot;    CASE A&quot;
          ^
```

I must have misunderstand scopes in Cypher.

Can someone explain me what I am doing wrong?

I am expecting to get the result &quot;success&quot; if there was no connection from b to a and if there was a connection I want to get the result &quot;error&quot;.","1691876010","","","","https://stackoverflow.com/q/76891207","","","Question","Cypher, Reusing information, with EXISTS{} as varname and then use varname, fails","false","76891207","36",,,,,
"671",":User","","","","","Shooper","","","","","","User","","false","19900735","",,,,,
"672",":Question","","1","I have the following Neo4j Cypher query which is hopefully fairly obvious:

    MATCH (n:Companies) WHERE CompanyID = $CompanyID 
    MERGE (c:Countries {CountryISOCode:$CountryID}) RETURN c 
    MERGE (n)-[r:MasterLink {Type:$Link}]-&gt;(c)

I have already created `n:Companies` so watch to match that, create a Country and then tie the two together. What am I doing wrong? (All parameters are provided)","1691783892","","","","https://stackoverflow.com/q/76886401","","","Question","Neo4j match and 2 merges","false","76886401","38",,,,,
"673",":Question","76858359","1","I am learning neo4j right now and understood/created the relationships between the nodes. I am trying to understand the quantifying path patterns. It seems like I was able to write the general queries to figure out the relationships between the nodes.

Consider this snapshot for the discussion:

[![enter image description here](https://i.stack.imgur.com/Vw5XT.png)](https://i.stack.imgur.com/Vw5XT.png)


&#39;Purple&#39; are the Person nodes and &#39;red&#39; nodes are the Marriage nodes. I wrote this path pattern to get me all the relationship paths:

    match ((p:Person)&lt;-[:IS_MAN_OF]-(m:Marriage)-[:IS_SON_OF]-&gt;(p1:Person)){1,} return p, p1

This returns me all the combinations at all the **levels** like

    Atma Ram - Tek Chand
    Atma Ram - Mukesh
    Tek Chand - Hemant
    Tek Chand - Rocky
    Mukesh - Dimpy

Alright. This make complete sense to me.

What does not make sense is that If I add an where clause in my quantifying pattern, it **does not give me nodes at more than 1 level.** This is the patterns I used along with where.

     match ((p:Person where p.name = &#39;Atma ram&#39;)&lt;-[:IS_MAN_OF]-(m:Marriage)-[:IS_SON_OF]-&gt;(p1:Person)){1,} return p, p1

I am curios to know the reason as to why does it not work for all levels. Also, what shall I write to get all the nodes at all levels even for an where clause.

Thank you.

Tried giving different combinations of min &amp; max in the curly braces.","1691479420","","","","https://stackoverflow.com/q/76857284","","","Question","Quantifying path patterns","false","76857284","222",,,,,
"674",":User","","","","","Hemant Bhargava","","","","","","User","","false","2037570","",,,,,
"675",":Question","76854610","1","in my database I have multiple nodes that have the same properties, so I want to merge all of these nodes into one. Those nodes are connected by the relationship &quot;similar&quot;, so I use gds weakly connected component to find these communities:

    CALL gds.graph.project(&quot;similar_officer&quot;,[&quot;Officer&quot;],[&quot;similar&quot;])

    CALL gds.wcc.write(&#39;similar_officer&#39;, { writeProperty: &#39;community&#39; }) YIELD nodePropertiesWritten, componentCount;

So every node has the new property community which identifies all nodes in a community connected by the relationship &quot;similar&quot;

Here is the problem: I want to iterate the command to merge all nodes into each community into one


I tested with a single community with this code:

    MATCH (a)
    where a.community=235631
    with collect(a) as community
    CALL apoc.refactor.mergeNodes(community,{properties:&quot;discard&quot;, mergeRels:true,preserveExistingSelfRels:false})
    YIELD node
    RETURN count(*)

and it worked in less than a minute and it was the biggest community so I wrote this to iterate for each community:

    call apoc.periodic.iterate(&#39;
        MATCH (n:Officer)
        with n.community as numerocom, collect(n) as nodicom, size(collect(n)) as dimcom
        return numerocom, nodicom
      &#39;,&#39;
        CALL apoc.refactor.mergeNodes(nodicom,{
            properties:&quot;discard&quot;, mergeRels:true, preserveExistingSelfRels:false}) YIELD node
        return node
      &#39;,{batchSize:10000, parallel:True})
    YIELD batches, total
    RETURN batches, total

The result is a never-ending query. I have 13428 communities and the biggest one has 60 nodes.

How can I fix this?","1691417106","","","","https://stackoverflow.com/q/76852512","","","Question","apoc.periodic.iterate never return a result","false","76852512","118",,,,,
"676",":Question","76843130","1","I have a question about how to add elements to an already existing graph in Neo4j.

First, I have created nodes and relationships using the following query:

    CALL apoc.import.csv(
        [{fileName: &quot;file:///accounts.csv&quot;, labels:[&quot;Account&quot;]}],
        [{fileName: &quot;file:///transactions.csv&quot;, type:&quot;transaction&quot;}],
        {ignoreDuplicateNodes: true}
    )

where the contents of `accounts.csv` and `transactions.csv` are as follows:

##### accounts.csv
    acct_id:ID
    &quot;3240&quot;
    &quot;6399&quot;
    &quot;4771&quot;
    &quot;2066&quot;

##### transactions.csv
    id,from_acct:START_ID,to_acct:END_ID,timestamp
    221214,6399,3240,2022-12-15
    221223,4771,3240,2022-12-23
    221229,2066,3240,2022-12-29

So far, I have been able to create graphs without any problems.

Next, I tried to read the data from `add.csv` one row at a time and add nodes and relationships to the graph created by the above query, but I failed. The contents of `add.csv` are as follows:

##### add.csv
    id,from_acct:START_ID,to_acct:END_ID,timestamp
    221243,1000,3240,2023-1-1
    221247,3000,3241,2023-1-2

For `add.csv` data, I only want to create nodes that do not yet exist. All relationships should be created, however.

In other words, in the first line, the node with `acct_id:3240` already exists, so I would like to add only the node with `acct_id:1000` to the graph and create a relationship with the node with `acct_id:3240`. In the second line, the node with `acct_id:3000` and the node with `acct_id:3241` both do not exist, so I would like to add both of them as new nodes and create a relationship with them.
","1691240771","","","","https://stackoverflow.com/q/76841783","","","Question","Adding Elements to an Already Existing Graph in Neo4j","false","76841783","48",,,,,
"677",":Question","","2","I have this nodes and relations, but I have a issue regarding the **from** and **to** node info

  [1]: https://i.stack.imgur.com/CQP43.png

I have this 3 transactions

- from: 111, to: 222 -&gt; amount: $10000
- from: 222, to: 333 -&gt; amount: $2000
- from: 222, to: 444 -&gt; amount: $4000

With this query (not shure if it&#39;s ok) 

	MATCH path = (:Contact {contact_id: &#39;111&#39;})-[t:TRANSACTION*1..3]-()
	With relationships(path) as relations
	unwind relations as u_relations
	With distinct(u_relations) as distinct_relations
	return distinct_relations

I get the info I need, but I can&#39;t figure it out how to add the contact_id from and to of each transaction, the result is

	{

	  &quot;identity&quot;: 0,
	  &quot;start&quot;: 0,
	  &quot;end&quot;: 1,
	  &quot;type&quot;: &quot;TRANSACTION&quot;,
	  &quot;properties&quot;: {
	    &quot;date&quot;: &quot;2023-08-03T17:08:34-03:00&quot;,
	    &quot;amount&quot;: 10000.0
	  },
	  &quot;elementId&quot;: &quot;0&quot;,
	  &quot;startNodeElementId&quot;: &quot;0&quot;,
	  &quot;endNodeElementId&quot;: &quot;1&quot;
	}
	{
	  &quot;identity&quot;: 1,
	  &quot;start&quot;: 1,
	  &quot;end&quot;: 5,
	  &quot;type&quot;: &quot;TRANSACTION&quot;,
	  &quot;properties&quot;: {
	    &quot;date&quot;: &quot;2023-08-03T17:08:34-03:00&quot;,
	    &quot;amount&quot;: 2000.0
	  },
	  &quot;elementId&quot;: &quot;1&quot;,
	  &quot;startNodeElementId&quot;: &quot;1&quot;,
	  &quot;endNodeElementId&quot;: &quot;5&quot;
	}
	{
	  &quot;identity&quot;: 2,
	  &quot;start&quot;: 1,
	  &quot;end&quot;: 6,
	  &quot;type&quot;: &quot;TRANSACTION&quot;,
	  &quot;properties&quot;: {
	    &quot;date&quot;: &quot;2023-08-03T17:08:35-03:00&quot;,
	    &quot;amount&quot;: 4000.0
	  },
	  &quot;elementId&quot;: &quot;2&quot;,
	  &quot;startNodeElementId&quot;: &quot;1&quot;,
	  &quot;endNodeElementId&quot;: &quot;6&quot;
	}


How can I use **start** and **end** keys to grab the contact_id and add it to the result?

","1691099100","","","","https://stackoverflow.com/q/76831772","","","Question","Get all the relations between models including node data","false","76831772","42",,,,,
"678",":User","","","","","Diego Fernandez","","","","","","User","","false","8570478","",,,,,
"679",":Question","","0","I am using the Neo4jClient and am trying to start at a parent node and get all related nodes and relationships to build and return an Object.

The object is simply:

    public class NodeModel 
    {
      public string Key {get; set;}
      public IEnumerable&lt;EdgeModel&gt; Edges {get; set;}
    }

    public class EdgeModel 
    {
      public string Key {get; set;}
      public string EdgeType {get; set;}
      public IEnumerable&lt;NodeModel&gt; ChildNodes {get; set;}
    }

and an example of the nodes and edges I am trying to return is:

![Related nodes example](https://i.stack.imgur.com/xHweb.png)

How can I write a query using the neo4jclient that will return the nodes and edges as my NodeModel object or something close that I can work with programmatically. When trying something like:

    _graphClient.Cypher
      .Match(&quot;(parentNode:TestLabel WHERE parentNode.Key = $key)&quot;)
      .OptionalMatch(&quot;(parentNode)-&gt;[r:RELATED_TO*]-&gt;(childNode:TestLabel)&quot;)

I&#39;m not sure what to return and how to process the results in a way that fits my model. Also, I would prefer not use the APOC plugin if possible.

Thanks for the help!
","1691084342","","","","https://stackoverflow.com/q/76830420","","","Question","How to get Nodes and Edges From Neo4j To C# Object Structure using Neo4jClient","false","76830420","197",,,,,
"680",":User","","","","","MochaShakaKhan","","","","","","User","","false","9613515","",,,,,
"681",":Question","76830433","1","I have a starting node, and I&#39;m supposed to find all matching nodes that can be found using 3 different relationship types.

For example: `(n1:NodeType1)-[:Use|Realisation|Aggregation]-(n2:NodeType2)`

How would I write a query that would search for `n2` using the `Use` and `Realisation` relationships in exclusively one direction, and `Aggregation` exclusively in the other? It can be any combination of the three, within 20 hops. 

It should be able to cover all combinations. Examples:

    (n1)&lt;-[:Use]-()-[:Aggregation]-&gt;()&lt;-[:Use]-()&lt;-[:Realisation]-()-[:Aggregation]-&gt;(n2)

    (n1)-[:Aggregation]-&gt;()-[:Aggregation]-&gt;()&lt;-[:Use]-(n2)


I currently have this written:

    MATCH (n1:`NodeType1`)&lt;-[:`Use`|`Realisation`*0..20]-()-[`Aggregation`*0..20]-&gt;(n2:`NodeType2`)

With this I have a problem that after using the &#39;Aggregation&#39; relationship, it doesn&#39;t check for the other two anymore. Another problem is that this could theoretically reach 40 hops, even though I want it limited to a maximum of 20. 

Any help in how I could achieve this?","1691053947","","","","https://stackoverflow.com/q/76826555","","","Question","Neo4j search for nodes while combining relationship types in different directions?","false","76826555","44",,,,,
"682",":Question","","2","I have nodes  uploaded to neo4j and each of the nodes have properties like `email`, `phone`, `address`, etc. I need to create relationship between two nodes if sum of levenshtein distance between properties of nodes is less than a threshold value. How to do this in more optimized way? Currently, I&#39;m doing it like this: 

    MATCH (p1:sample500K) WITH p1 
    MATCH (p2:sample500K)
    WHERE id(p1) &lt;id(p2)
    AND (
      apoc.text.levenshteinDistance(p1.email, p2.email) + 
      apoc.text.levenshteinDistance(p1.phone, p2.phone) + 
      apoc.text.levenshteinDistance(p1.mobilephone, p2.mobilephone) +
      apoc.text.levenshteinDistance(p1.street, p2.street)) &lt;= $threshold
    MERGE (p1)-[:SAME_USER500K]-&gt;(p2)

I have also tried with apoc.periodic.iterate which also taking time. Also, I need to run the query in python.

Can someone suggest a better method or any changes if needed to make?
","1691046635","","","","https://stackoverflow.com/q/76825661","","","Question","Optimized way to create relationship between millions of nodes","false","76825661","78",,,,,
"683",":User","","","","","cheese butter","","","","","","User","","false","22331006","",,,,,
"684",":Question","76823335","1","I&#39;m trying to do something like the following using the py2neo module to get information for a large quantity of nodes in a neo4j database that I already know the id&#39;s of: 

    query = f&#39;&#39;&#39;    
        MATCH 
            (n:MY_LABEL)
        OPTIONAL MATCH 
            (n) -- (u:OTHER_LABEL) // Won&#39;t always have a neighbor
        WHERE 
            id(n) in [{&#39;,&#39;.join(very_long_list_of_nids)}]
        RETURN 
            id(n) as nid, 
            n.feature1,
            u.feature2
    &#39;&#39;&#39;
    resp = graph.run(query)

And I have noticed it&#39;s far faster to just omit the `WHERE` clause, and do filtering after it returns the content of every `n:MY_LABEL` node. Is there a more elegant way to do this? 

For reference, the `very_long_list_of_nodes` list is about 500k elements long (and I have tried batching it into smaller, 10k chunks and have the same problem) and the database contains 4m nodes, and 10m edges. ","1690997092","","","","https://stackoverflow.com/q/76822214","","","Question","Best way to query a large list of nodes in neo4j","false","76822214","47",,,,,
"685",":Question","76826858","1","I&#39;m following https://github.com/graphaware/fix-your-microservices to scan and identify the Micro services and their respective consumers to identify if there are any circular dependencies in my application. 

The challenge in my case is the consumers may use any one of the client libraries including Github OpenFeign, Spring OpenFeign, Apache HTTP Client, OAuthRestTemplate/RestTemplate, OkHttpClient etc. I&#39;m able to identify the Rest Controllers in my spring boot based application. That&#39;s pretty straight forward using the RestController annotations. What&#39;s challenging is to identify the client/consumers using the REST API&#39;s by the path and match them with the provider REST API&#39;s. 

Each client library have a different way of invoking the services. Its fine even it means to write separate cypher queries for each of the libraries. But I&#39;m not able to identify the relation as mentioned in the above article using `INVOKES_REMOTE`. What would be the approach to match the client invocation of those services using the respective URI ? I&#39;m using jqassistant command-line 1.12.2 utility to scan multiple microservices from my source.

Thanks in advance.","1690874515","","","","https://stackoverflow.com/q/76809330","","","Question","jQAssistant analysis to find microservices and their clients","false","76809330","50",,,,,
"686",":User","","","","","Venkat","","","","","","User","","false","2882083","",,,,,
"687",":Question","76807045","3","I have written the following custom function that performs a complex search and returns a list of IDs. Here is a simplified version:

    CALL apoc.custom.declareFunction(&#39;test()::LIST OF INTEGER?&#39;, &#39;
        MATCH (m:Movie)
        WITH m.id AS id
        LIMIT 1
        RETURN id
    &#39;)

The function is intended to be used in the following query:

    MATCH (m:Movie)
    WHERE m.id IN custom.test()
    RETURN m.title AS title

When testing the function with `RETURN custom.test() as ids`, the execution result is `[{&#39;ids&#39;: [57]}]`

In the case where the function finds nothing (for the simplified version, I replace `LIMIT 1` with `LIMIT 0`), I expect the function to return `[{&#39;ids&#39;: []}]`. However, instead, **it simply hangs**.

I have tried defining the return type as both `LIST OF INTEGER` and `LIST OF INTEGER?`.

Is this an APOC bug? How can I resolve this issue?","1690536985","","","","https://stackoverflow.com/q/76786571","","","Question","Neo4j APOC custom function hangs when nothing is found","false","76786571","72",,,,,
"688",":User","","","","","Vitaliy","","","","","","User","","false","2738250","",,,,,
"689",":Question","","0","in our neo4j database, &quot;Device&quot; node  is connected to &quot;DeviceFeature&quot; node with one way relation called &quot;has&quot;. I am trying to find an efficient way to model this in my graphql api. I am using Strawberry and FastAPI. The below code works but I guess there might be a better way to achieve this goal, possibly a better way than iteration over each device.

I would like to get devicefeature of a device by writring a graphql query like below:

    query {
      get_device(limit:20) {
        TAC_CODE
        device
        type
        has {
          id
          TAC_CODE
          brand_name
          gsma_device_type
          manufacturer_name
          model_family
          operating_system
        }
      }
    }

I would like to also be able to run the below query as well

 

    query {
     get_device(limit:20) {
            TAC_CODE
            device
            type
    }
    }

My python code is:

```py

@strawberry.type
class Device:
    TAC_CODE: Optional[int]
    device: Optional[str]
    type: Optional[str]
    has: Optional[List[DeviceFeature]] = None

@strawberry.type
class DeviceFeature:
    id: Optional[int]
    TAC_CODE:  Optional[str]
    brand_name: Optional[str]
    gsma_device_type: Optional[str]
    manufacturer_name: Optional[str]
    model_family: Optional[str]
    operating_system: Optional[str]

@strawberry.type
class DeviceFeatureQuery:
    @strawberry.field
    async def get_devicefeature(
         ... some code to run a cypher query


@strawberry.type
class DeviceQuery:
    @strawberry.field
    async def get_device(self, info:Info, filters: Optional[List[str]] = None, limit: Optional[int] = None) -&gt; List[&#39;Device&#39;]:

        device_fields = info.return_type
        print(&quot;device_fields&quot;)
        print(device_fields)
        # Extract the names of the attributes of the &#39;Device&#39; type
        device_attribute_names = {
  
                selection.name
                for field in info.selected_fields
                for selection in field.selections
                
            }
      
        cypher_query = &quot;MATCH (c:Device)&quot;
        where_conditions = []
        if filters:
            where_conditions = [f&quot;{field} = &#39;{value}&#39;&quot; for field, value in filters]
        if where_conditions:
            cypher_query += &quot; WHERE &quot; + &quot; AND &quot;.join(where_conditions)
        cypher_query += &quot; RETURN c&quot;
        if limit is not None:
            cypher_query += f&quot; LIMIT {limit}&quot;
        loop = asyncio.get_running_loop()
        neo4j_uri_instance=neo4j_uri(info.context[&#39;user&#39;][&#39;access_token&#39;])
        with neo4j_uri_instance.driver.session() as session:
            result = await loop.run_in_executor(None, session.run, cypher_query)
            devices = [Device(TAC_CODE=record[&#39;c&#39;][&#39;TAC_CODE&#39;],  device=record[&#39;c&#39;][&#39;device&#39;], type=record[&#39;c&#39;][&#39;type&#39;]) for record in result]
            if &quot;has&quot; in device_attribute_names:
                print(&quot;request has &#39;has&#39;&quot;)
                for device in devices:
            
                    device.has= await DeviceQuery.get_device_devicefeatures ( info,device.TAC_CODE)
                 
        return devices


    
    async def get_device_devicefeatures( info:Info,tac_code: int ) -&gt; List[DeviceFeature]:
        access_token = info.context[&#39;user&#39;][&#39;access_token&#39;]
        cypher_query = f&quot;MATCH (d:Device)-[:HAS]-&gt;(df:DeviceFeature) where d.TAC_CODE={tac_code} RETURN df limit 10&quot;
        #print (cypher_query)
        loop = asyncio.get_running_loop()
        neo4j_uri_instance=neo4j_uri(access_token)
        with neo4j_uri_instance.driver.session() as session:
            result = await loop.run_in_executor(None, session.run, cypher_query)
            device_features = [DeviceFeature(id=record[&#39;df&#39;][&#39;id&#39;],TAC_CODE=record[&#39;df&#39;][&#39;TAC_CODE&#39;],manufacturer_name =record[&#39;df&#39;][&#39;manufacturer_name&#39;], model_family=record[&#39;df&#39;][&#39;model_family&#39;], operating_system=record[&#39;df&#39;][&#39;operating_system&#39;], brand_name=record[&#39;df&#39;][&#39;brand_name&#39;], gsma_device_type=record[&#39;df&#39;][&#39;gsma_device_type&#39;]) for record in result]
        return device_features
```
","1690512099","","","","https://stackoverflow.com/q/76784542","","","Question","model node-relation in graphql api in python","false","76784542","47",,,,,
"690",":User","","","","","Moh-Spark","","","","","","User","","false","19489763","",,,,,
"691",":Question","","1","I&#39;m trying to find if in my database I have a closed loop consisting of only nodes that match certain criteria. I know how to specify a variable number of relationships matching criteria, such as: `-[rel_type:type*]-&gt;`, but I can&#39;t figure out how to specify the criteria for the nodes I want to have in the variable length path.

I tried this, but it found nodes not matching the criteria:

    match (n{rel_type:&#39;type&#39;})
    match (m) -[*]-&gt; (m)
    return m","1690485539","","","","https://stackoverflow.com/q/76782807","","","Question","How to write a neo4j cypher query to find closed loop of similar nodes","false","76782807","49",,,,,
"692",":User","","","","","Mike Holczer","","","","","","User","","false","6146065","",,,,,
"693",":Question","76764673","2","I am trying to get all of the nodes and relationships of a node up to n jumps(edges). Meaning that what are the nodes that I can reach with e.g., n edges, and what are the relations in between each node.

Assume that my entire graph looks like the following: `s-[r1]-x-[r2]-n`, where s, x and n are nodes, and r1 and r2 are relations.

The following query returns entire paths going from &quot;s&quot; to &quot;n&quot;:

```
MATCH (s:Type1 {id: &quot;some_id&quot;})-[r*1..2]-(n)
RETURN s,r,n
// please note that I don&#39;t necessarily mean 1..2 connections
// it should be generalizable to 1..n
```
It returns:
1. s-r1-x
2. s-(r1 and r2)-n

However, what I want is:
1. s-r1-x
2. x-r2-n

How can I achieve this?","1690294841","","","","https://stackoverflow.com/q/76763682","","","Question","Get neighbors of a node that can be reached with n jumps (edges)","false","76763682","41",,,,,
"694",":User","","","","","JollyRoger","","","","","","User","","false","8739916","",,,,,
"695",":Question","","1","I have a graph of unknown length.  I need to be able to start from a node and traverse the length of the entire chain.  I am able to do this using the quantified path pattern like below

```
MATCH (:Station { name: &#39;Station A&#39; })((:Station)-[:NEXT]-&gt;(:Station)){1,}(a:Station))
RETURN *
```

However, it is not enough to return all of the nodes.  At a particular node I have many NEXT relationships that point to other nodes.  The correct path to take is determined by plucking off the name property from the previous node, and comparing that to the name property on all of the relationships.  As an example:

`(:Station {name:&quot;Station A&quot;})-[:NEXT]-&gt;(:Station {name:&quot;Station B&quot;})
`
At the Station node named &quot;Station B&quot;, I have 3 NEXT relationships
```
[:NEXT {name:&quot;Station A}]
[:NEXT {name:&quot;Station B}]
[:NEXT {name:&quot;Station C}]
```

The correct traversal is [:NEXT {name:&quot;Station A}] because the node prior to B is the node with the name &quot;Station A&quot;

Ultimately, I need to return a chain of an indefinite length.  At each step of the graph, the correct path to take is determined by a value on the previous node.  How can I achieve this with a Cypher Query?

Thank you

I tried the following:

```
```
MATCH (a:Station { name: &#39;Station A&#39; })((:Station)-[:NEXT {name:a.name}]-&gt;(:Station)){1,}(a:Station))
RETURN *
```
```

But get the following error
`From within a quantified path pattern, one may only reference variables, that are already bound in a previous `MATCH` clause.
`
","1689797937","","","","https://stackoverflow.com/q/76724911","","","Question","Neo4j Traverse Graph of Indefinite Length With Selection Criteria","false","76724911","51",,,,,
"696",":User","","","","","Kadeem Walsh","","","","","","User","","false","22254377","",,,,,
"697",":Question","76724396","1","I&#39;m a student working on a report focused on Neo4j. I&#39;ve come across the terms &quot;native projections&quot; and &quot;cypher projections&quot;&#160; and I&#39;m having some trouble understanding the distinction between the two. Can someone please shed some light on this and help me grasp the key differences?

I&#39;ve gone through the official Neo4j documentation, but the explanations were a bit elusive, and I&#39;d love to get some additional information.
How do native and cypher projections differ, and when should I consider using one over the other?
What are the differences in performance and functionality?
Any examples or use cases illustrating the contrast would be highly appreciated.

Thank you all in advance for your help!
","1689777305","","","","https://stackoverflow.com/q/76722460","","","Question","Projections in Neo4j","false","76722460","63",,,,,
"698",":User","","","","","Marc","","","","","","User","","false","22252961","",,,,,
"699",":Question","76809108","1","I&#39;m using jqassistant-maven-plugin version 1.10.1 with common Neo4j database and am trying to collate scanning from multiple Spring boot based java applications. I&#39;ve disabled reset database so that I can collate scan information from multiple projects and identify API clients invoking API services from within other apps and see if there is any cyclic dependencies. When I do so the first maven build is working fine. But when I run the second application scan, it fails with the below error:

&gt;org.neo4j.driver.exceptions.DatabaseException: The shortest path algorithm does not work when the start and end nodes are the same. This can happen if you
perform a shortestPath search after a cartesian product that might have the same start and end nodes for some
of the rows passed to shortestPath. If you would rather not experience this exception, and can accept the
possibility of missing results for those rows, disable this in the Neo4j configuration by setting
`cypher.forbid_shortestpath_common_nodes` to false. If you cannot accept missing results, and really want the
shortestPath between two common nodes, then re-write the query using a standard Cypher variable length pattern
expression followed by ordering by path length and limiting to one result.

The package names of the class are different and there may be couple of classes that might be named similar but the fully qualified names should not create a name collision. Not sure what&#39;s causing this and how to resolve this. Any help would be appreciated.

**EDIT** The query that&#39;s failing is given below:

    UNWIND $batch as entry 
    CREATE (n:File:Directory:Package:Java) 
    SET n=entry[&#39;n&#39;]   
    RETURN collect({oldId:entry[&#39;id&#39;], newId:id(n)}) as nodes&#39;, {batch=[{n={name=controller, file
    Name=/com/mycompany/client/controller, fqn=com.mycompany.client.controller}, id=-9}]}

Unfortunately I don&#39;t have control on the query generated as its auto generated by the jqassistant-maven-plugin.","1689660942","","","","https://stackoverflow.com/q/76709965","","","Question","jQassistant assessment failing with multiple projects","false","76709965","66",,,,,
"700",":Question","","1","The py2neo cursor has attributes relating to if a query is writing data in `cursor.summary()` and `cursor.stats()`
However this dictionary remains the same both before and after `graph.commit(tx)`.

How can I confirm that `graph.commit(tx)` has written changes to the database?

My code is as follows:


```lang-python
from py2neo import Graph


def process_query(cursor):
    # Some logic would go here to create query 2 from the response of query 1.
    dummy_query = &quot;CREATE (:Person {name: &#39;John&#39;})&quot;
    return dummy_query


# Create link.
graph = Graph(uri=&quot;*****&quot;, auth=(&quot;*****&quot;, &quot;*****&quot;))

# Start transaction.
tx = graph.begin()

# Run first query.
cursor1 = tx.run(&quot;MATCH (n) RETURN n&quot;)

# Process data from first query.
query2 = process_query(cursor1)

# Run second query.
cursor2 = tx.run(query2)

# Commit the transaction.
graph.commit(tx)

# Need logic here on success of final operation.

```
I can get the write information from `cursor2.stats()` but how should I monitor `graph.commit(tx)` if the transaction is unsuccesful? Does it throw an exception or return a specific response?

I have looked at the docs but I cannot get a clear idea on how this function works exactly.","1689604020","","","","https://stackoverflow.com/q/76705469","","","Question","How to check if graph.commit(tx) has updated records in py2neo","false","76705469","40",,,,,
"701",":User","","","","","cmf","","","","","","User","","false","5027541","",,,,,
"702",":Question","","0","Can we execute cypher query through qliksense using ODBC connection?
Also, can anyone share the network graph used in qliksense which supports more nodes with arrow for indication and selection on nodes allowed? 

I am trying to load with normal SQL select statements but need to execute a cypher query","1689573737","","","","https://stackoverflow.com/q/76701842","","","Question","Neo4j odbc connection to qliksense","false","76701842","24",,,,,
"703",":User","","","","","Shruthi B.K","","","","","","User","","false","22213219","",,,,,
"704",":Question","76682867","2","I&#39;m trying to retrieve nodes where none of the relationships to that node have a specific property value. For example, I would like the query to return `foo` in the following example, because both relationships to `foo` have `prop = false`. 

`(bar0) -[{prop:false}]-&gt; (foo) &lt;-[{prop:false}]- (bar1)`

On the other hand, I would like the query to return `null` in the following example, because a subset of the relationships to `foo` have `prop = true`. 

`(bar0) -[{prop:false}]-&gt; (foo) &lt;-[{prop:true}]- (bar1)`

So far, I&#39;ve tried:

```
MATCH (foo)-[r]-(bar)
WITH collect(r) as rs, foo, bar
WHERE NONE(r in rs WHERE r.prop = True)
UNWIND rs as r
RETURN foo, bar, r
```

However, this still returns `foo`, it just removes the relationship where `prop = True`. 

I also tried using `CASE`, but run into the same problem.

```
MATCH (foo)-[r]-(bar)
WITH collect(r) as rs, foo
RETURN
CASE 
WHEN ALL(r in rs WHERE r.prop=False)
    THEN foo
ELSE null
END
```

Ideally, the query would also return nodes with no relationships as well, but I can also handle that with a separate query.
","1689265708","","","","https://stackoverflow.com/q/76681546","","","Question","Retrieve nodes where all relationships match a criteria in neo4j","false","76681546","52",,,,,
"705",":User","","","","","sjeknic","","","","","","User","","false","13895257","",,,,,
"706",":Question","76691823","1","I have two node types &quot;Person&quot; and &quot;Company&quot;. There is also a relationship called &quot;Shareholder&quot;, which can be from Person to Company or Company to Company (as companies can also hold shares in other companies). The Shareholder relationship has three properties &quot;shareholding_start_date&quot;, &quot;shareholding_end_date&quot;, &quot;number_of_shares&quot;.

I have a query which takes in Company name (call it &#39;ABC&#39;), as well as provide a date (e.g. &#39;2021-07-23&#39;), and the query returns all Person/Company nodes that are shareholders of c at the date &#39;2021-07-23&#39; (i.e. shareholding_start_date &lt; 2021-07-23 &lt; shareholding_end_date). It also calculates the percentage based on &#39;number_of_shares&#39;. 

The working query is below: 

    MATCH (c:Company {name:”ABC”})&lt;-[r:Shareholder]-(s)
    WHERE R.shareholding_start_date &lt;= Date(“2021-07-23”) 
       AND r.shareholding_end_date &gt;= DATE(“2021-07-23”)
    WITH c, 
    collect(s) as shareholders, 
    collect(r) as rels, 
    sum(r.number_of_shares) AS totalShares
    UNWIND range(0, size(rels) - 1) AS I
    RETURN shareholders[i].name AS shareholder, 
    100.0 * rels[i].number_of_shares/totalShares as percentTotalShares

I am looking to extend this so that it also shows shareholders of shareholders, up to a certain layer limit which can be defined in the query (let&#39;s say 3, for example). So in the above example, the query will return all shareholders of company &#39;ABC&#39;, which may be &quot;Person&quot; or &quot;Company&quot; node types. In the case where the shareholders of &#39;ABC&#39; are &quot;Company&quot; nodes, I basically want to repeat the same code on them and list all their Shareholders, along with the shareholding % in that company. This should continue until we reach the limit (i.e. 3). 
","1689212694","","","","https://stackoverflow.com/q/76675398","","","Question","Extending layers of nodes in neo4j graph","false","76675398","59",,,,,
"707",":User","","","","","Programmer","","","","","","User","","false","4958156","",,,,,
"708",":Question","76682768","1","Say I have nodes of types A, B and C, and I have the following graph:
[![enter image description here](https://i.stack.imgur.com/QD5Y1.png)](https://i.stack.imgur.com/QD5Y1.png)

    @NodeEntity
    data class A(
        @Id val id: String? = null,
        @Relationship(type = &quot;HAS_B&quot;)
        val b: MutableSet&lt;B&gt; = mutableSetOf&lt;B&gt;()
    )
    
    @RelationshipEntity(type = &quot;HAS_B&quot;)
    data class HasB @JvmOverloads constructor(
        @Id @GeneratedValue val id: Long? = null,
        @StartNode val start: A = A(),
        @EndNode val end: B = B()
    )
    
    @NodeEntity
    data class B(
        @Id val id: String? = null,
        @Relationship(type = &quot;HAS_C&quot;)
        val c: MutableSet&lt;C&gt; = mutableSetOf&lt;C&gt;()
    )
    
    ...

My goal is to load the node A, together with the connected B and C nodes.

Currently (in Kotlin code) I am doing `session.load(A::class.java, &quot;a1&quot;, -1)`, which uses this implementation:
`&lt;T,ID extends Serializable&gt; T load(Class&lt;T&gt; type, ID id, int depth)` (from [here](https://javadoc.io/static/org.neo4j/neo4j-ogm-core/3.2.3/org/neo4j/ogm/session/Session.html))

Supposedly, with depth = -1, this should load node A together with all its connected nodes. However, it seems to only load the node A. 

What is causing this issue, and how to fix it?","1689147430","","","","https://stackoverflow.com/q/76668155","","","Question","Neo4j OGM: How to correctly use @RelationshipEntity to load connected nodes","false","76668155","88",,,,,
"709",":User","","","","","ConfusedPenguin","","","","","","User","","false","16329148","",,,,,
"710",":Question","","1","
```
@Node(&quot;label&quot;)
public class Object extends  Auditable&lt;String&gt; implements Serializable {

    @Id
    @GeneratedValue
    private Long id;
    ....
//getter 
//setter
//constructor


}


public class ExtendedObject extends Object{

    private Long projectId;
    private String projectName;
    private Long clientID;
 
// extra field which i don&#39;t want to store in entity but want to retrieve while fetching the Object


}


@Repository
public interface ObjectRepo extends Neo4jRepository&lt;Object, Long&gt; {

@Query(&quot;&quot;)
List&lt;ExtendedObject&gt; findPosition(@Param(&quot;comparison&quot;) String comparison);

}
```


I provided necessary annotation whenever necessary.

I want to map the query result into an `ExtendedObject`, but it&#39;s throwing error:

    neo4j.com.example.entity.ExtendedObject is not a known entity



","1689062103","","","","https://stackoverflow.com/q/76659774","","","Question","&quot;neo4j.com.example.entity.ExtendedObject is not a known entity&quot; when mapping data to ExtendedObject","false","76659774","64",,,,,
"711",":User","","","","","Prasanna","","","","","","User","","false","20518585","",,,,,
"712",":Question","","1","is it possible to access data of same label name in two databases and different alias in composite database.
for example - label = person , which i have created in two different databases personDbPartition1 and personDbPartition2 respectively. i have separate alias also, see below commands: 

```sql
CREATE DATABASE personDbPartition1 TOPOLOGY 3 PRIMARY;
CREATE DATABASE personDbPartition2 TOPOLOGY 3 PRIMARY;

CREATE COMPOSITE DATABASE socialDb;
CREATE ALIAS socialDb.personP1 FOR DATABASE personDbPartition1;
CREATE ALIAS socialDb.personP2 FOR DATABASE personDbPartition2;
```

1. personDbPartition1: i have created data in personDbPartition1 and relationships 
```sql
CREATE (p:person {name: &#39;user10001&#39;, age: 30});
CREATE (p:person {name: &#39;user10002&#39;, age: 30});
CREATE (p:person {name: &#39;user10003&#39;, age: 30});
CREATE (p:person {name: &#39;user10004&#39;, age: 30});

CREATE CONSTRAINT for (p:person) REQUIRE p.name IS UNIQUE;

match(a:person{name: &#39;user10001&#39;}),(b:person{name: &#39;user10002&#39;}) create(a)-[:knows]-&gt;(b) return a,b;
match(a:person{name: &#39;user10002&#39;}),(b:person{name: &#39;user10003&#39;}) create(a)-[:knows]-&gt;(b) return a,b;
match(a:person{name: &#39;user10003&#39;}),(b:person{name: &#39;user10004&#39;}) create(a)-[:knows]-&gt;(b) return a,b;
```

2. personDbPartition2: i have created data in personDbPartition2 and relationships 
```sql
CREATE (p:person {name: &#39;user10004&#39;}); ## proxy data node
CREATE (p:person {name: &#39;user10005&#39;, age: 30});
CREATE (p:person {name: &#39;user10006&#39;, age: 30});
CREATE (p:person {name: &#39;user10007&#39;, age: 30});

CREATE CONSTRAINT for (p:person) REQUIRE p.name IS UNIQUE;

match(a:person{name: &#39;user10004&#39;}),(b:person{name: &#39;user10005&#39;}) create(a)-[:knows]-&gt;(b) return a,b;
match(a:person{name: &#39;user10005&#39;}),(b:person{name: &#39;user10006&#39;}) create(a)-[:knows]-&gt;(b) return a,b;
match(a:person{name: &#39;user10006&#39;}),(b:person{name: &#39;user10007&#39;}) create(a)-[:knows]-&gt;(b) return a,b;
```

all data created successfully and i can access them individually while login to specific database and through composite DB also


but when i am calling below combine cypher then its returning empty results:

```sql
CALL {
  USE socialDb.personP1 MATCH (p:person{name:&#39;user10004&#39;}) RETURN COLLECT(p.name) AS pids
}
WITH *
UNWIND [g IN graph.names() WHERE g STARTS WITH &#39;socialDb.personP2&#39;] AS g
CALL {
  USE graph.byName(g)
  WITH pids
  UNWIND pids as pid
  MATCH (p:person{name:pid})-[:knows]-&gt;(c:person) RETURN p.name as pname, c.name AS cname
}
RETURN pname, cname
LIMIT 20;
```





am i missing anything in query? or same label not work for multiple database and alias ?","1689010892","","","","https://stackoverflow.com/q/76656126","","","Question","create two alias of same label for different DB - composite databases","false","76656126","65",,,,,
"713",":User","","","","","user7089046","","","","","","User","","false","7089046","",,,,,
"714",":Question","","2","My Edge object is like this:

    class Edge {
       public long srcNodeId;
       public long destNodeId;
    }

Given a `List&lt;Edge&gt;`, is it possible to return all edges either src OR dest OR both nodes doesn&#39;t exist, using a single cypher query?","1688808580","","","","https://stackoverflow.com/q/76642251","","","Question","neo4j: cypher to identify unresolved edges","false","76642251","32",,,,,
"715",":User","","","","","Arjun","","","","","","User","","false","583367","",,,,,
"716",":Question","","3","Neo4j Desktop:
There is a big JSON file with entries like the one shown below.
I want to split up the entries of &quot;src&quot; and create nodes with each single one of the entries. 
Further i want the other values to be the nodes parameters.
Input via JSON file (see below).

What is the best way to do all this stuff?

```
{
    &quot;transaction&quot;:  &quot;42043-134632465-3221&quot;,
    &quot;action&quot;:  &quot;Accept&quot;,
    &quot;src&quot;:  &quot;dummy593, dummy834, dummy203&quot;,
    &quot;adds&quot;:     {
                },
    &quot;dest&quot;:     {
                    &quot;name&quot;:  &quot;John Doe&quot;,
                    &quot;address&quot;:  &quot;Baker Street&quot;,
                    &quot;phone&quot;:  &quot;12345, 54321&quot;                  
                }
}
```


I tried to combine the functions of apoc.load.json, apoc.cyper.run and within this i used split(src, &#39;,&#39;).
I&#39;ve gotten a security error and honestly i don&#39;t think it would&#39;ve worked though.
Should i use `apoc.load.json` or something like `with{json}`?

```
call apoc.load.json(&quot;file:/Users/user/.Neo4jDesktop/relate-data/dbmss/dbms-969/import/example.json&quot;) YIELD value
with value.src as src
call apoc.cypher.run(&quot;with $src as src unwind src as src create (:src {src: src})&quot;, {src: split(src, &#39;,&#39;)}) yield value
return value
```


Apologies and thanks - i&#39;m bloody new in cypher topics ... 
","1688735321","","","","https://stackoverflow.com/q/76637272","","","Question","How to split up elements in an array (JSON) and create nodes in neo4j","false","76637272","36",,,,,
"717",":User","","","","","chickenleg","","","","","","User","","false","22178705","",,,,,
"718",":Question","76631134","1","The DB has items, and these items have a string parameter which is a comma separated string array. Im trying to pass in a search variable, and use that to return the item node, and the string array but with only the strings that match the search variable

```
match (n:Node) return n.string

```
returns the strings sorted by the item node as [&quot;abc,def,abcde&quot;]


```
match (n:Node)  where any(string in n.string where string contains &quot;abc&quot;) return n
```
This gets me the nodes where one of the strings contains what I&#39;m looking for, but I can&#39;t seem to find a way to get the ones which matched and return them as a field



So if a node has a string of [&quot;abc&quot;,&quot;def&quot;,&quot;abcde&quot;] then when I search for strings containing &quot;bc&quot; then it should get the node and return just the strings of [&quot;abc&quot;,&quot;abcde&quot;]


","1688629312","","","","https://stackoverflow.com/q/76626552","","","Question","Trying to filter an array of strings to return a single field which is a subset of the array with strings that contain a variable","false","76626552","40",,,,,
"719",":User","","","","","footiefan92","","","","","","User","","false","22183369","",,,,,
"720",":Question","","0","I apologize for the naive question as I am relatively new to graph databases and currently working with Neptune OpenCypher for my use case. I am experiencing different outcomes for two similar queries and would like to understand the reasons behind it.

My dataset consists of hundreds of millions of nodes. Here are the details of the queries:

Query 1: Timeout Error

```
MATCH p=(n:Person)-[:RELATIONSHIP*..5]-&gt;(m:Person {condition: True})
WHERE 
ID(n) = &lt;id_Value&gt;
AND size([node IN nodes(p) WHERE node.event_date &gt; n.event_date]) = 0
RETURN p
LIMIT 1
```

Query 2: Successful Response

```
MATCH p=(n:Person)-[:RELATIONSHIP*..5]-&gt;(m:Person {condition: True})
WHERE 
ID(n) = &lt;id_Value&gt;
AND size([node IN nodes(p) WHERE node.event_date &gt; n.event_date]) = 0
WITH p
ORDER BY n.event_date ASC
LIMIT 1
RETURN p
```

I&#39;m curious about the reasons behind the timeout error in Query 1 and the successful response in Query 2. Both queries have a similar structure, but Query 1 times out while Query 2 executes successfully. Can someone explain why this might be happening?

I ran both queries mentioned earlier, and Query 1 resulted in a timeout while Query 2 executed successfully. However, I&#39;m encountering unexpected results with Query 2, and I want to ensure that I&#39;m not misunderstanding or misusing it.","1688593634","","","","https://stackoverflow.com/q/76624234","","","Question","Query Timeout in Neptune OpenCypher - Different Results for Similar Queries","false","76624234","87",,,,,
"721",":User","","","","","topgun007","","","","","","User","","false","22181634","",,,,,
"722",":Question","","2","I have the datascheme shown in the picture. I want, for instance, to retrieve all &quot;Diseases&quot; connected to &quot;Pathway&quot; through different combinations of edges and nodes in between. If I write:

MATCH (p:Pathway)-\[:IS_INVOLVED\]-(d:Disease) RETURN DISTINCT d.Name LIMIT 3

The query is executed very fast. If I write:

MATCH (p:Pathway)-\[\*\]-(d:Disease) RETURN DISTINCT d.Name LIMIT 3

It takes forever to finish. My suspicion is that it traverses to the Compound node at the beginning and checks if there is a connection to the node Disease. Since there is a fairly large number of Compound nodes, the execution time is extremely large. Is there a way to hint the engine to take a specific approach when traversing? Maybe influencing the query execution plan in some way?

My dataset is expected to increase so it

[Data Scheme](https://i.stack.imgur.com/pGfO1.png)

The only way of retrieving some results without an excessive wait time is by limiting the edge depth constraint to 1 or 2 (i.e. -[*..2]-). I am hoping to be able to retrieve results connected by a maximum of 6-edge paths (i.e. -[*..6]- or -[*]-).","1688542838","","","","https://stackoverflow.com/q/76618102","","","Question","Is there an efficient way of traversing a graph to find connections between two nodes through all combinations of relatiosnhips and nodes?","false","76618102","39",,,,,
"723",":User","","","","","Guillermo Guells","","","","","","User","","false","22174712","",,,,,
"724",":Question","76620613","2","I am currently doing something like:

```
MATCH (s:Something)
OPTIONAL MATCH (t:Tag)&lt;-[:HAS_TAG]-(s)
OPTIONAL MATCH (i:Item)&lt;-[:HAS_ITEM]-(s)
OPTIONAL MATCH (w:Whatever)&lt;-[:HAS_WHATEVER]-(s)
```

When I do a profile, I see that 3 optional expand for each OPTIONAL MATCH sequentially, wonder if I can speed it up by possibly doing it in parallel? Since its independent of each other? ","1688541774","","","","https://stackoverflow.com/q/76617954","","","Question","How do I do multiple OPTIONAL MATCH in parallel in Cypher?","false","76617954","42",,,,,
"725",":User","","","","","Jiew Meng","","","","","","User","","false","292291","",,,,,
"726",":Question","","2","A typical pattern I find myself looking for is I want to find results do some pagination (skip/limit) then do some additional &quot;joins&quot; to populate related fields. Currently, something like

    MATCH (s:Something)
    CALL {
      WITH s
      MATCH (s)-[:SOMETHING]-&gt;(o:Other)
      RETURN o
    }
    SKIP 1000
    LIMIT 50

Seem to cause the subquery to run for 1000 (the skipped `s` nodes) + 50 (limit). I think ideally I only need to run the subquery for the 50 nodes I really want, I tried putting the skip earlier but cannot seem to get the syntax correct. How do I do it? ","1688539366","","","","https://stackoverflow.com/q/76617679","","","Question","How to limit then do subquery?","false","76617679","23",,,,,
"727",":Question","","1","I have a large knowledge graph (below is a small part of it):
[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/Rggkl.png

The P nodes are in a hierarchy and other nodes and relationships are connected to them, I want to retrieve the D nodes and the edges and nodes attached to them like C and X nodes shown in the sample image below.
I want to write a query where I provide the id for node P1 and subsequently retrieve all the connections and extract a subgraph. There are multiple other connections to the D nodes. I want to retrieve all of it and also filter the connections based on edge properties. How can I do this using a cypher query in Neo4j?","1688473066","","","","https://stackoverflow.com/q/76612533","","","Question","Extract a subgraph starting from one node","false","76612533","52",,,,,
"728",":User","","","","","kamalika ray","","","","","","User","","false","20505088","",,,,,
"729",":Question","76604792","2","I have nodes in my graph where they are in a hierarchy. The hierarchy is saved as a node property instead of edges. There are no connecting edges between these nodes in the graph.

eg:
```
P1 -CHILD-&gt; P2, P3 -CHILD-&gt; P4
P1 has Node property: Child - [P2,P3,P4]
P2 has Node property: Child - [P4]
P3 has Node property: Child - [P4]
P4 has Node property: Child - None
```
Is it possible to retrieve all the hierarchy starting from P1 in a cypher query?","1688374717","","","","https://stackoverflow.com/q/76603290","","","Question","Retrieve hierarchy based on node property with Cypher","false","76603290","37",,,,,
"730",":Question","76601616","1","I have two node types &quot;Person&quot; and &quot;Company&quot;. There is also a relationship called &quot;Shareholder&quot;, which can be from Person to Company or Company to Company (as companies can also hold shares in other companies). The Shareholder relationship has three properties &quot;shareholding_start_date&quot;, &quot;shareholding_end_date&quot;, &quot;number_of_shares&quot;. 

I want to be able to query a Company (call it **c**) by name, as well as provide a date (e.g. &#39;2021-07-23&#39;), and the query should return all Person/Company nodes that are shareholders of **c** at the date &#39;2021-07-23&#39; (i.e. shareholding_start_date &lt; 2021-07-23 &lt; shareholding_end_date). I also want to calculate the percentage based on &#39;number_of_shares&#39;.

As an example, let&#39;s say there is a company called XYZ, and I want to know all it&#39;s shareholders on 2022-03-15. Suppose ABC has three shareholders ABC, DEF, GHI on this day (these can be either Person or Company nodes). ABC holds 30 shares, DEF holds 50 shares, GHI holds 120 shares.

The query should be something like this (obviously this is not cypher, but I&#39;m unable to express it in any other way!): 

    Company.name = &quot;XYZ&quot;
    and Shareholder.shareholding_start_date &lt;= 2022-03-15
    and SHareholder.shareholding_end_date &gt;= 2022-03-15

 Returns something like:

    ABC 15%, DEF 25%, GHI 60%","1688350539","","","","https://stackoverflow.com/q/76601502","","","Question","Getting weights as percentages from edges","false","76601502","67",,,,,
"731",":Question","","0","I am looking to figure out how to build a qualitative dataset based on cause effect relationships. 

For the causes, i want to consider Findings and Symptoms and for the effects i want to consider diseases and disorders. 

I have imported the SNOMED CT data into Neo4J DB using the scripts provided by SNOMED International (https://github.com/IHTSDO) (https://github.com/IHTSDO/snomed-database-loader/tree/master/NEO4J). 

The Ontology has been downloaded from the official NLM website(https://www.nlm.nih.gov/healthit/snomedct/us_edition.html). 

What would the cypher queries look for this?

Other details - 

1. SNOMED CT US Data version = 20230301
2. Neo4J desktop on Mac OS X running db version `4.4.22`
","1688311533","","","","https://stackoverflow.com/q/76599592","","","Question","SNOMED CT Cypher Query","false","76599592","95",,,,,
"732",":User","","","","","saarthak gupta","","","","","","User","","false","4865707","",,,,,
"733",":Question","","1","I am working on a simple app.
I am using neo4j db and in the frontend I have given an option to the users to write a cypher query that would then be executed in neo4j and would give expected response
I wanted to know if there is any library or any way apart from regex where I can check for the syntax in the frontend only without having to run it in the neo4j.","1688105920","","","","https://stackoverflow.com/q/76586497","","","Question","Validate cypher query in Frontend","false","76586497","126",,,,,
"734",":User","","","","","rohit bumrah","","","","","","User","","false","14059508","",,,,,
"735",":Question","","2","I am currently working with Neo4j and using the Popoto.js library. However, I have come across an issue regarding the customization of node labels in the generated queries.

To provide some context, when Popoto.js generates a query for a node with a specific label, it includes the label as part of the node identifier, which can lead to queries that are not accepted by the Neo4j database. For example, the generated query looks like this:

    MATCH (node::test:`Node::test`) RETURN node::test

As mentioned, this query format is not compatible with the Neo4j database. I am wondering if there is a solution or workaround to customize the query and achieve the desired result. Specifically, I would like to generate a query in the following format:

    MATCH (n:`Node::test`) RETURN n

PS: i can&#39;t remove the &#39;::&#39; from nodes 
This modified query format would allow me to work with the Neo4j database seamlessly.

I would greatly appreciate any guidance or insights you can provide regarding this issue. Thank you in advance for your assistance.

I tried to update `popoto.start` function to generate a custom node label, but am still looking for a solution.","1688033499","","","","https://stackoverflow.com/q/76580079","","","Question","popoto.js - customize node label","false","76580079","49",,,,,
"736",":User","","","","","Dorgaa Said","","","","","","User","","false","17405501","",,,,,
"737",":Question","","2","I have the following Cypher query:

    MATCH (c:Criterion {id: 24}) 
    OPTIONAL MATCH (c)&lt;-[:HAS_VOTE_ON]-(d:Decision)-[:HAS_VOTE_ON]-&gt;(s:Skill) 
    WHERE s.id &lt;&gt; c.id WITH c, s

How to continue the query in order to return for `c`: `s` and `count of each distinct s` ?","1687989028","","","","https://stackoverflow.com/q/76576921","","","Question","Neo4j Cypher Group By","false","76576921","27",,,,,
"738",":Question","76567283","3","I&#39;m trying to swap multiple properties and all relationships between two nodes in Neo4j. 
For example-

    Node 1 -&gt; {id=&#39;id1&#39;,name:&#39;ABC&#39;,city=&#39;London&#39;} belongs to A
    Node 2 -&gt; {id=&#39;ID1&#39;,name:&#39;PQR&#39;,city=&#39;Paris&#39;} belongs to B

After Query Execution, the result should be-

    Node 1 -&gt; {id=&#39;id1&#39;,name:&#39;PQR&#39;,city=&#39;Paris&#39;} will belong to B
    Node 2 -&gt; {id=&#39;ID1&#39;,name:&#39;ABC&#39;,city=&#39;London&#39;} will belong to A

Note: id is case-sensitive hence two nodes with similar text are present. We don&#39;t want to swap id property.

Tried doing it with `set properties(node)` and Temp node like-

    MATCH
      (node1 {id: &#39;id1&#39;}),
      (node2 {id: &#39;ID1&#39;})
    CREATE (Temp:Student{properties(node1)}) 
    AND SET node1.name = node2.name, node1.city = node2.city
    AND SET node2.name = Temp.name, node2.city = Temp.city
    AND DELETE Temp 
    RETURN node1,node2

Getting following error

    Invalid input &#39;(&#39;: expected &quot;}&quot; (line 4, column 33 (offset: 99))
    &quot;CREATE (Temp:Student{properties(node1)})&quot;

Wanted to know if it&#39;s possible without creating a Temp node.

Thank you.","1687869390","","","","https://stackoverflow.com/q/76564945","","","Question","Swapping specific properties of two nodes including relationships in Neo4j","false","76564945","63",,,,,
"739",":User","","","","","nik","","","","","","User","","false","5238800","",,,,,
"740",":Question","76564394","1","I want to filter the edges between the two nodes according to the an edge property. However, only the nodes are getting filtered when I use the following Cypher query. 
```
MATCH (s:Source {id: 54558})-[r:CCI{prop_1: 8}]-&gt;(t:Target)
with s, collect(r) as filterededges, t return s, filterededges, t
```
[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/rGYJ7.png


In the &quot;Table&quot; output, it is showing the correct result (one edge from the source node to the target node) How can I remove the unwanted edges that are displayed?
I am using Neo4j version 5.

Thanks a lot!","1687861820","","","","https://stackoverflow.com/q/76563944","","","Question","Neo4j/Cypher: Filter edges between two nodes","false","76563944","35",,,,,
"741",":Question","76560854","1","We are using neo4j v4.

I have USER, COMPUTER, COMPANY nodes(IBM, HP, DELL etc),

When company is IBM, I want to reverse the edge before returning.

I tried apoc.refactor.invert() like below:


    MATCH (u:USER {id: 101})
    RETURN  
    CASE u.preference 
    WHEN &#39;HP&#39;    THEN  [(n:computer)-[r: MANUFACTURED_BY]-&gt;(c:HP) | r]
    WHEN &#39;IBM&#39;   THEN [(n:computer)-[r:ASSEMBELED_BY]-&gt;(c:IBM) | apoc.refactor.invert(r)] 
    WHEN &#39;DELL&#39;   THEN [(n:computer)-[r:ASSEMBELED_BY]-&gt;(c:DELL) | r] 
    WHEN &#39;HP_IBM&#39; THEN xxxxxxx END
    AS result;

But, getting this error: Invalid input &#39;s&#39;

Any idea?




","1687817166","","","","https://stackoverflow.com/q/76560493","","","Question","neo4j cypher: return invert relationship","false","76560493","76",,,,,
"742",":Question","","1","I am using neo4j-admin import command to import data into a neo4j causal cluster with neo4j enterprise 4.4.7 installed on 9 Ubuntu VMs configured as CORE instances. Cluster is functional and works.
The data I want to import are stored in csv/tbl files generated with tpch-dbgen tool (based on TPCH schema). I have csv files with the headers and tbl files with actual data. The data is generated for scale factor 1 and 10, not so big datasets, but I plan to scale up to 500 if I can make the import work.


I just can&#39;t obtain the data after import and I am running into a dead end.
Would really appreciate some guidance !

The steps I take for import:
1. stop neo4j with command /usr/local/neo4j-enterprise-4.4.7/bin/neo4j stop;
I get the message that it&#39;s stopping and stopped.
This step I take on all VMs of the cluster.

2. run the command for import: 
neo4j-admin import --database=tpch --delimiter=&quot;|&quot; --ignore-extra-columns=true --nodes=REGION:REGION=&quot;/home/ubuntu/tpch_headers/region.csv&quot;,&quot;/home/ubuntu/tpch-dbgen/data01/region.tbl&quot; --nodes=NATION:NATION=&quot;/home/ubuntu/tpch_headers/nation.csv&quot;,&quot;/home/ubuntu/tpch-dbgen/data01/nation.tbl&quot; --nodes=CUSTOMER:CUSTOMER=&quot;/home/ubuntu/tpch_headers/customer.csv&quot;,&quot;/home/ubuntu/tpch-dbgen/data01/customer.tbl&quot; --nodes=PART:PART=&quot;/home/ubuntu/tpch_headers/part.csv&quot;,&quot;/home/ubuntu/tpch-dbgen/data01/part.tbl&quot; --nodes=SUPPLIER:SUPPLIER=&quot;/home/ubuntu/tpch_headers/supplier.csv&quot;,&quot;/home/ubuntu/tpch-dbgen/data01/supplier.tbl&quot; --nodes=PARTSUPP:PARTSUPP=&quot;/home/ubuntu/tpch_headers/partsupp.csv&quot;,&quot;/home/ubuntu/tpch-dbgen/data01/partsupp.tbl&quot; --nodes=ORDERS:ORDERS=&quot;/home/ubuntu/tpch_headers/orders.csv&quot;,&quot;/home/ubuntu/tpch-dbgen/data01/orders.tbl&quot; --nodes=LINEITEM:LINEITEM=&quot;/home/ubuntu/tpch_headers/lineitem.csv&quot;,&quot;/home/ubuntu/tpch-dbgen/data01/lineitem.tbl&quot;;

it displays import completed

3. start neo4j with command /usr/local/neo4j-enterprise-4.4.7/bin/neo4j start;
I get the message that it started and ran it on all VMs of the cluster.

4. I connect from one of the VMs using cypher-shell to the system database with user neo4j

5. I create the tpch database

6. I select it

7. I run call db.schema.visualization; to see it&#39;s data but nothing appears, like it would be empty.

8. I run a simple query like match(n) return count(n); and it displays 0 like no node would be present.","1687732054","","","","https://stackoverflow.com/q/76552642","","","Question","Data not available after neo4j-admin import (Causal Cluster / Neo4J Enterprise Edition)","false","76552642","67",,,,,
"743",":User","","","","","Esanu Codrin Stefan","","","","","","User","","false","22130263","",,,,,
"744",":Question","","1","I am looking for a way to add a relationship property to collapsed path during native projection. Eg. I&#39;m collapsing `(P1)-[:HAS_ZIP]-&gt;(:ZIP)&lt;-[:HAS_ZIP]-(P2)` to `(P1)-[:SHARES_ZIP]-(P2)`.

And I want to add say `[:SHARES_ZIP {verified: 1}]` if either P1/P2 have property is_verified=1 to use as weight in GDS centrality algorithms. I looked at the collapsePath [signature][1] but couldn&#39;t find a way to add relationship properties.


  [1]: https://neo4j.com/docs/graph-data-science/current/beta-algorithms/collapse-path/","1687538345","","","","https://stackoverflow.com/q/76542023","","","Question","Adding relationship property on projection based on node property during collapse path","false","76542023","46",,,,,
"745",":User","","","","","Vaibhav","","","","","","User","","false","1578274","",,,,,
"746",":Question","","2","I&#39;ve recently started working on Cypher. Created a `Book` database. I want to implement following things using Cypher query-
1. Find all books containing at least 1 capital letter in its `isbn` property value.
2. Traverse over all of such books and for each book if one more book(node) is present with same value but in small case(If other node is present then it&#39;ll always have small case isbn value) then add label to capital value node with name `Deleted`.
3. If only one node present with capital value then convert its value into small case.

Following is the query I wrote, but getting error about unexpected case-

     CALL apoc.periodic.iterate(
    &#39;MATCH (res:Book) WHERE res.isbn =~ \&#39;.*[A-Z]+.*\&#39; RETURN res&#39;, 
    &#39;MATCH (res2:Book) WHERE toLower(res.isbn) = toLower(res.isbn) 
    RETURN count(res2) as rescount WITH CASE rescount 
    WHEN 1 THEN set res.isbn=toLower(res.isbn) 
    WHEN 2 THEN set (res:Deleted) END&#39;,{})

Error-

    {&quot;Invalid input &#39;r&#39;: expected whitespace, comment, &#39;{&#39;, node labels, MapLiteral, a parameter, a parameter (old syntax), a relationship pattern, &#39;(&#39;, &#39;.&#39;, node labels or rel types, &#39;[&#39;, &#39;^&#39;, &#39;*&#39;, &#39;/&#39;, &#39;%&#39;, &#39;+&#39;, &#39;-&#39;, &quot;=~&quot;, IN, STARTS, ENDS, CONTAINS, IS, &#39;=&#39;, &quot;&lt;&gt;&quot;, &quot;!=&quot;, &#39;&lt;&#39;, &#39;&gt;&#39;, &quot;&lt;=&quot;, &quot;&gt;=&quot;, AND, XOR, OR, WHEN, ELSE or END (line 3, column 21 (offset: 187))\n&quot;    WHEN 1 THEN set res.isbn=toLower(res.isbn)&quot;\n                     ^&quot;: 1                                                                                                                            }

","1687521439","","","","https://stackoverflow.com/q/76539882","","","Question","Adding case in Match statement of iterate function in neo4j","false","76539882","36",,,,,
"747",":Question","","1","After running cypher query on neo4j, I can export/download the result as json or csv format. However, as I tried to import that into python, I found error as the json and csv are not formatted properly. Can someone please  help with importing into json? Thank you.


    with open(file_path, &quot;r&quot;) as file:
        data = json.load(file)
    ---------------------------------------------------------------------------
    JSONDecodeError                           Traceback (most recent call last)
    Cell In[28], line 2
          1 with open(file_path, &quot;r&quot;) as file:
    ----&gt; 2     data = json.load(file)

","1687434122","","","","https://stackoverflow.com/q/76531524","","","Question","How to export and read json output from neo4j cypher queries?","false","76531524","219",,,,,
"748",":User","","","","","Droid-Bird","","","","","","User","","false","626664","",,,,,
"749",":Question","","0","I&#39;m having an issue when trying to map a node entity inside a COLLECT aggregate.

For example, consider that a Company has zero or more Employees. In a graph database, I can create the following relationship between two nodes:

    MATCH (e:Employee { name:&#39;Michael&#39; }), (c:Company { name:&#39;Acme&#39;})
    CREATE (e)-[r:WORKS_FOR {hired: datetime()}]-&gt;(c);

For whatever reason, I now want to write a custom query to fetch all employees in a company.

***NOTE: I understand I can annotate the relationship in the MyCompany entity, but I want to do it in a custom query.***

For example:

    @Query(value=
      &quot;&quot;&quot;
      MATCH (c:Company {name:$name})&lt;-[r:WORKS_FOR]-(e:Employee)
      RETURN c AS company, COLLECT({employee:e, type:type(r)}) as relationships;
      &quot;&quot;&quot;)
    MyResult findRelationships(String name);

The POJOs are ***(excluding most of the annotations intentionally)***:

    @Node(&quot;Company&quot;)
    class MyCompany {
      private String name;
    }
    
    @Node(&quot;Employee&quot;)
    class MyEmployee {
      private String name;
    }
    
    class MyRelationship {
      private MyEmployee employee;
      private String type;
    }
    
    class MyResult {
      private MyCompany company;
      private Set&lt;MyRelationship&gt; relationships;
    }

This query works perfectly fine using the Cypher Shell CLI. Furthermore, if I avoid the COLLECT and simply return the company, employee and the relationship type, Spring Data works as expected (other than returning multiple matching rows for each permutation).

However, when running in the application using Spring Data with the COLLECT, I get the following error:

    Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed:
      org.springframework.data.mapping.MappingException:
      Error mapping {type: &quot;WORKS_FOR&quot;, employee: node&lt;58&gt;}] with root cause
      java.util.NoSuchElementException: No value present

I think they call this a projection?

Some database/app details:

    Database: &quot;Neo4j Kernel&quot; | &quot;5.8.0&quot; | &quot;community&quot;
    App (spring-boot-starter-parent): 3.1.0
    App (org.neo4j:neo4j-cypher-dsl:jar:2023.2.0:compile)
    App (org.neo4j.driver:neo4j-java-driver:jar:5.8.0:compile)
    App (org.projectlombok:lombok:jar:1.18.28:provided)
    App (JDK 17.0.2)
    App (Cypher-DSL Dialect.NEO4J_5)

Any help would be greatly appreciated!","1687373254","","","","https://stackoverflow.com/q/76526269","","","Question","Spring Data Neo4j custom query that maps node entity inside COLLECT aggregate","false","76526269","75",,,,,
"750",":User","","","","","Michael Cronk","","","","","","User","","false","1183989","",,,,,
"751",":Question","","2","I have a json file that defines the nodes and their relationships. It looks sometihng like this:

&gt; {&quot;p&quot;:{&quot;type&quot;:&quot;node&quot;,&quot;id&quot;:&quot;0&quot;,&quot;labels&quot;:[&quot;Paintings&quot;],&quot;properties&quot;:{&quot;date&quot;:&quot;1659-01-01T00:00:00&quot;,&quot;img&quot;:&quot;removed-for-brevity(RFB)&quot;,&quot;name&quot;:&quot;King Caspar&quot;,&quot;sitelink&quot;:&quot;1&quot;,&quot;description&quot;:&quot;RFB&quot;,&quot;exhibit&quot;:&quot;RAB&quot;,&quot;uri&quot;:&quot;RFB&quot;}},&quot;r&quot;:{&quot;id&quot;:&quot;144&quot;,&quot;type&quot;:&quot;relationship&quot;,&quot;label&quot;:&quot;on_MATERIAL&quot;,&quot;start&quot;:{&quot;id&quot;:&quot;0&quot;,&quot;labels&quot;:[&quot;Paintings&quot;]},&quot;end&quot;:{&quot;id&quot;:&quot;2504&quot;,&quot;labels&quot;:[&quot;Material&quot;]}},&quot;n&quot;:{&quot;type&quot;:&quot;node&quot;,&quot;id&quot;:&quot;2504&quot;,&quot;labels&quot;:[&quot;Material&quot;],&quot;properties&quot;:{&quot;name&quot;:&quot;oak&quot;,&quot;sitelink&quot;:5,&quot;description&quot;:&quot;RFB&quot;,&quot;uri&quot;:&quot;RFB&quot;}}}
&gt; 
&quot;p&quot; is the first node, &quot;r&quot; is the relationship, &quot;n&quot; is the second node.

Is it possible for neo4j to create a graph/map automatically from this json file, without having to define the nodes and relationships through cypher manually?

I am fairly new to neo4j, I tried following the examples given on the [Load JSON](https://neo4j.com/labs/apoc/4.1/import/load-json/) page, but it defines the nodes and their relationships manually, which i want to avoid.","1687369787","","","","https://stackoverflow.com/q/76525941","","","Question","Can neo4j create the map automatically from the json file if the relationships are defined in the json file?","false","76525941","98",,,,,
"752",":User","","","","","Wahaj Ahmad","","","","","","User","","false","8555995","",,,,,
"753",":Question","76525872","1","I have currently the problem, that I want to find an exactly same subgraph under one other node. 

To make it more specific. I have multiple repair guides which have multiple repair steps. The repair steps can exist also inside another repair guide. Now I want to find similar repair guides which have the exact same repair steps. 

```
MATCH (mp1:Maintenance{name:&#39;13 Years (325000 km)&#39;})-[:HAS]-&gt;(ws:WorkStep)
WHERE id(mp1)=49214
with collect(ws) as workingssteps, mp1
MATCH (mp2:Maintenance)
```

Now I&#39;m stuck, how to proceed further to iterate over mp2 to find the same working steps from mp1. 

Thanks for any help or tips. 
Christian","1687356320","","","","https://stackoverflow.com/q/76524175","","","Question","Neo4j: Searching in graph for exact same sub-graph","false","76524175","26",,,,,
"754",":User","","","","","TiMeJuMp","","","","","","User","","false","6108697","",,,,,
"755",":Question","76522550","1","I&#39;m new to Neo4j. I want to fetch all nodes whose one of property for example `name` contains a capital character at any position. I saw the `CONTAINS` clause provided but was unable to use it with RegEx as Compiler does not accept `=~` after CONTAINS keyword in the query.
Thanks in advance.","1687344791","","","","https://stackoverflow.com/q/76522485","","","Question","Find all nodes containing capital letter in specific property value","false","76522485","35",,,,,
"756",":Question","","1","I am new in neo4j. I wanted to run a query that should return a :person node, and all the surrounding nodes and relationship so that I can form a subgraph from those components. 

I have started like [this][1] But could not go far. My output should look like this,

    Return CentreNode, OtherNodes, RelationshipsAmongNodesUpToNHops

To explain the problem, I am using python networkx for illustration only.

In this example, the original graph looks like this,

    import os
    import sys
    import networkx as nx
    
    G1 = nx.karate_club_graph()
    nx.draw_networkx(G1)

Now lets find an ego_graph centered on node 16, radious 2 and it should look like this,

    ego_graph = nx.ego_graph(G1, 16, 2)
    nx.draw_networkx(ego_graph)

My goal is to find (:person) nodes, and ego_graph with radius R, centered on the person nodes. Its a large database, so the there will be many :person nodes (hence many ego_graphs).

Thanks in advance.

  [1]: https://stackoverflow.com/questions/68082323/return-nodes-together-with-relations

","1687342193","","","","https://stackoverflow.com/q/76522148","","","Question","How do I query neo4j to get a node of any class, and surrounded nodes, inlcuding relationship?","false","76522148","34",,,,,
"757",":Question","","1","So, I am working with Neo4J and I have a problem where I have 2 different nodes (one called :Road and other called :Landmark) both of them have a property called coordinate that is the location of this point in wsg-84 system (created using spatial datatype in neo4j basically i.e. ```point()``` ). I need to create a relation between a :Road and a :Landmark where the distance is the minimum between them (geodesic distance). 

I am using spatial function like ```point.distance(r.coordinate,l.coordinate)``` to find the distance between them but I am not able to understand **how to find the closest distance from a :Landmark to a :Road and then create a relation between them**. It is possible to for a :Road to have multiple :Landmark related to it but each :Landmark should have only one :Road related to it. Can somebody help me write a cypher query for this.   


```cypher
MATCH (l:Landmark)
OPTIONAL MATCH (r:Road)
with p,apoc.coll.sortMaps(collect({road:r,dist:point.distance(l.coordinate ,r.coordinate)}),&quot;dist&quot;) as minDist
CREATE (l) -[:relatesTo]-&gt;(head(minDist).road)
```

I tried things like this but even when I return the values l and head of minDist it is it is the minDist part is same for all entries. This does not work it maps all :Landmarks to one :Road. Please help
","1687111759","","","","https://stackoverflow.com/q/76501936","","","Question","How to pick a parent node then iterate over other node (with different label) and find some information and do it repeatedly for each parent node","false","76501936","25",,,,,
"758",":User","","","","","that guy","","","","","","User","","false","22093104","",,,,,
"759",":Question","","1","Let&#39;s say I have a graph structure like:

```cypher
:Project{name:&quot;str&quot;} -[:BelongsTo]-&gt; :Organisation{id: &quot;str&quot;} 
```

I want to ensure that the project `name` is unique for a given organisation `id`. Is it possible to do this within this structure, or do I need to store the `organisationId` as a property in the `:Project` node too? What is the best practice for this type of requirement?","1687043117","","","","https://stackoverflow.com/q/76498481","","","Question","Unique key for nodes and relationship property","false","76498481","27",,,,,
"760",":Question","","0","I am currently trying to make recommendations based on collaborative Filtering. I have `Book`, `User`, and `Author` nodes in my database. The users are connected to the books with `RATED` and `ADDED TO LIST`. The books and authors with `WRITTEN_BY`.

```
// k-nearest neighbor
MATCH (u1:User {user_id: 11927})-[r:RATED]-&gt;(b:Book)
WITH u1,r.rating AS rating_u1
MATCH (u1)-[r1:RATED]-&gt;(b:Book)&lt;-[r2:RATED]-(u2)
WITH u1, u2, COLLECT({r1: r1, r2: r2}) AS ratings WHERE size(ratings) &gt; 5
MATCH (u2)-[r:RATED]-&gt;(b:Book)
WITH u1, u2, r.rating AS rating_u2, ratings
UNWIND ratings AS r
WITH sqrt(sum((r.r1.rating - r.r2.rating)^2)) AS euclidean_distance,
u1, u2 WHERE euclidean_distance &lt;&gt; 0
WITH u1, u2, 1 / (1 + euclidean_distance) AS similarity
ORDER BY similarity DESC LIMIT 10
MATCH (u2)-[r:RATED]-&gt;(b:Book)
WHERE NOT EXISTS((u1)-[:RATED]-&gt;(b))
RETURN b.title, SUM(similarity * r.rating) AS score
ORDER BY score DESC LIMIT 25
```
With this Cypher query I want to compare each pair of users who have rated at least 5 common books. Then, I want to compare the 10 most similar users to the user with `user_id` 11927. But there must be something wrong with my code; it is not doing what it should. Have you an idea how I could solve this? (I want to do it without graph data science, playground, or AuraDS). 
","1687019486","","","","https://stackoverflow.com/q/76497144","","","Question","Cypher and k nearest neighbor collaborative filtering","false","76497144","27",,,,,
"761",":User","","","","","Eliza","","","","","","User","","false","21558841","",,,,,
"762",":Question","76493211","1","I have a data model that&#39;s something like:

```
(PersonA)-[:KNOWS]-&gt;(PersonB)
(PersonA)-[:KNOWS]-&gt;(PersonC)
(PersonA)-[:IS_FRIENDS_WITH]-&gt;(PersonD)
(PersonA)-[:LIKES]-&gt;(PersonE)
```

I&#39;d like to write a query to return PersonA, with lists of related person grouped by the relation type. i.e.

```
{
     &quot;id&quot;: &quot;PersonA&quot;,
     &quot;knows&quot;: [
         {&quot;id&quot;: &quot;PersonB&quot;},
         {&quot;id&quot;: &quot;PersonC&quot;}
     ],
     &quot;is_friends_with&quot;: [
         {&quot;id&quot;: &quot;PersonD&quot;}
     ],
     &quot;likes&quot;: [
         {&quot;id&quot;: &quot;PersonE&quot;}
     ]
}
```

*Importantly*, I can&#39;t hard code the relation types — they could, in theory, be anything!

Any idea? I&#39;ve tried using something like `apoc.map.groupMulti`, but this only allows grouping on node properties, not the relationship type.","1686914440","","","","https://stackoverflow.com/q/76489680","","","Question","Cypher: group nodes by relation type","false","76489680","85",,,,,
"763",":User","","","","","oculardexterity","","","","","","User","","false","21080888","",,,,,
"764",":Question","","2","I have a long chain of relations:

```
:User can have multiple :Territory(ies)
:Account can belong in multiple :Territory(ies)
:Account can be assigned to a multiple :User(s)
:Account can have an :Invoice(s)
:Invoice can have an :InvoiceEntry(ies)
```

To sum up:

    :User-[:BELONGS_TO]-&gt;:Territory&lt;-[:EXISTS_IN]-:Account-[:ISSUED]-&gt;:Invoice-[:HAS]-&gt;:InvoiceEntry

I can simplify the relation to 
```
:User-[:CAN_SEE]-&gt;:Invoice
```

Since I&#39;m not proficient with Cypher, my questions are:

### Question #1. 
What would be the query to refresh the relationships between :User and :Invoice once the :Account is being removed from :Territory and leave valid relationships :CAN_SEE untouched.
### Question #2. 
Same as above but :User is removed from :Territory and can no longer see :Invoice.

## UPDATE 16.06.23

My primary relation chain is `:User -&gt; :Territory &lt;- :Account -&gt; :Invoice`.&lt;br&gt;
`:User -&gt; :Territory` relation is provided by the Active Directory.&lt;br&gt;
`:Account -&gt; :Territory` and `:Account -&gt; Invoice` relations are fetched from ERP system.

In order to avoid costly calculation, because single `:User` can have hundreds of `:Territory` and one `:Account` can be in a hundreds of `:Territory`, I want to introduce a &quot;shortcut&quot; relationship `:User-[:CAN_SEE]-&gt;:Invoice`.

Example case:

`U1` belongs to `T1`, `T2`, `T3`.&lt;br&gt;
`A1` exists in `T1`, `T4`.&lt;br&gt;
`A2` exists in `T3`, `T4`.&lt;br&gt;
`A3` exists in `T1`, `T2`, `T4`.&lt;br&gt;
`A1` issued `I1`.&lt;br&gt;
`A2` issued `I2`.&lt;br&gt;
`A3` issued `I3`. &lt;br&gt;

Here, I would end up having it simplified to:&lt;br&gt;
`U1` can see `I1`, `I2`, `I3`.


### Follow-up to Question #1:&lt;br&gt;

I receive a payload that the ERP detached `A1` and `A3` from `T1`.&lt;br&gt;
I remove `A1-&gt;T1`, `A3-&gt;T1` relationships.&lt;br&gt;
I need to recalculate `[:CAN_SEE]` since U1 loses `[:CAN_SEE]` to `I1` because `U1` to `A1` has no longer valid territory relations. `U1` still can see `I3` because `A3` loses `T1` but `T2` ensures the chain to `I3`.

How would the query look like?

### Follow-up to Question #2:&lt;br&gt;

Active Directory got updated:&lt;br&gt;
`U1` is detached from `T1`.
`U1` is no longer able to see `I1`.

How would the query look like in this situation.

Putting my questions in another words:

I know how to create new relationships based on existing ones. I have trouble understanding how to re-invalidate old ones and remove those if no longer valid.","1686844612","","","","https://stackoverflow.com/q/76483469","","","Question","Recalculating Neo4J relationships based on chain of relationships","false","76483469","105",,,,,
"765",":User","","","","","Lucassith","","","","","","User","","false","3834585","",,,,,
"766",":Question","76482862","2","I am trying to combine the result of two `MATCH` statements.
for example like this

```
MATCH (a)-[:connection]-(b:labelB)
WHERE a.id IN $selection
WITH COLLECT(a) + COLLECT(b) AS selection
```
However, the issue with this is that it produces a list of type `List&lt;node&gt;` instead of `node`. This is an issue because it does not enable another `MATCH` statement using `selection`.
Meaning this would not be possible as a continuation to the query:
```
MATCH (selection)-[]-(c)
RETURN c
```

This behavior can be achieved by a `UNION` but it seems to behave unexpectedly when using the result of the first `MATCH` in the second `MATCH`.

```
MATCH (a)
WHERE a.id IN $selection
RETURN a AS selection
UNION
MATCH (a)-[]-(b)
RETURN b AS selection
``` 

How can I combine two Nodes into a single value?","1686833421","","","","https://stackoverflow.com/q/76482665","","","Question","Combining two results in cypher","false","76482665","30",,,,,
"767",":User","","","","","Abdelsalam ElTamawy","","","","","","User","","false","10660754","",,,,,
"768",":Question","76485346","2","
The docs state:
&gt; Specify the target database on all queries, either with the database_ parameter in Driver.execute_query() or with the database parameter when creating new sessions. If no database is provided, the driver has to send an extra request to the server to figure out what the default database is. The overhead is minimal for a single query, but becomes significant over hundreds of queries.

and gives 2 examples:

    # Good practice
    driver.execute_query(&quot;&lt;QUERY&gt;&quot;, database_=&quot;&lt;DB NAME&gt;&quot;)
    driver.session(database=&quot;&lt;DB NAME&gt;&quot;)

    # Bad practice
    driver.execute_query(&quot;&lt;QUERY&gt;&quot;)
    driver.session()


Does that mean that

    # Good practice
    driver.execute_query(&quot;&lt;QUERY&gt;&quot;, database_=&quot;&lt;DB NAME&gt;&quot;)
    driver.session()

and this 

    # Good practice
    driver.execute_query(&quot;&lt;QUERY&gt;&quot;)
    driver.session(database=&quot;&lt;DB NAME&gt;&quot;)

are good practices or should I specify the database name in `execute_query()` **and** `session()`?
","1686819341","","","","https://stackoverflow.com/q/76480799","","","Question","clarification on Neo4j&#39;s performance good practice","false","76480799","73",,,,,
"769",":User","","","","","Schniddi","","","","","","User","","false","11027812","",,,,,
"770",":Question","","2","I am trying to create node n1 when rv exists and n2 in case not, I declared a variable flag if rv exists. I want to return n1 in case of flag true and n2 in case of false.

Hereby my code:

    WITH rv IS NOT NULL AS flag
    WHERE flag
    CREATE (n1:Test1 {name: &quot;Test1&quot;})
    Return n1
    
    WITH flag
    WHERE NOT flag
    CREATE (n2:Test2 {name: &quot;Test2&quot;})
    Return n2 

","1686811404","","","","https://stackoverflow.com/q/76479788","","","Question","Is there a way to use create and return with cypher cases?","false","76479788","28",,,,,
"771",":User","","","","","Batoul Alsayyed","","","","","","User","","false","19667770","",,,,,
"772",":Question","76471849","1","I want to put a uniqueness constraint on value.path, how can I do it ?

```
{
  &quot;identity&quot;: 16866,
  &quot;labels&quot;: [
    &quot;Component&quot;
  ],
  &quot;properties&quot;: {
    &quot;asset_id&quot;: &quot;&quot;,
    &quot;id&quot;: &quot;ComponentIdentity&quot;,
    &quot;version&quot;: &quot;#head&quot;,
    &quot;value&quot;: &quot;{
            &quot;id&quot;: &quot;f75cb59f-85ce-4247-979a-c8c8784b98d4&quot;,
            &quot;path&quot;: &quot;interactions.json&quot;
        }&quot;
  },
  &quot;elementId&quot;: &quot;16866&quot;
}
```

I have tried

```
CREATE CONSTRAINT ComponentPathUniqueness IF NOT EXISTS
FOR (n:Component)
REQUIRE n.value.path IS NODE UNIQUE
```

But it fails with Invalid input &#39;.&#39;","1686732400","","","","https://stackoverflow.com/q/76471684","","","Question","Is there a way to have neo4j / cypher place constraint on a nested property?","false","76471684","46",,,,,
"773",":User","","","","","Shaurya Gupta","","","","","","User","","false","5777079","",,,,,
"774",":Question","76467684","1","I have a cypher query that works as expected in Neo4j but is failing for me in RedisGraph. 

So I have a query like this:

    MATCH (dp:DataProduct {name: &#39;DataProduct1&#39;})-[:CONTAINS]-&gt;(t:Table {name: &#39;output_table&#39;})-[:HAS_COLUMN]-&gt;(c:Column {name: &#39;foo&#39;})
    RETURN exists((c)-[:TRANSFORMATION]-&gt;())

If column c does not have an outgoing TRANSFORMATION relationship I expect this query to return false. However, in RedisGraph this seems to return true always if the first part of the query matches.

To replicate, run the following cypher:

    MERGE (dp:DataProduct {name: &#39;DataProduct1&#39;}) RETURN dp
    MATCH (dp:DataProduct {name: &#39;DataProduct1&#39;}) MERGE (dp)-[:CONTAINS]-&gt;(t:Table {name: &#39;output_table&#39;})
    MATCH (dp:DataProduct {name: &#39;DataProduct1&#39;})-[:CONTAINS]-&gt;(t:Table {name: &#39;output_table&#39;}) MERGE (t)-[:HAS_COLUMN]-&gt;(c:Column {name: &#39;foo&#39;})
    
    MERGE (dp:DataProduct {name: &#39;DataProduct2&#39;}) RETURN dp
    MATCH (dp:DataProduct {name: &#39;DataProduct2&#39;}) MERGE (dp)-[:CONTAINS]-&gt;(t:Table {name: &#39;input_table&#39;})
    MATCH (dp:DataProduct {name: &#39;DataProduct2&#39;})-[:CONTAINS]-&gt;(t:Table {name: &#39;input_table&#39;}) MERGE (t)-[:HAS_COLUMN]-&gt;(c:Column {name: &#39;bar&#39;})
    
    MATCH (sourceDp:DataProduct {name: &#39;DataProduct2&#39;})-[:CONTAINS]-&gt;(sourceT:Table {name: &#39;input_table&#39;})-[:HAS_COLUMN]-&gt;(sourceC:Column {name: &#39;bar&#39;})
    MATCH (targetDp:DataProduct {name: &#39;DataProduct1&#39;})-[:CONTAINS]-&gt;(targetT:Table {name: &#39;output_table&#39;})-[:HAS_COLUMN]-&gt;(targetC:Column {name: &#39;foo&#39;})
    MERGE (sourceC)-[r:TRANSFORMATION]-&gt;(targetC)
    SET r.type = &#39;function&#39;,
    r.code = &#39;CONCAT(foo and bar)&#39;

This results in this graph:
[![sample graph][1]][1]

So with this data setup, I would expect this query to return true:

    MATCH (dp:DataProduct {name: &#39;DataProduct2&#39;})-[:CONTAINS]-&gt;(t:Table {name: &#39;input_table&#39;})-[:HAS_COLUMN]-&gt;(c:Column {name: &#39;bar&#39;})
    RETURN exists((c)-[:TRANSFORMATION]-&gt;())

And this query to return false:

    MATCH (dp:DataProduct {name: &#39;DataProduct1&#39;})-[:CONTAINS]-&gt;(t:Table {name: &#39;output_table&#39;})-[:HAS_COLUMN]-&gt;(c:Column {name: &#39;foo&#39;})
    RETURN exists((c)-[:TRANSFORMATION]-&gt;())

However, in RedisGraph both return true. In fact if you create some unconnected nodes it even returns true:

    MERGE (dp:DataProduct {name: &#39;DataProduct3&#39;}) RETURN dp
    MATCH (dp:DataProduct {name: &#39;DataProduct3&#39;}) MERGE (dp)-[:CONTAINS]-&gt;(t:Table {name: &#39;whatever&#39;})
    MATCH (dp:DataProduct {name: &#39;DataProduct3&#39;})-[:CONTAINS]-&gt;(t:Table {name: &#39;whatever&#39;}) MERGE (t)-[:HAS_COLUMN]-&gt;(c:Column {name: &#39;foobar&#39;})

So here foobar has neither an incoming nor an outgoing TRANSFORMATION relationship. But still this query returns true:

    MATCH (dp:DataProduct {name: &#39;DataProduct3&#39;})-[:CONTAINS]-&gt;(t:Table {name: &#39;whatever&#39;})-[:HAS_COLUMN]-&gt;(c:Column {name: &#39;foobar&#39;})
    RETURN exists((c)-[:TRANSFORMATION]-&gt;())

Any idea what I am doing wrong?

EDIT:
I have rewritten the query to use count() instead of exists(), this seems to work. Still interested in how to use exists correctly, but just wanted to add this in case anyone out there is running into the same problem.

    MATCH (dp:DataProduct {name: &#39;DataProduct1&#39;})-[:CONTAINS]-&gt;(t:Table {name: &#39;output_table&#39;})-[:HAS_COLUMN]-&gt;(c:Column {name: &#39;foo&#39;})-[:TRANSFORMATION]-&gt;() RETURN COUNT(dp) &gt; 0


  [1]: https://i.stack.imgur.com/hsY7U.png","1686662712","","","","https://stackoverflow.com/q/76465447","","","Question","Exists function in RedisGraph","false","76465447","48",,,,,
"775",":User","","","","","Jonck van der Kogel","","","","","","User","","false","718849","",,,,,
"776",":Question","","1","I have the following cypher query:

`MATCH (group_data:Group)-[]-&gt;(asset_data:Asset)&lt;-[metadata:MD]-(:RawData) RETURN group_data, asset_data, metadata`

but, in some cases, Asset node is not connected to any Group node. I still want to get in this case the aseet_data and the metadata.

thanks!!
","1686653414","","","","https://stackoverflow.com/q/76464135","","","Question","Conditional return in cypher query","false","76464135","42",,,,,
"777",":User","","","","","Yuval Kobel","","","","","","User","","false","8220115","",,,,,
"778",":Question","76434758","1","I have nodes, called Book. Each node have property Name (owner&#39;s name). It&#39;s not a lot of names, a lot of books. How to run aggregate query of all Names, and book quantity per Name?

    Name Book_Count
    Sam  55
    John 12

Database version: 3.5","1686238780","","","","https://stackoverflow.com/q/76433557","","","Question","count nodes per property neo4j database","false","76433557","54",,,,,
"779",":User","","","","","sam sergiy klok","","","","","","User","","false","3394776","",,,,,
"780",":Question","","0","Why are neo4j browser returning different elementId&#39;s on the same nodes?

For example;

```cypher
MATCH (a)
RETURN elementId(a)
```

returns something like;

 - &quot;4:03bd44da-415d-4ed9-a682-7510a61bc8e3:0&quot;
 - &quot;4:03bd44da-415d-4ed9-a682-7510a61bc8e3:1&quot;
 - &quot;4:03bd44da-415d-4ed9-a682-7510a61bc8e3:2&quot;
 - &quot;4:03bd44da-415d-4ed9-a682-7510a61bc8e3:3&quot;

whereas;

```cypher
MATCH (a)
RETURN a
```

returns this;

```
{
  &quot;identity&quot;: 0,
  &quot;labels&quot;: [
    &quot;SomeLabel&quot;
  ],
  &quot;properties&quot;: {
    &quot;SomeProperty&quot;: &quot;Blah&quot;,
  },
  &quot;elementId&quot;: &quot;0&quot;
}
```

For example &quot;4:03bd44da-415d-4ed9-a682-7510a61bc8e3:0&quot; vs &quot;0&quot;.

I would expect the same elementId string.","1686195031","","","","https://stackoverflow.com/q/76428442","","","Question","Why are neo4j browser returning different elementId&#39;s on the same nodes?","false","76428442","175",,,,,
"781",":User","","","","","Kasper","","","","","","User","","false","1027826","",,,,,
"782",":Question","76434660","2","I want to write a cypher query where given a node X, it gives all the parent nodes for that given node until I find the root node which has the type attribute as ROOT.

As an example, I have attached below image where my RootNode is the main parent node and it has attribute *{type: &quot;ROOT&quot;}*.

[![enter image description here][1]][1]
&gt; **Example1:** Find all parent nodes for a node with label *TYPE2:X3*
From the graph we can see, TYPE2:X3 has one parent nodes TYPE2:X1. Now TYPE2:X1 has two parents TYPE1:T1 and RootNode. Recursively, finding parent of TYPE1:T1 which is RootNode. Hence, the answer will be **TYPE1:T1 and TYPE2:X1**

&gt; **Example2:** Find all parent nodes for a node with label *TYPE2:X4*
From the graph we can see, TYPE2:X4 has 4 parent nodes 
**TYPE1:T1, TYPE2:X1, TYPE2:X2, TYPE1:T2** who all have parent as RootNode so the answer will be these 4 nodes.

Please note that my graph can have upto 10 level of parent nodes like this. 


  [1]: https://i.stack.imgur.com/9lrKl.png","1686174712","","","","https://stackoverflow.com/q/76427321","","","Question","Recursively find all parent nodes for a given node in neo4j","false","76427321","231",,,,,
"783",":User","","","","","utkarsh31","","","","","","User","","false","8081281","",,,,,
"784",":Question","","0","I try to call **GraphSage Neo4j GDS** method using **python**. The goal is to perform nodes embedding of an in-memory projected graph. I runned this part of the code: 

    query = &quot;&quot;&quot;CALL gds.beta.graphSage.train(
      &#39;ExperimentsConditionNeighborhood&#39;,
      {
        modelName: &#39;multiLabelModel1&#39;,
        featureProperties: [&#39;final_prot_interet&#39;, &#39;pH&#39;, &#39;temperature&#39;, &#39;glucose&#39;],
        projectedFeatureDimension: 22,
        embeddingDimension: 4,
        randomSeed: 19,
        searchDepth: 2,
        epochs: 25,
       learningrate: 0.001,
       batchSize:30,
       aggregator: &#39;MEAN&#39;,
       sampleSizes: [25, 10],
       activationFunction: &#39;ReLu&#39;,
       tolerance: 1e-5
      }
    )&quot;&quot;&quot;

    conn.query(query, db=db)

I got the following error:

    Query failed: {code: Neo.ClientError.Procedure.ProcedureCallFailed} {message: Failed to invoke procedure `gds.beta.graphSage.train`: Caused by: java.lang.IllegalStateException: No more running tasks}

Any help on that ? 

I found some answers in Java framework, since the error seems to be generated by the Neo4J JVM. But in my case I need a fix on python. 

Just a remark: 
This error message does not appear when I reduce the number of featureProperties. ","1686072306","","","","https://stackoverflow.com/q/76417047","","","Question","Issue with calling GraphSage Neo4j graph embedding method from python driver","false","76417047","78",,,,,
"785",":User","","","","","user22031477","","","","","","User","","false","22031477","",,,,,
"786",":Question","","1","I have 1,000,000 small unrelated graphs in my Neo4j DB. I&#39;d like to input a big graph (as lists of nodes and relationships) and find my unrelated graphs as subgraph of the big graph.

Are there any function or approaches in Cypher (Neo4j) which can simplify this for me? Thanks.

[UPDATE]

Here is an example with 2 graphs in the DB, and a submitted input graph. So, how can I find Graph 1 (from picture) in submitted graph?

![enter image description here][1]

  [1]: https://i.stack.imgur.com/0E07D.png","1686064209","","","","https://stackoverflow.com/q/76416046","","","Question","Find graphs in DB that are subgraphs of an input graph","false","76416046","22",,,,,
"787",":User","","","","","Thesaurus","","","","","","User","","false","19794631","",,,,,
"788",":Question","","2","# Setup

I use an application with Spring Boot `3.1.0` (which brings Spring Data Neo4j `7.1.0`) with a Neo4j database `5.8.0`. Further, I have a node like this:

```java
@Node
@Data
public class SourceNode {
    @Id
    @GeneratedValue(generatorClass = UUIDStringGenerator.class)
    private String uuid;

    @Relationship(type = &quot;RELATION_NAME&quot;, direction = Relationship.Direction.OUTGOING)
    private List&lt;TargetNode&gt; randomRelationName = new ArrayList&lt;&gt;();
}
```

and a repository with custom CYPHER queries like this:

```java
public interface SourceNodeRepository extends CrudRepository&lt;SourceNode, String&gt; {
    @Query(&quot;MATCH (s:SourceNode) RETURN s{.uuid}&quot;)
    List&lt;SourceNode&gt; getAllWithoutRelations();

    @Query(&quot;MATCH (s:SourceNode) RETURN s{.uuid, __elementId__: toString(id(s))}&quot;)
    List&lt;SourceNode&gt; getAllWithoutRelationsFixed();
}
```

# Question

When I execute `getAllWithoutRelations()` to fetch the source nodes without intentionally mapping the relations, I get:

```
org.springframework.data.mapping.MappingException: Error mapping Record&lt;{role: {uuid: &quot;xxxxx&quot;}}&gt;
...
Caused by: java.util.NoSuchElementException: No value present
```

Is it a bug in Spring Data Neo4j `7.1.0` or how can I prevent this problem properly?

When using Spring Boot `3.0.6` bringing Spring Data Neo4j `7.0.5` the query execution works without problems.

# Ugly Workaround

I found out, that the problem relates to the source node&#39;s internal Neo4j ID, which cannot be determined based on the actual query when executing the custom query. By adding `__elementId__: toString(id(s))` (see repository method `getAllWithoutRelationsFixed()`) to the return object, the problem can be solved, but I doubt that this is a good solution.","1685968839","","","","https://stackoverflow.com/q/76406516","","","Question","Error mapping node with custom CYPHER RETURN leaving out relations in SDN 7.1.0","false","76406516","231",,,,,
"789",":User","","","","","sdm4n","","","","","","User","","false","15354138","",,,,,
"790",":Question","","2","I have a query already written which returns some result

    MATCH(n:Prop)
    		WHERE toLower(n.Type)=toLower(&quot;abc&quot;) 
    		WITH n.Id AS id, n
        	MATCH (new:op)
    		WHERE new.Id STARTS WITH id
    		WITH new,n 
    		MATCH (o:`here`)-[:Property]-&gt;(new) 
    		WHERE (o:Obj) 
        	WITH Count(DISTINCT o) AS languages,n,new
    	return count(n)

This returns me count 6 which is expected
But since I want the id as well I change the query as

    MATCH(n:Prop)
    		WHERE toLower(n.Type)=toLower(&quot;abc&quot;) 
    		WITH n.Id AS id, n
        	MATCH (new:op)
    		WHERE new.Id STARTS WITH id
    		WITH new,n 
    		MATCH (o:`here`)-[:Property]-&gt;(new) 
    		WHERE (o:Obj) 
        	WITH Count(DISTINCT o) AS languages,n,new
    	return count(n), id(n)

The problem with this is that I get the count as one with each id but I want the totalCount which was 6 only with each row

I have tried many different things but couldnt get what I want.
","1685967634","","","","https://stackoverflow.com/q/76406355","","","Question","Not able to use COUNT properly in cypher query","false","76406355","51",,,,,
"791",":Question","","1","I have a tree-like structure involving &quot;Blocks&quot;, which are connected to other Blocks by &quot;NEXT_BLOCK&quot; or &quot;BLOCK_CHILD&quot;. A node can have at most one BLOCK_CHILD and one NEXT_BLOCK, and this can recursively repeat itself.

![node structure](https://i.stack.imgur.com/cqTbz.png)

While I can get all the blocks from the starter node simply by running the following cypher, I would like to get the data in a specific data format.


```
MATCH (n:Node {id: $nodeId})-[r:NEXT_BLOCK|BLOCK_CHILD*0..]-(b:BLOCK_ELEMENT|BLOCK_INLINE)
RETURN n, r, b

```

I need to efficiently get this tree of data as an array where each &#39;Next block&#39; is the next element in the array, while everything that&#39;s part of &#39;BLOCK_CHILD&#39; (including its next nodes) is encapsulated within a children field which is also an array. So the example above would be given as

```
[
  {
  id : &quot;4fa9125..&quot;
  children : [{text: &quot;&quot;}]
  }, 
  {
  id : &quot;66fb771..&quot;
  children : [
                    {
                      id: &quot;466a6a&quot;
                      children: [{id: &quot;5498a3&quot;}]
                    },
                    {
                      id: &quot;90753...&quot;
                      children: []
                    },
              ]
  }, 
  {
  id : &quot;12258d5..&quot;
  children : [{id: &quot;97b56a&quot;}]
  }, 
]
```

The organisation can still change if my nodes have a better structural design. These need to be correctly ordered and the order will frequently change though.

I appreciate the help!

I&#39;ve tried using APOC.convertToTree as an example below.

```
MATCH path = (n {id: &quot;eecd1592-d41b-4b3c-aaa1-16562d808ecc&quot;})-[r:BLOCK_CHILD|NEXT_BLOCK*0..]-&gt;(p)
WITH collect(path) AS paths
CALL apoc.convert.toTree(paths)
YIELD value
RETURN value;
```

I&#39;ve also tried some structural changes such as storing the json object, but as it frequently is changed and blocks are consistently cross referenced I didn&#39;t want to simply store the entire content as a string. ","1685710005","","","","https://stackoverflow.com/q/76390282","","","Question","Returning formatted json querying a tree with two different relationships (cypher)","false","76390282","53",,,,,
"792",":User","","","","","jli","","","","","","User","","false","16617343","",,,,,
"793",":Question","76380516","1","I have a list of `User` emails and I need to get all of them with their `Team` membership. Both `Users` with `Teams` and those who are not members of any `Team`. I have a query for that which is:

```
  MATCH (u:User)
  WHERE (u.email in $userEmails)
  OPTIONAL MATCH (u)-[r:MEMBER_OF]-(t:Team)
  RETURN r, u, t;
```

The problem I have is that I would also want to exclude a list of `Teams` in my query. When I tried this:

```
  MATCH (u:User)
  WHERE (u.email in $userEmails)
  OPTIONAL MATCH (u)-[r:MEMBER_OF]-(t:Team)
  WHERE NOT (t.id in $excludedTeamIds)
  RETURN r, u, t;
```

The result was the same list of `Users`, but their `relation` to the `Team` was just missing. I would want to remove both - the `User` and the `Team` from the result.","1685601642","","","","https://stackoverflow.com/q/76379275","","","Question","Filtering out optional matches or results in cypher query","false","76379275","64",,,,,
"794",":User","","","","","Michał J. Gąsior","","","","","","User","","false","1923409","",,,,,
"795",":Question","76378562","1","I&#39;m confused how neo4j query work.

If I have 10 nodes in my graph DB (7 Customer nodes + 3 Product nodes)

Now, I want to query a customer node(ex: C1), what&#39;s the time complexity?

And how the query work ? Like hash table O(1)? Or like binary search O(logN) ?","1685585122","","","","https://stackoverflow.com/q/76378251","","","Question","What&#39;s the time complexity of query a node in neo4j?","false","76378251","71",,,,,
"796",":User","","","","","Josh-money","","","","","","User","","false","21443513","",,,,,
"797",":Question","","1","## Intro

This what an existing query of mine looks like:

```
MATCH
(p:Person { id: $p_id })-[k1:`KNOWS`]-&gt;(person:Person)
WHERE (// some criteria)
MATCH
(person)-[work:`WORKED_AT`]-&gt;(company:Company)
WHERE (work.title contains “Product Manager&quot; and work.start_date is not null)
WITH person, work
RETURN
DISTINCT person.full_name, work.title
```

The problem in the above query is that it is not case insensitive. So the above query fails if the actual title is `product manager` in the database.

So we are trying to use [full text search index][1]. We created the index on the `:work` relationship, and we verified that it works, for example the search of:


```
call db.index.fulltext.queryRelationships(“&lt;indexName&gt;”, “CEO”) 
yield relationship return reltionship.title limit 10
```
would return stuff like:

```
CEO
Ceo
..etc
```

## Question
How can I apply the above index search on the node search? For example:

```
MATCH
(p:Person { id: $p_id })-[k1:`KNOWS`]-&gt;(person:Person)
WHERE (// some criteria)
MATCH
(person)-[work:`WORKED_AT`]-&gt;(company:Company)
WHERE //apply the db.index.fulltext.queryRelationships here on :work somehow
WITH person, work
RETURN
DISTINCT person.full_name, work.title
```


  [1]: https://neo4j.com/docs/cypher-manual/current/indexes-for-full-text-search/","1685529438","","","","https://stackoverflow.com/q/76372597","","","Question","How to efficiently use a fulltext index to search based on prior MATCH results in same query","false","76372597","121",,,,,
"798",":User","","","","","abbood","","","","","","User","","false","766570","",,,,,
"799",":Question","","1","I&#39;m using Memgraph (but open to using Neo4j) and need some help on building a recursive query to build out a tree. I&#39;m new to Cypher so my attempts so far haven&#39;t been successful. I&#39;ve played around with the CALL subqueries but can&#39;t seem to get the format and ordering right. 

My goals are:

1. Be able to fetch a Node, and its direct edges - but the edges should be limited to a certain number sorted by a edge property value. E.g. Get Node A and 3 of its edges ordered by property X.
2. Be able to fetch a Node, and based on some variable be able to specify the depth to &quot;walk&quot; to tree. E.g. Get Node A, and for each of its 3 edges (sorted by X), get those edge&#39;s edges the using the same filter function, up to the depth limit. Bonus points if it can filter out the parent node so it&#39;s only a directed tree. 

Some concrete examples - given the following graph. Note this is not real data and I&#39;m aware the &quot;age&quot; property is not symmetrical between Nodes. Just threw it together for the question. 

    CREATE (n0:Node {name: &quot;a&quot;}) CREATE (n1:Node {name: &quot;b&quot;}) CREATE (n2:Node {name: &quot;c&quot;}) CREATE (n3:Node {name: &quot;d&quot;}) CREATE (n4:Node {name: &quot;e&quot;}) CREATE (n5:Node {name: &quot;f&quot;}) CREATE (n6:Node {name: &quot;g&quot;}) CREATE (n7:Node {name: &quot;h&quot;}) CREATE (n8:Node {name: &quot;i&quot;}) CREATE (n9:Node {name: &quot;j&quot;});
    CREATE (n0)-[:KNOWN_FOR {age: 20} ]-&gt;(n2) CREATE (n0)-[:KNOWN_FOR {age: 7} ]-&gt;(n1) CREATE (n0)-[:KNOWN_FOR {age: 15} ]-&gt;(n4) CREATE (n0)-[:KNOWN_FOR {age: 23} ]-&gt;(n3) CREATE (n0)-[:KNOWN_FOR {age: 5} ]-&gt;(n7) CREATE (n1)-[:KNOWN_FOR {age: 10} ]-&gt;(n6) CREATE (n1)-[:KNOWN_FOR {age: 14} ]-&gt;(n2) CREATE (n1)-[:KNOWN_FOR {age: 24} ]-&gt;(n3) CREATE (n1)-[:KNOWN_FOR {age: 19} ]-&gt;(n5) CREATE (n2)-[:KNOWN_FOR {age: 24} ]-&gt;(n8) CREATE (n2)-[:KNOWN_FOR {age: 25} ]-&gt;(n3) CREATE (n2)-[:KNOWN_FOR {age: 17} ]-&gt;(n1) CREATE (n3)-[:KNOWN_FOR {age: 7} ]-&gt;(n4) CREATE (n3)-[:KNOWN_FOR {age: 10} ]-&gt;(n7) CREATE (n3)-[:KNOWN_FOR {age: 25} ]-&gt;(n6) CREATE (n3)-[:KNOWN_FOR {age: 22} ]-&gt;(n1)CREATE (n4)-[:KNOWN_FOR {age: 21} ]-&gt;(n0) CREATE (n4)-[:KNOWN_FOR {age: 24} ]-&gt;(n6) CREATE (n4)-[:KNOWN_FOR {age: 17} ]-&gt;(n8) CREATE (n5)-[:KNOWN_FOR {age: 14} ]-&gt;(n9) CREATE (n5)-[:KNOWN_FOR {age: 8} ]-&gt;(n0) CREATE (n5)-[:KNOWN_FOR {age: 15} ]-&gt;(n8) CREATE (n5)-[:KNOWN_FOR {age: 18} ]-&gt;(n6) CREATE (n5)-[:KNOWN_FOR {age: 22} ]-&gt;(n4) CREATE (n6)-[:KNOWN_FOR {age: 7} ]-&gt;(n4) CREATE (n6)-[:KNOWN_FOR {age: 21} ]-&gt;(n2) CREATE (n7)-[:KNOWN_FOR {age: 25} ]-&gt;(n3) CREATE (n8)-[:KNOWN_FOR {age: 18} ]-&gt;(n7) CREATE (n8)-[:KNOWN_FOR {age: 12} ]-&gt;(n3) CREATE (n9)-[:KNOWN_FOR {age: 14} ]-&gt;(n4) CREATE (n9)-[:KNOWN_FOR {age: 15} ]-&gt;(n3) CREATE (n9)-[:KNOWN_FOR {age: 7} ]-&gt;(n2) CREATE (n9)-[:KNOWN_FOR {age: 14} ]-&gt;(n8);

[![Example Graph][1]][1]

Examples

Get Node A and 3 of its children ordered by KNOWN_FOR age desc, where age &gt; 5. Should return:

    A -&gt;
      - D (age: 23)
      - C (age: 20)
      - E (age: 15)

Get Node A, and its children to a depth of 3, where its children have a limit of 2 order by age desc. Should return: 

    A 
      -&gt; D (age: 23)
        -&gt; G (age: 25)
          -&gt; C (age: 21)
          -&gt; E (age: 7)
        -&gt; B (age: 22)
          -&gt; D (age: 24)
          -&gt; F (age: 19)
      -&gt; C (age: 20)
        -&gt; D (age: 25)
          -&gt; G (age: 25)
          -&gt; B (age: 22)
        -&gt; I (age: 24)
          -&gt; H (age: 18)
          -&gt; D (age: 12)
      -&gt; E (age: 15)
        -&gt; G (age: 24)
          -&gt; C (age: 21)
          -&gt; E (age: 7)
        -&gt; A (age: 21)
          -&gt; D (age: 23)
          -&gt; C (age: 20)

I don&#39;t mind to much on the format of the return data, as long as it includes the nodes and relationship value between them. Something as simple as this is ideal: 

    A, D, 23
    D, G, 25

But if its a nested array, I can parse it out on the function that wraps the query. 


  [1]: https://i.stack.imgur.com/pVuj2.png","1685419019","","","","https://stackoverflow.com/q/76361528","","","Question","Memgraph cypher recursive tree with depth and filtering query","false","76361528","229",,,,,
"800",":User","","","","","NathanS","","","","","","User","","false","1642540","",,,,,
"801",":Question","","1","I am running a simple query on neo4j in an enterprise system. I have been using neo4j for last 3-4 months. So have basic familiarity of cypher queries etc. I am using neo4j browser using Chrome. While working , all of a sudden if I write a simple Cypher query such as &quot;MATCH (c:mynode) return c limit 5&quot; , the result does not show any nodes in &quot;Graph display&quot; window. However the &quot;Table&quot;,&quot;Text&quot; and &quot;Code&quot; view is displaying results easily. I never had this problem in last 3-4 months that display vanishes all of a sudden.. Tried many things in settings etc..nothing seems to work.. any possible reason for the same?

Tried :reset style, was expecting the nodes would display again as it does normally in graph view. Did not display. All those nodes are however showing in Tables, Text and Code view.","1685393962","","","","https://stackoverflow.com/q/76360295","","","Question","Why aren&#39;t nodes displaying in neo4j graph view when they show up in Table and Text view?","false","76360295","246",,,,,
"802",":User","","","","","DBA_WORLD 2016","","","","","","User","","false","21981763","",,,,,
"803",":Question","","2","I&#39;m use cypher to count the number of paths between two nodes.  I have this query:

    MATCH p=(a)-[*1..2]-(b)
    where ID(a) = &quot;node1&quot;
    and ID(b) = &quot;node2&quot;
    return COUNT(p)

However, many of my nodes have multiple links to the same node with different relationship types.  I&#39;d like to ONLY count the distinct paths regardless of the relationship type.  

For example, the paths returned may be as follows:

    (node1)-[rel_type_a]-(node3)-[rel_type_b]-(node2) 
    (node1)-[rel_type_c]-(node3)-[rel_type_d]-(node2) 
    (node1)-[rel_type_e]-(node3)-[rel_type_f]-(node2) 
The query above counts this as 3 paths, but I only want to count this as a single path since all of the nodes are are the same, I&#39;m not interested in the relationship types.

Thanks in advance!
","1706903603","","","","https://stackoverflow.com/q/77929550","","","Question","cypher: Count distinct paths between two nodes disregarding link type","false","77929550","16",,,,,
"804",":User","","","","","xygonyx","","","","","","User","","false","7009395","",,,,,
"805",":Question","","0","I have this code, but am confused about how to convert it to php-cypher-dsl! even ChatGPT doesn&#39;t know LOL
BTW: the documentation does not cover all aspects of this great lib, is there another doc?

```
                MATCH (node)-[r]-&gt;(c)
                where 
                (labels(c)[0] = &quot;SubCategoryM&quot; or labels(c)[0] = &quot;CategoryM&quot;)
                and (c.status=1 OR c.status=&quot;1&quot;) 
                and id(node)=$node_id
                return 
                id(c) as id,
                c.name as name,
                c.slug as slug
```

https://github.com/neo4j-php/php-cypher-dsl

Thank you","1704808565","","","","https://stackoverflow.com/q/77787297","","","Question","How to convert labels(c)[0] in Neo4j cypher query to a PHP cypher DSL?","false","77787297","26",,,,,
"806",":User","","","","","user1402259","","","","","","User","","false","1402259","",,,,,
"807",":Question","77357928","2","I have a list of capital cities. I want to see if I have all of them. How can I see which cities I don&#39;t have inside? My query looks like this at the moment:

    OPTIONAL MATCH (n:Captial {name: &#39;London&#39;})
    RETURN n.name
    UNION
    OPTIONAL MATCH (n:Captial {name: &#39;Paris&#39;})
    RETURN n.name
    UNION
    OPTIONAL MATCH (n:Captial {name: &#39;Berlin&#39;})
    RETURN n.name
    UNION
    OPTIONAL MATCH (n:Captial {name: &#39;Rome&#39;})
    RETURN n.name

This doesn&#39;t seem elegant and on top of everything as a result I get:

    London
    Paris
    Berlin
    null

To me it means that I don&#39;t have Rome in my database. But can the output be `Rome` only, and not list off all cities that are there and `null` for one that isn&#39;t there?
","1698215074","","","","https://stackoverflow.com/q/77357033","","","Question","How can I list only nodes that were not found using Cypher?","false","77357033","35",,,,,
"808",":User","","","","","TenTonBonton","","","","","","User","","false","21507344","",,,,,
"809",":Question","77322859","1","I&#39;m a bit confused by graph traversing queries. After executing:

```
CREATE (:Node {id: 0});
CREATE (:Node {id: 1});
CREATE (:Node {id: 2});
CREATE (:Node {id: 3});
MATCH (n:Node {id: 0}), (m:Node {id: 1})
CREATE (n)-[:LINK {date: &quot;2023-03&quot;}]-&gt;(m);
MATCH (n:Node {id: 1}), (m:Node {id: 2})
CREATE (n)-[:LINK {date: &quot;2023-03&quot;}]-&gt;(m);
MATCH (n:Node {id: 2}), (m:Node {id: 3})
CREATE (n)-[:LINK {date: &quot;2023-03&quot;}]-&gt;(m);
```

I want to find paths between Node with id 0 and Node with id 3, so I run next query:

```
MATCH p = (:Node {id:&quot;0&quot;})-[*]-&gt;(:Node {id: &quot;3&quot;})
RETURN p;
```

and this will return an empty set.
Isn&#39;t it supposed to return all paths between these two nodes?
","1697694884","","","","https://stackoverflow.com/q/77321256","","","Question","Graph traversing query returns no results","false","77321256","24",,,,,
"810",":User","","","","","EWoodAv","","","","","","User","","false","21257965","",,,,,
"811",":Question","77258091","2","I&#39;m currently testing Memgraph(2.11.0) in docker. I have successfully imported my CYPHERL file via Memgraph Lab. However, it&#39;s very hard to read and maintain. Is it possible to improve that? Is there a document on the format any where?

Here&#39;s example of the CYPHERL file I have except that the WHERE clause in the real thing is longer.

```
CREATE (:EndPoint {service: &quot;x-svc&quot;, owner: &quot;x&quot;, method: &quot;POST&quot;, path: &quot;accounts/&quot;});
CREATE (:EndPoint {service: &quot;y-svc&quot;, owner: &quot;y&quot;, method: &quot;GET&quot;, path: &quot;wallets/&quot;});
CREATE (:EndPoint {service: &quot;z-svc&quot;, owner: &quot;z&quot;, method: &quot;GET&quot;, path: &quot;files/&quot;});
CREATE (:DataSource {type: &quot;mysql&quot;, name: &quot;acc-db&quot;});
MATCH (e:EndPoint), (e2:EndPoint) WHERE e.service = &quot;x-svc&quot; AND e.path = &quot;accounts/&quot; AND e2.service = &quot;y-svc&quot; AND e2.path = &quot;wallets/&quot; CREATE (e)-[:IS_CALLING]-&gt;(e2); 
MATCH (e:EndPoint), (d:DataSource) WHERE e.service = &quot;x-svc&quot; AND e.path = &quot;accounts/&quot; AND d.name = &quot;acc-db&quot; CREATE (e)-[:READ_FROM]-&gt;(d);
MATCH (e:EndPoint), (e2:EndPoint) WHERE e.service = &quot;y-svc&quot; AND e.path = &quot;wallets/&quot; AND e2.service = &quot;z-svc&quot; AND e2.path = &quot;files/&quot; CREATE (e)-[:IS_CALLING]-&gt;(e2); 
```","1696781337","","","","https://stackoverflow.com/q/77254345","","","Question","How to make CYPHERL file more human readable?","false","77254345","71",,,,,
"812",":User","","","","","RobGThai","","","","","","User","","false","271736","",,,,,
"813",":Question","77191320","2","Given the following graph (where all relationships have the `FOLLOWS` type), how can we get the results such that they are grouped according to previous and next node(s) of a given node?

```
 H-&gt;G-&gt;E-&gt;D
     -&gt;F
```

- Where H follows G 
- Where G follows both E &amp; F. 
- E follows D

So given some property of G, expecting results in the form:
`[{H}, {G}, {E, F}, {D}]`

Tried:
```
MATCH (prev:Person)&lt;-[:FOLLOWS *0..]-(p:Person)&lt;-[:FOLLOWS *0..]-(next:Person) WHERE p.name =&#39;G&#39; RETURN collect(prev), p, collect(next) as result
```

","1695841952","","","","https://stackoverflow.com/q/77190279","","","Question","Grouping Cypher query results by direct relationships","false","77190279","56",,,,,
"814",":User","","","","","Lisvar27","","","","","","User","","false","22646786","",,,,,
"815",":Question","77208534","1","We are translating a Neo4j cypher query to PHP cypher DSL (Domain-Specific Language) using [the php-cypher-dsl library](https://github.com/neo4j-php/php-cypher-dsl/) to have more flexibility. 

We struggle with this because the library&#39;s documentation is not really explaining how to use it in much detail. Given that we have a plain query in cypher Neo4j:

    MATCH (a:Resource), (b:Resource) 
    WHERE a.uri = $uri AND b.uri = $object
    CREATE (a)-[r:{$propertyUri}]-&gt;(b)
    RETURN type(r)

**How can we translate this Neo4j cypher query to PHP cypher DSL?**
","1695553893","","","","https://stackoverflow.com/q/77166834","","","Question","How can I translate this Neo4j cypher query to a PHP cypher DSL?","false","77166834","60",,,,,
"816",":User","","","","","Victor Donet","","","","","","User","","false","2063104","",,,,,
"817",":Question","","1","The `neo4j-admin` tool can import data from CSV.  [One of the options][1] it takes is:

[1]: https://neo4j.com/docs/operations-manual/4.4/tools/neo4j-admin/neo4j-admin-import/#import-tool-option-normalize-types

&gt;
&gt;
&gt;`--normalize-types[=&lt;true/false&gt;]`
&gt;
&gt;    Determines whether or not to normalize property types to Cypher types, e.g. `int` becomes `long` and `float` becomes `double`.
&gt;
&gt;    Default: `true`


If I don&#39;t explicitly set `--normalize-types=false`, then the `neo4j-admin` tool produces messages like this:

```
Property type of &#39;foo&#39; normalized from &#39;int&#39; --&gt; &#39;long&#39; in /path/to/my-nodes.csv
```


My database has billions of properties, so I&#39;d like to save space (and RAM) if possible. I know that the integer properties fit within 32 bits, and I don&#39;t need 64-bit precision for floating-point properties.  (See [this reference][2] for the bit-width of each property type.)

[2]: https://neo4j.com/docs/java-reference/4.4/java-embedded/property-values/

### What are the tradeoffs of normalizing the types vs. not normalizing?

For example, do narrower types actually save space/RAM?  Are they somehow incompatible with Cypher queries?","1695424907","","","","https://stackoverflow.com/q/77161091","","","Question","neo4j: What are the tradeoffs of --normalize-types=false?","false","77161091","30",,,,,
"818",":User","","","","","Stuart Berg","","","","","","User","","false","162094","",,,,,
"819",":Question","77225280","2","So I have a system whereby I will be handed in cypher queries to do specific operations (e.g. create a new node) as part of a pipeline. 

The question I have, is that I would like to add additional properties and labels to this query that has been handed in to a process before it sends it off to the database (Neo4j) , but I would like to avoid a complex string parsing/update exercise.

For example, I may be given something like this:

```CREATE (:testnode {tag_str: \&quot;CgESpOVg\&quot;})```

But I want to add additional system (i.e. source process outside of the databse) provided properties and labels to this node creation _before_ we hand it off to Neo4J.

Is there a way to do this without having to modify the original query, but instead just &quot;bolting&quot; on to it at the end?

As an obviously nonworking example, something like as follows?

```CREATE (newnode:testnode {tag_str: \&quot;mytag\&quot;}) + &lt;additional property foobar: usefuldata on variable new node&gt;```

The WITH clause sounds promising, but thus far I have not been able to make it work.



 ","1695421153","","","","https://stackoverflow.com/q/77160928","","","Question","Modifying cypher query with additional properties and labels","false","77160928","47",,,,,
"820",":User","","","","","I.F. Adams","","","","","","User","","false","2852481","",,,,,
"821",":Question","77132469","2","Ideally I want `toFixed` function in JavaScript https://www.w3schools.com/jsref/jsref_tofixed.asp I know I can do this with Cypher like below.

    WITH 3 AS inputNumber
    RETURN
      CASE
        WHEN inputNumber &lt; 10 THEN &#39;0&#39; + toString(inputNumber)
        ELSE toString(inputNumber)
      END AS formattedString;

but a simple APOC function would be better","1695106416","","","","https://stackoverflow.com/q/77132269","","","Question","Converting an integer to a fixed-length string with leading zeros","false","77132269","60",,,,,
"822",":User","","","","","canbax","","","","","","User","","false","3209523","",,,,,
"823",":Question","","1","I have this Cypher query that I have written.

```
MATCH (grade:Grade:`2547`:Transaction WHERE grade.NodeID=&quot;2547:12117:000:6839&quot; or grade.NodeID=&quot;2547:12117:000:6841&quot; or grade.NodeID=&quot;2547:12117:000:6840&quot; or grade.NodeID=&quot;2547:12117:000:6843&quot; or grade.NodeID=&quot;2547:12117:000:6842&quot; or grade.NodeID=&quot;2547:12117:000:6845&quot; or grade.NodeID=&quot;2547:12117:000:6844&quot; or grade.NodeID=&quot;2547:12117:000:6838&quot;)-[vGrade:Version
WHERE vGrade.Status = &quot;1&quot;]-&gt;(grade:`2547`:Grade:Transaction)&lt;-[rGrade:Grade
WHERE rGrade.Status = &quot;1&quot;]-(n:User:`2547`:Transaction)
WITH n, grade, vGrade.Document as GradeDocument
MATCH (LegalEntity:LegalEntity:`2547`:Transaction WHERE LegalEntity.NodeID=&quot;2547:12106:000:6167&quot; or LegalEntity.NodeID=&quot;2547:12106:000:5754&quot;)-[vLegalEntity:Version
WHERE vLegalEntity.Status = &quot;1&quot;]-&gt;(LegalEntity:`2547`:LegalEntity:Transaction)&lt;-[rLegalEntity:LegalEntity
WHERE rLegalEntity.Status = &quot;1&quot;]-(n:User:`2547`:Transaction)
WITH n, grade, GradeDocument, LegalEntity, LegalEntityDocument
RETURN n, Grade, GradeDocument, LegalEntity, LegalEntityDocument
```

I need to find all those User nodes that are related to a given set of Grade ids and LegalEntity ids. The output of the query is as required. but I would like to know if there is any way that the performance of this query could be improved, as this is one of the queries that I&#39;m generating. But the general structure of all the queries would be like this only. The number of nodeIDs in the MATCH statements in the above query are just an example, the actual number of the nodeIDs could vary, but that is being handled by the code and the resulting structure is same as above. Also, the number of match statements could also increase as per requirement.

[![Example of how the relationship exists in neo4j](https://i.stack.imgur.com/Auwtl.png &quot;Example of how the relationship exists in neo4j&quot;)](https://i.stack.imgur.com/Auwtl.png)

Currently, the query is taking 10-14 seconds and the output is correct(result has a bit more than 9500 records). Is there any way in which the execution time of the query be decreased?","1694973246","","","","https://stackoverflow.com/q/77123006","","","Question","Optimizing a Cypher query in Neo4j","false","77123006","64",,,,,
"824",":Tag","","","","","","true","","https://stackoverflow.com/questions/tagged/neo4j","neo4j","","Question","","false","","",,,,,
"825",":Tag","","","","","","true","","https://stackoverflow.com/questions/tagged/neodash","neodash","","Question","","false","","",,,,,
"826",":Tag","","","","","","true","","https://stackoverflow.com/questions/tagged/cypher","cypher","","Question","","false","","",,,,,
"827",":Answer","","","Try to set like this:
```
MATCH (n:NodeA),(additionalDate:AdditionalDate)
WHERE (n.Id = &quot;xxxx1111xxxx11&quot;)
AND (additionalDate.DateType = &quot;1&quot;)
CREATE (additionalDate)-[additionalDateOf:AdditionalDateOf]-&gt;(n)
SET additionalDateOf.Value = &quot;2024-02-06T11:16:02.09Z&quot;
```
For:
```
MERGE (n:NodeA {Id:&quot;xxxx1111xxxx11&quot;})
MERGE (additionalDate:AdditionalDate {DateType:&quot;1&quot;}) 
```
If I add a return to the query above I get:
```
╒═══════════════════════════════╤═════════════════════════════════╤══════════════════════════════════════════════════════╕
│n                              │additionalDate                   │additionalDateOf                                      │
╞═══════════════════════════════╪═════════════════════════════════╪══════════════════════════════════════════════════════╡
│(:NodeA {Id: &quot;xxxx1111xxxx11&quot;})│(:AdditionalDate {DateType: &quot;1&quot;})│[:AdditionalDateOf {Value: &quot;2024-02-06T11:16:02.09Z&quot;}]│
└───────────────────────────────┴─────────────────────────────────┴──────────────────────────────────────────────────────┘
```","","","true","false","https://stackoverflow.com/a/77956188","","0","Question","Create Node and Set a value in a relationship Neo4j","false","77956188","",,,,,
"828",":Answer","","","As @nimrod-serok suggests, you can use the dot property reference syntax to set the `Value` property of `additionalDateOf`. 

Alternatively, you can just remove the double quotes from the key:
```lang-cypher
MATCH (n:Node),(additionalDate:AdditionalDate)
WHERE (n.Id = &quot;xxxx1111xxxx11&quot;)
AND (additionalDate.DateType = &quot;1&quot;)
CREATE (additionalDate)-[additionalDateOf:AdditionalDateOf]-&gt;(n)
SET additionalDateOf = {
  Value: &quot;2024-02-06T11:16:02.09Z&quot;
}
```
The property key-values you are assigning to the relationship are a map where the keys are identifiers. You were using the JSON data format where the keys are specified as strings.

As a third option, you can inline the property specification in the `CREATE` clause:
```lang-cypher
MATCH (n:Node),(additionalDate:AdditionalDate)
WHERE (n.Id = &quot;xxxx1111xxxx11&quot;)
AND (additionalDate.DateType = &quot;1&quot;)
CREATE (additionalDate)-[additionalDateOf:AdditionalDateOf 
                          {Value: &quot;2024-02-06T11:16:02.09Z&quot;}]-&gt;(n)
```","","","true","false","https://stackoverflow.com/a/77956303","","0","User","Create Node and Set a value in a relationship Neo4j","false","77956303","",,,,,
"829",":User","","","","","Finbar Good","","","","","","User","","false","2258090","",,,,,
"830",":Answer","","","To add to @FinbarGood&#39;s answer, you may want to use [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) instead of [CREATE](https://neo4j.com/docs/cypher-manual/current/clauses/create/) in order to avoid creating duplicate relationships:

    MATCH (n:Node), (additionalDate:AdditionalDate)
    WHERE (n.Id = &quot;xxxx1111xxxx11&quot;) AND (additionalDate.DateType = &quot;1&quot;)
    MERGE (additionalDate)-[additionalDateOf:AdditionalDateOf]-&gt;(n)
    ON CREATE
      SET additionalDateOf = {
        Value: &quot;2024-02-06T11:16:02.09Z&quot;
      }","","","true","false","https://stackoverflow.com/a/77956529","","0","Tag","Create Node and Set a value in a relationship Neo4j","false","77956529","",,,,,
"831",":User","","","","","cybersam","","","","","","User","","false","974731","",,,,,
"832",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/langchain","langchain","","Tag","","false","","",,,,,
"833",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/vector-search","vector-search","","Tag","","false","","",,,,,
"834",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/graph-databases","graph-databases","","Tag","","false","","",,,,,
"835",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-apoc","neo4j-apoc","","Tag","","false","","",,,,,
"836",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/graph-data-science","graph-data-science","","Tag","","false","","",,,,,
"837",":Comment","","","","","","true","","https://stackoverflow.com/questions/77946019/neo4j-cypher-query-doublenan-issue#comment137417071_77946019","","0","Tag","","false","137417071","",,,,,
"838",":Comment","","","","","","true","","https://stackoverflow.com/questions/77946019/neo4j-cypher-query-doublenan-issue#comment137417269_77946019","","0","User","","false","137417269","",,,,,
"839",":Comment","","","","","","true","","https://stackoverflow.com/questions/77946019/neo4j-cypher-query-doublenan-issue#comment137422924_77946019","","0","Question","","false","137422924","",,,,,
"840",":Comment","","","","","","","","https://stackoverflow.com/questions/77946019/neo4j-cypher-query-doublenan-issue#comment137427192_77946019","","1","Comment","","false","137427192","",,,,,
"841",":Answer","","","You can use two [CALL subqueries](https://neo4j.com/docs/cypher-manual/current/subqueries/call-subquery/):

    MATCH (n:Thing) WHERE &lt; complicated list of conditions &gt;
    WITH COLLECT(n) AS list
    CALL {
      WITH list
      UNWIND list AS x
      WITH x
      ORDER BY x.label LIMIT 25
      RETURN COLLECT(x) AS list1
    }
    CALL {
      WITH list
      UNWIND list AS y
      MATCH (m:RelatedThing)-[:Relationship]-(y)
      WITH DISTINCT m
      ORDER BY m.label LIMIT 25
      RETURN COLLECT(m) AS list2
    }
    RETURN list1, list2

#### For very old neo4j versions without CALL subquery

The APOC procedure `apoc.cypher.run` has been supported for a long time, and can be used instead of the more recent `CALL subquery` feature:

    MATCH (n:Thing) WHERE &lt; complicated list of conditions &gt;
    WITH COLLECT(n) AS list
    CALL apoc.cypher.run(&quot;
      UNWIND list AS x
      WITH x
      ORDER BY x.label LIMIT 25
      RETURN COLLECT(x) AS list1&quot;,
      {list: list}
    ) YIELD value as val1
    CALL apoc.cypher.run(&quot;
      UNWIND list AS y
      MATCH (m:RelatedThing)-[:Relationship]-(y)
      WITH DISTINCT m
      ORDER BY m.label LIMIT 25
      RETURN COLLECT(m) AS list2&quot;,
      {list: list}
     ) YIELD value as val2
    RETURN val1.list1 AS list1, val2.list2 AS list2","","","","true","https://stackoverflow.com/a/77944207","","2","Answer","Running two partially related cypher queries together","false","77944207","",,,,,
"842",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/python","python","","Tag","","false","","",,,,,
"843",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/flask","flask","","Tag","","false","","",,,,,
"844",":Comment","","","","","","","","https://stackoverflow.com/questions/77936432/neo4j-aura-db-connection-doesnt-work-when-a-use-flask#comment137410416_77936432","","0","Comment","","false","137410416","",,,,,
"845",":Answer","","","You have a few errors in your query:
 - There is an illegal comma between the (unneeded) `WITH` clause and the following `CALL` clause.
 - You used the `batchMode: &quot;BATCH_SINGLE&quot;`
   option but still expected the second Cypher statement to be able to
   access `n` and `c` directly.

*Apparently, you did actually have backticks around the property name &quot;GO ID&quot; -- to make the space character usable as part of the name. But for some reason the backticks were not visible characters in your question.*

When you use the [BATCH_SINGLE](https://neo4j.com/labs/apoc/4.4/overview/apoc.periodic/apoc.periodic.iterate/#_batch_mode_batch_single) mode, an entire batch of `n` and `c` values are provided to the second Cypher statement via the `$_batch` parameter, as a list of results (e.g., `[{n: &lt;node1&gt;, c: &lt;node2&gt;}, {n: &lt;node3&gt;, c: &lt;node4&gt;}, ...]`).

You can just omit the `batchMode` option to get the default behavior, which is the one you expected:

    CALL apoc.periodic.iterate(
        &quot;MATCH (n:Genes),(c:n4sch__Class)
         WHERE n.`GO ID` = c.n4sch__name
         RETURN n, c&quot;,
        &quot;CALL apoc.create.relationship(n, n.Qualifier, {}, c) YIELD rel
         RETURN rel&quot;,
         {batchSize:100}
    )","","","","true","https://stackoverflow.com/a/77943636","","1","Answer","Neo4j complex dynamic relationship creation with batch iteration","false","77943636","",,,,,
"846",":Answer","","","Based on what you&#39;ve written in the question, the straightforward way would be to add constraints on the number of each relationship type in a `WHERE` clause:
```sql
MATCH path = (from:Station {id: 61})-[:IN]-&gt;(sec_from:Section), 
      (to:Station {id: 131})&lt;-[:OUT]-(sec_to:Section), 
      route = (sec_from)-[r:CONNECTION|EXCHANGE*1..103]-&gt;(sec_to) 
WHERE 1 &lt;= size([rel IN r WHERE rel:CONNECTION]) &lt;= 100 
      AND size([rel IN r WHERE rel:EXCHANGE]) &lt;= 3
RETURN route;
```
Depending on your data, a post-filter like this could be inefficient, as it might fetch many paths with &gt; 3 relationships of type `EXCHANGE` before discarding them at the `WHERE` clause stage.","","","","true","https://stackoverflow.com/a/77928553","","0","Answer","How to set number of relations between nodes?","false","77928553","",,,,,
"847",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/openstreetmap","openstreetmap","","Tag","","false","","",,,,,
"848",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/osmnx","osmnx","","Tag","","false","","",,,,,
"849",":Comment","","","","","","","","https://stackoverflow.com/questions/77918453/storing-openstreetmap-data-in-neo4j-need-advice-on-defined-structure#comment137383245_77918453","","1","Comment","","false","137383245","",,,,,
"850",":User","","","","","gboeing","","","","","","User","","false","7321942","",,,,,
"851",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/windows","windows","","Tag","","false","","",,,,,
"852",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/keyboard","keyboard","","Tag","","false","","",,,,,
"853",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/cypher-shell","cypher-shell","","Tag","","false","","",,,,,
"854",":Answer","","","You only need a single [fulltext index](https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/full-text-indexes/#create-full-text-indexes) to cover the `name` and `code` properties of `Concept` and `Accession` nodes:

    CREATE FULLTEXT INDEX nameAndCode FOR (n:Concept|Accession) ON EACH [n.name, n.code]

*Note: Aside from `:Concept.name` and `:Accession.code`, the index would also include `:Concept.code` and `:Accession.name` if they happen to exist. If they do, change their property names to avoid polluting the index.*

Once that index is defined, this query may work for your use case:

    // $name and $code are parameters
    CALL db.index.fulltext.queryNodes(
      &quot;nameAndCode&quot;,
      &quot;&#39;&quot; + $name + &quot;&#39; OR &#39;&quot; + $code + &quot;&#39;&quot;) YIELD node, score
    CALL {
      WITH node
      WITH node WHERE node.name = $name
      RETURN node AS concept

      UNION

      WITH node
      WITH node WHERE node.code = $code
      MATCH (concept)-[:hasAccession]-&gt;(node)
      RETURN concept
    }
    RETURN concept, score","","","","false","https://stackoverflow.com/a/77907874","","1","Answer","Neo4j Full text Index that includes properties from a 1-n node","false","77907874","",,,,,
"855",":Answer","","","As you pointed out, you can have two indexes, however it will be a nightmare in the long term, `OR` queries will be fine, `AND` queries will just be non performant, combining FullTextSearch with `AND` on two indexes along with an optional pattern in Cypher will lead to very, very long and hard hours of pain.

There is no single answer tho, it will depend on the level of performance you need, the level of changes you can do at ingestion level or the level of pain you want to have. 

- @cybersam answer is a valid one
- you can create new nodes representing the pairs of texts between concept and ascensions and have an index on that and automate this process during ingestion and vice versa
- you can use [CDC][1] to automate all this process in the background


  [1]: https://neo4j.com/docs/cdc/current/","","","","false","https://stackoverflow.com/a/77908813","","1","Answer","Neo4j Full text Index that includes properties from a 1-n node","false","77908813","",,,,,
"856",":User","","","","","Christophe Willemsen","","","","","","User","","false","2662355","",,,,,
"857",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/c#","c#","","Tag","","false","","",,,,,
"858",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-driver","neo4j-driver","","Tag","","false","","",,,,,
"859",":Comment","","","","","","","","https://stackoverflow.com/questions/77907255/neo4j-c-driver-method-not-found-when-calling-tolistasync#comment137347043_77907255","","1","Comment","","false","137347043","",,,,,
"860",":User","","","","","Guru Stron","","","","","","User","","false","2501279","",,,,,
"861",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/spring","spring","","Tag","","false","","",,,,,
"862",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/spring-data-neo4j","spring-data-neo4j","","Tag","","false","","",,,,,
"863",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/embeddable","embeddable","","Tag","","false","","",,,,,
"864",":Answer","","","Neo4j does not support embedded objects. This is why there is no other way than using `@CompositeProperty` with a custom converter to &quot;embed&quot; your objects.

For example for `soldFor` with a property defined as:

```
@CompositeProperty(prefix=&quot;soldFor&quot;, converter = SoldForConverter.class)
private SoldFor soldFor;
```

and a converter like

```
class SoldForConverter implements Neo4jPersistentPropertyToMapConverter&lt;String, SoldFor&gt; {

	@NonNull @Override
	public Map&lt;String, Value&gt; decompose(@Nullable SoldFor property, Neo4jConversionService conversionService) {

		final HashMap&lt;String, Value&gt; decomposed = new HashMap&lt;&gt;();
		if (property == null) {
			decomposed.put(&quot;cost&quot;, Values.NULL);
			decomposed.put(&quot;currency&quot;, Values.NULL);
		} else {
			decomposed.put(&quot;cost&quot;, Values.value(property.getCost()));
			decomposed.put(&quot;currency&quot;, Values.value(property.getCurrency()));
		}
		return decomposed;
	}

	@Override
	public SoldFor compose(Map&lt;String, Value&gt; source, Neo4jConversionService conversionService) {
		return source.isEmpty() ?
				null :
				new SoldFor(source.get(&quot;cost&quot;).asInt(), source.get(&quot;currency&quot;).asString());
	}
}
```

You will get
```
soldFor.cost=34
soldFor.currency=&quot;EUR&quot;
```
Example taking from 

Converter: https://github.com/spring-projects/spring-data-neo4j/blob/c5d3458217124e1867f12bc47454eab85551c72b/src/test/java/org/springframework/data/neo4j/integration/shared/conversion/ThingWithCompositeProperties.java#L235

Property definition: https://github.com/spring-projects/spring-data-neo4j/blob/c5d3458217124e1867f12bc47454eab85551c72b/src/test/java/org/springframework/data/neo4j/integration/shared/conversion/RelationshipWithCompositeProperties.java#L44 
and simplified.","","","","true","https://stackoverflow.com/a/77912146","","0","Answer","How to define in spring model to embed an object using Neo4j","false","77912146","",,,,,
"865",":User","","","","","meistermeier","","","","","","User","","false","2650436","",,,,,
"866",":Answer","","","You should read the documentation for [CALL](https://neo4j.com/docs/cypher-manual/current/clauses/call/), [WITH](https://neo4j.com/docs/cypher-manual/current/clauses/with/), and [UNION](https://neo4j.com/docs/cypher-manual/current/clauses/union/).

Here are answers to your specific questions:

 - When you `CALL` a procedure that can return results, you generally must also specify a `YIELD` for at least one of the procedure&#39;s result fields and use the exact field name. You can use [SHOW PROCEDURES](https://neo4j.com/docs/cypher-manual/current/clauses/listing-procedures/) to get the signature of a procedure, which includes its result fields. For example, to get the signature of `apoc.create.addLabels`:

       SHOW PROCEDURES YIELD name, signature
       WHERE name = &#39;apoc.create.addLabels&#39;
       RETURN signature

 - `YIELD` must specify at least one of the result field name(s) used in the procedure&#39;s signature. You cannot use arbitrary names, although you can immediately use `AS` to rename a field (e.g., `YIELD officalName AS foo`).

 - Cypher does not permit multiple `YIELD`s to produce the same variable name (in the same scope). To get around this, you can use `AS` to rename such variables. For example, this should work:

    ```
    LOAD CSV WITH HEADERS FROM &#39;file:///myfile.csv&#39; AS row
    MERGE (n:Person{id:row.ID,name:row.Name}) 
    WITH n,row
    CALL apoc.create.addLabels(id(n), [row.Title,row.Position]) YIELD node AS _
    CALL apoc.create.addLabels(id(n), split(row.Roles, &#39;,&#39;)) YIELD node AS __
    CALL apoc.create.addLabels(id(n), split(row.Aliases, &#39;,&#39;)) YIELD node
    RETURN node
    ```

   (*Also FYI: [WITH](https://neo4j.com/docs/cypher-manual/current/clauses/with/) changes the set of variables that are in scope. If any subsequent clauses need a variable, then a `WITH` clause must specify that variable.*)

- As documented, a [UNION](https://neo4j.com/docs/cypher-manual/current/clauses/union/) &quot;combines the results of two or more queries into a single result set&quot;. You cannot just put `UNION` between arbitrary clauses.","","","","true","https://stackoverflow.com/a/77903083","","1","Answer","How to stack consecutive APOC statements in Neo4j Cypher","false","77903083","",,,,,
"867",":Answer","","","To return paths from station A with `id = 1` to station B with `id = 25` via `Line` relationships with equal `Line_ID` properties:

```sql
MATCH (:Station {id: 1})-[r:Line]-&gt;+(:Station {id: 25})
WHERE all(i IN range(0, size(r)-2) WHERE r[i].Line_ID = r[i+1].Line_ID)
```","","","","false","https://stackoverflow.com/a/77901640","","0","Answer","Search route in NEO4J","false","77901640","",,,,,
"868",":Answer","","","This may be an efficient query, since the variable-length relationship pattern `[rs:Line *0..9 {id: r1.id}]` specifies a static `id`:

    MATCH path = (start:Station {id: 1})-[r1:Line]-&gt;(:Station)
        -[:Line *0..9 {id: r1.id}]-&gt;(:Station {id: 25})
    RETURN path

I imposed an arbitrary upper bound of 9 (for a total path length of up to 10) to avoid taking too long or running out of memory. Adjust the bound as appropriate for your data.

It is important to recognize that variable-length relationship queries have exponential complexity. If each node has `R` relevant relationships, then a path length upper bound of `N` can result in `R**N` database lookups. This is why it is important to set a reasonable upper bound (`N`).

##### Specific `Line` `id`

If you want to specify the `Line` `id` to use, then the query can be simpler and much quicker (but you should still impose an upper bound on the path length). This query assumes you pass the following [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/):
 - `$line_id`: the desired `id` value
 - `$station_id_first` and `$station_id_last`

       MATCH path = (:Station {id: $station_id_first})-[:Line *..9 {id: $line_id}]-&gt;(:Station {id: $station_id_last})
       RETURN path
","","","","false","https://stackoverflow.com/a/77901888","","0","Answer","Search route in NEO4J","false","77901888","",,,,,
"869",":Comment","","","","","","","","https://stackoverflow.com/questions/77900793/neo4j-is-not-running-after-putting-the-right-path#comment137335847_77900793","","1","Comment","","false","137335847","",,,,,
"870",":Comment","","","","","","","","https://stackoverflow.com/questions/77900793/neo4j-is-not-running-after-putting-the-right-path#comment137338984_77900793","","1","Comment","","false","137338984","",,,,,
"871",":Answer","","","That `RETURN tag` is reducing the cardinality to zero when `$tagNames` is empty. To solve this, wrap the `CALL` in another `CALL` to preserve the cardinality of the first MATCH:
```sql
MATCH (i:Item {id: $itemId})

OPTIONAL MATCH (i)-[previousRelations:hasTag]-&gt;(:Tag)
DELETE previousRelations
    
WITH *
CALL {
  WITH i
  CALL {
    UNWIND $tagNames as tagName

    MERGE (tag:Tag {name: tagName})
    ON CREATE SET tag.id = randomUUID(), tag.createdAt = datetime()

    RETURN tag
  }
  MERGE (i)-[:hasTag]-&gt;(tag)
}

RETURN i
```","","","","true","https://stackoverflow.com/a/77900287","","1","Answer","UNWIND an empty list negatively affects outer RETURN statement","false","77900287","",,,,,
"872",":Comment","","","","","","","","https://stackoverflow.com/questions/77898928/query-speed-optimalization-neo4j#comment137334561_77898928","","0","Comment","","false","137334561","",,,,,
"873",":Comment","","","","","","","","https://stackoverflow.com/questions/77898928/query-speed-optimalization-neo4j#comment137335477_77898928","","0","Comment","","false","137335477","",,,,,
"874",":Comment","","","","","","","","https://stackoverflow.com/questions/77898928/query-speed-optimalization-neo4j#comment137337072_77898928","","0","Comment","","false","137337072","",,,,,
"875",":Comment","","","","","","","","https://stackoverflow.com/questions/77898928/query-speed-optimalization-neo4j#comment137343756_77898928","","0","Comment","","false","137343756","",,,,,
"876",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/database","database","","Tag","","false","","",,,,,
"877",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/mongodb","mongodb","","Tag","","false","","",,,,,
"878",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/graphql","graphql","","Tag","","false","","",,,,,
"879",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-graphql-js","neo4j-graphql-js","","Tag","","false","","",,,,,
"880",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-graphql-library","neo4j-graphql-library","","Tag","","false","","",,,,,
"881",":Answer","","","GraphQL only allows alphanumeric characters and underscores in [names](https://github.com/graphql/graphql-spec/blame/October2021/spec/Section%202%20--%20Language.md#L191).

If your graph data model has property names containing special symbols like &quot;.&quot;, you should consider changing those property names to conform to the GraphQL requirements (e.g., &quot;properties_lowerNameMonolithic&quot; instead of &quot;properties.lowerNameMonolithic&quot;).","","","","true","https://stackoverflow.com/a/77897011","","1","Answer","Neo4j GraphQL library schema instrospector wtih property names separated by a dot","false","77897011","",,,,,
"882",":Answer","","","This query returns every tree (without the root node) of every `root` whose `name` is &quot;The Root Name&quot;.

    MATCH (root {name: &quot;The Root Name&quot;})-[:metaClassOf]-&gt;(n)
    WHERE NOT ()-[:metaClassOf]-&gt;(root)
    MATCH p=(n)-[:metaClassOf*0..]-&gt;()
    WITH root, COLLECT(p) AS ps
    CALL apoc.convert.toTree(ps) YIELD value AS tree
    RETURN root, tree

","","","","true","https://stackoverflow.com/a/77894062","","1","Answer","How to query hierarchy paths without the root node (as list of paths)","false","77894062","",,,,,
"883",":Answer","","","No, you must perform explicit mutations to populate the database.

The Neo4j GraphQL Library `type definitions` are used to define the mapping between your input/output data and your graph data model. And the [directives](https://neo4j.com/docs/graphql/current/type-definitions/directives/) are used to further modify the behavior of [queries or mutations](https://graphql.org/learn/queries/) (e.g. to automate the population of specific fields). But those facilities are not able to prepopulate the database.","","","","true","https://stackoverflow.com/a/77893238","","2","Answer","Neo4j GraphQL library First Development approach","false","77893238","",,,,,
"884",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/amazon-ec2","amazon-ec2","","Tag","","false","","",,,,,
"885",":Answer","","","Make sure you delete all the existing neo4j data before reinstalling. Or, just use a new ECS instance.","","","","true","https://stackoverflow.com/a/77889580","","2","Answer","Neo4j fails to start","false","77889580","",,,,,
"886",":Comment","","","","","","","","https://stackoverflow.com/questions/77888556/neo4j-fails-to-start#comment137313207_77888556","","1","Comment","","false","137313207","",,,,,
"887",":Comment","","","","","","","","https://stackoverflow.com/questions/77888556/neo4j-fails-to-start#comment137314835_77888556","","0","Comment","","false","137314835","",,,,,
"888",":Comment","","","","","","","","https://stackoverflow.com/questions/77888556/neo4j-fails-to-start#comment137315122_77888556","","0","Comment","","false","137315122","",,,,,
"889",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/csv","csv","","Tag","","false","","",,,,,
"890",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/graph","graph","","Tag","","false","","",,,,,
"891",":Comment","","","","","","","","https://stackoverflow.com/questions/77887260/invalid-input-expected-where-or-a-parameter-line-3-column-19-of#comment137313174_77887260","","0","Comment","","false","137313174","",,,,,
"892",":Comment","","","","","","","","https://stackoverflow.com/questions/77887260/invalid-input-expected-where-or-a-parameter-line-3-column-19-of#comment137345767_77887260","","0","Comment","","false","137345767","",,,,,
"893",":Comment","","","","","","","","https://stackoverflow.com/questions/77887260/invalid-input-expected-where-or-a-parameter-line-3-column-19-of#comment137347475_77887260","","0","Comment","","false","137347475","",,,,,
"894",":Answer","","","The following query will go through all relationships in the database, enumerate all labels on start and end node and then count how often these pairs appear:

```cypher
MATCH (a)-[r]-&gt;(b)
UNWIND labels(a) AS Label_Start
UNWIND labels(b) AS Label_End
RETURN
  type(r) AS RelationshipType,
  Label_Start,
  Label_End,
  count([Label_Start, Label_End]) AS Count
```","","","","true","https://stackoverflow.com/a/77885643","","3","Answer","Get number of relationships for each relationship type and label in Neo4j","false","77885643","",,,,,
"895",":User","","","","","Arne","","","","","","User","","false","23302132","",,,,,
"896",":Answer","","","Like with SQL the columns in Cypher are fixed (except if you use RETURN *), so it is hard to achieve a column per label-pair without knowing the possible label-pairs when you write the query.

There are other ways to solve it though. One is to have one row for each relationship type and label pair. Another one is to return a map for the different label pairs.

Another thing that we need to consider is that nodes can have many labels (and can even be without label).

If you have access to APOC Core you could do like this to get one row per node-pair-type:

    MATCH (a)-[r]-&gt;(b)
    WITH DISTINCT apoc.text.join(labels(a), &#39;_&#39;)+&#39;_&#39;+apoc.text.join(labels(b), &#39;_&#39;) AS Labels,r
    RETURN type(r) AS Relationship_Type, Labels, COUNT(*) AS Count

To get the result as a map you could do:

    MATCH (a)-[r]-&gt;(b)
    WITH DISTINCT apoc.text.join(labels(a), &#39;_&#39;)+&#39;_&#39;+apoc.text.join(labels(b), &#39;_&#39;) AS Labels,r
    WITH type(r) AS Relationship_Type, Labels, COUNT(*) AS c
    RETURN Relationship_Type, apoc.map.fromPairs(collect([Labels, c])) AS Count","","","","false","https://stackoverflow.com/a/77886294","","1","Answer","Get number of relationships for each relationship type and label in Neo4j","false","77886294","",,,,,
"897",":User","","","","","Christoffer Bergman","","","","","","User","","false","21624328","",,,,,
"898",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/network-drive","network-drive","","Tag","","false","","",,,,,
"899",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-desktop","neo4j-desktop","","Tag","","false","","",,,,,
"900",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/large-language-model","large-language-model","","Tag","","false","","",,,,,
"901",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/retrieval-augmented","retrieval-augmented","","Tag","","false","","",,,,,
"902",":Answer","","","If you don&#39;t care about the weight you may not have to use APOC at all, but instead the built-in Cypher shortestPath function:

    MATCH path=shortestPath((:City {name: &#39;M&#252;nchen&#39;})-[d:DIRECT*]-(:City {name: &#39;Hamburg&#39;})) RETURN size(d) AS weight, path

which gives this result

    ╒══════╤══════════════════════════════════════════════════════════════════════╕
    │weight│path                                                                  │
    ╞══════╪══════════════════════════════════════════════════════════════════════╡
    │2     │(:City {name: &quot;M&#252;nchen&quot;})&lt;-[:DIRECT]-(:City {name: &quot;Frankfurt&quot;})-[:DIR│
    │      │ECT]-&gt;(:City {name: &quot;Hamburg&quot;})                                       │
    └──────┴──────────────────────────────────────────────────────────────────────┘","","","","true","https://stackoverflow.com/a/77878372","","2","Answer","Shortest path on a topological graph with default weight","false","77878372","",,,,,
"903",":Answer","","","This query may work for your use case (assuming you only have one `Pantry`):

    MATCH (:Pantry)-[has:HAS]-&gt;(i:Ingredient)&lt;-[required:REQUIRED]-(r:Recipe)
    WHERE has.quantity &gt;= required.quantity
    WITH r, COUNT(i) AS iCount
    WHERE iCount = COUNT{ (r)-[:REQUIRED]-&gt;() }
    RETURN r

It finds all ingredients in the pantry that have a sufficient quantity for any recipe, counts the number of such ingredients for each recipe, and efficiently filters for those recipes in which the sufficient-ingredient count equals the required-ingredient count.","","","","true","https://stackoverflow.com/a/77869514","","0","Answer","Neo4j Cypher Query to find recipes where I have all the ingredients and a sufficient quantity","false","77869514","",,,,,
"904",":Answer","","","This returns all recipes that the Pantry has enough ingredients for:
```sql
MATCH (r:Recipe)
WHERE all(enough IN 
        COLLECT {
          MATCH (r)-[req:REQUIRED]-&gt;(i:Ingredient)
          RETURN EXISTS { 
            (i)&lt;-[h:HAS]-(:Pantry) WHERE req.requires &lt;= h.has
          }
        } WHERE enough) 
RETURN r","","","","false","https://stackoverflow.com/a/77869533","","0","Answer","Neo4j Cypher Query to find recipes where I have all the ingredients and a sufficient quantity","false","77869533","",,,,,
"905",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/indexing","indexing","","Tag","","false","","",,,,,
"906",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-java-api","neo4j-java-api","","Tag","","false","","",,,,,
"907",":Answer","","","If I understand you correctly, you are measuring the performance of the `MATCH` _and_ the `DELETE` of the matched nodes. As it says in the docs [here](https://neo4j.com/docs/cypher-manual/current/indexes/search-performance-indexes/using-indexes/#over-indexing), that shouldn&#39;t be surprising, as indexes will slow down writes: 

&gt; **Slower write queries**: adding indexes impacts the performance of write queries. This is because indexes are updated with each write query. If a system needs to perform a lot of writes quickly, it may be counterproductive to have an index on the affected data entities. In other words, if write performance is crucial for a particular use case, it may be beneficial to only add indexes where they are necessary for read purposes.","","","","false","https://stackoverflow.com/a/77866881","","0","Answer","How Does the Neo4j Range Index BTREE work after deletion of nodes","false","77866881","",,,,,
"908",":Comment","","","","","","","","https://stackoverflow.com/questions/77865854/how-does-the-neo4j-range-index-btree-work-after-deletion-of-nodes#comment137276503_77865854","","0","Comment","","false","137276503","",,,,,
"909",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/kotlin","kotlin","","Tag","","false","","",,,,,
"910",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/android-studio","android-studio","","Tag","","false","","",,,,,
"911",":Comment","","","","","","","","https://stackoverflow.com/questions/77855812/execution-failed-for-task-appmergeextdexdebug-failed-to-transform-neo4j-jav#comment137283804_77855812","","0","Comment","","false","137283804","",,,,,
"912",":Answer","","","You can do it using the GDS strongly connected components procedure after projecting the relationships as undirected:
```lang-cypher
// Project the CONTAINS relationships as undirected so that traversals 
// disregard the directions
CALL gds.graph.project(
       &#39;components&#39;, 
       [&#39;NodeA&#39;, &#39;NodeB&#39;], 
       {CONTAINS: {orientation: &#39;UNDIRECTED&#39;}}
);

// Only show the NodeA nodes using the node:NodeA label predicate
CALL gds.scc.stream(&#39;components&#39;, {})
YIELD nodeId, componentId AS component
WITH gds.util.asNode(nodeId) AS node, component 
WHERE node:NodeA 
RETURN node, component 
ORDER BY component;
```

Results using your data:
```
+----------------------------------+
| node                 | component |
+----------------------------------+
| (:NodeA {name: &quot;1&quot;}) | 0         |
| (:NodeA {name: &quot;2&quot;}) | 0         |
| (:NodeA {name: &quot;3&quot;}) | 0         |
| (:NodeA {name: &quot;4&quot;}) | 0         |
| (:NodeA {name: &quot;5&quot;}) | 4         |
| (:NodeA {name: &quot;6&quot;}) | 4         |
+----------------------------------+
```","","","","true","https://stackoverflow.com/a/77855696","","1","Answer","Neo4j - Retrieve nodes of graph components","false","77855696","",,,,,
"913",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/docker","docker","","Tag","","false","","",,,,,
"914",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/docker-compose","docker-compose","","Tag","","false","","",,,,,
"915",":Answer","","","After researching for a long time and doing several tests I found the solution. was to create a shared volume with the bind option pointing to where these folders are referenced. Here I leave the code of my docker-composa file in case someone else runs into this problem.
Greetings

    version: &quot;3.8&quot;
    services:  
      # Noe4j database config
      neo4j:
        container_name: neo4j_social_seed_db 
        image: neo4j:5.15.0-enterprise
        ports:
          - &quot;7474:7474&quot;
          - &quot;7687:7687&quot;
        restart: always
        environment:
          - NEO4J_AUTH=neo4j/neo4jSocial
          - NEO4J_ACCEPT_LICENSE_AGREEMENT=yes
          - NEO4J_server.memory.pagecache.size=1G
          - NEO4J_server.directories.import=import
        volumes:
          - ./neo4j/data:/data
          - ./neo4j/conf:/conf
          - ./neo4j/logs:/logs
          - ./neo4j/plugins:/plugins
          - import_data:/import
        networks:
          - net
      # Social Seed Api in Java config
      social-seed-app:
        container_name: app_social_seed
        image: social-seed:0.0.1
        build: 
          context: ./backend
        ports:
          - &quot;8081:8081&quot;
        environment:
          - DATABASE_URI=bolt://neo4j:7687
          - DATABASE_USERNAME=neo4j
          - DATABASE_PASSWORD=neo4jSocial
        depends_on:
          - neo4j
        networks:
          - net
      # Fake Graph config
      fake-graph:
        container_name: fake_graph_service
        image: python:3.11.2-slim
        build: 
          context: ./fake_graph    
        volumes:
          - ./fake_graph:/app
          - import_data:/app/temp
        depends_on:
          - neo4j
        environment:
          - GENERATE_FAKE_GRAPH
          - DATABASE_URI=bolt://neo4j:7687
        command: &gt;
          sh -c &quot;if [ &#39;$GENERATE_FAKE_GRAPH&#39; = &#39;true&#39; ]; then python /app/generate.py; else sleep infinity; fi&quot;    
        networks:
          - net
    volumes:
      import_data:
        driver_opts:
          o: bind
    networks:
      net:","","","","false","https://stackoverflow.com/a/77856014","","0","Answer","Neo4j Import folder shared between services in docker","false","77856014","",,,,,
"916",":Comment","","","","","","","","https://stackoverflow.com/questions/77852179/neo4j-import-folder-shared-between-services-in-docker#comment137249844_77852179","","0","Comment","","false","137249844","",,,,,
"917",":Comment","","","","","","","","https://stackoverflow.com/questions/77852179/neo4j-import-folder-shared-between-services-in-docker#comment137254002_77852179","","0","Comment","","false","137254002","",,,,,
"918",":Comment","","","","","","","","https://stackoverflow.com/questions/77852179/neo4j-import-folder-shared-between-services-in-docker#comment137254012_77852179","","0","Comment","","false","137254012","",,,,,
"919",":Comment","","","","","","","","https://stackoverflow.com/questions/77852179/neo4j-import-folder-shared-between-services-in-docker#comment137254024_77852179","","0","Comment","","false","137254024","",,,,,
"920",":Comment","","","","","","","","https://stackoverflow.com/questions/77852179/neo4j-import-folder-shared-between-services-in-docker#comment137256023_77852179","","0","Comment","","false","137256023","",,,,,
"921",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/knowledge-graph","knowledge-graph","","Tag","","false","","",,,,,
"922",":Answer","","","The latest Neo4j desktop won&#39;t let you download a 3.4 neo4j because 3.4 has been out of support for several years now.

You have what you need to install 3.4.12 though. Forget desktop and use the zip file you downloaded, that has everything you need. The 3.4 windows installation instructions are here:
https://neo4j.com/docs/operations-manual/3.4/installation/windows/","","","","true","https://stackoverflow.com/a/77838141","","1","Answer","How to Use Neo4j 3.4.12 Community Version in Neo4j Desktop 1.5.8?","false","77838141","",,,,,
"923",":User","","","","","jenny","","","","","","User","","false","11334268","",,,,,
"924",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/swift","swift","","Tag","","false","","",,,,,
"925",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/xcode","xcode","","Tag","","false","","",,,,,
"926",":Answer","","","The documentation doesn’t seem to be up to date and links to an old swift library.

Make sure you use the new one at https://github.com/Neo4j-Swift/Neo4j-Swift

And the class you are trying to use seems to have been renamed to BoltClient in the new version.","","","","true","https://stackoverflow.com/a/77834509","","1","Answer","Cannot find type &#39;Client&#39; in scope","false","77834509","",,,,,
"927",":User","","","","","Joakim Danielson","","","","","","User","","false","9223839","",,,,,
"928",":Answer","","","From the [documentation][1] 

&gt; Even though text indexes do support other text queries, ENDS WITH or CONTAINS queries are the only ones for which this index type provides an advantage over a range index.

If you need CONTAINS, TEXT indexes are way faster than RANGE.

That said, based on your query, TEXT indexes are case sensitive and trying to lowercase the value of properties for comparison will prevent the index usage.

```cypher
// doesn&#39;t use the index
WHERE toLower(n.text) CONTAINS &#39;my-input&#39;

// uses the index
WHERE n.text CONTAINS &#39;my-input&#39;
```


  [1]: https://neo4j.com/docs/operations-manual/current/performance/index-configuration/#index-configuration-text","","","","true","https://stackoverflow.com/a/77835440","","2","Answer","Neo4j - Range index vs Text index when checking membership in list of only strings","false","77835440","",,,,,
"929",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/foreach","foreach","","Tag","","false","","",,,,,
"930",":Answer","","","You don&#39;t show where `signalTag` comes from, so I will just replicate it being available with a `WITH` clause at the start of the query. 

I am guessing that what you want is for every existing node whose property `signalTag` equals the `signalTag` value, you want to create a new node with property `tag` = `signalTag`. If the `IOType` of the existing node starts with `&#39;A&#39;`, then the new node gets the label `AnalogAlarm`, or if it starts with `&#39;D&#39;`, then it gets the `DigitalAlarm` label instead. The new node is then connected to the existing node(s) with an `IS_ALARM` relationship.

If that is true, you can achieve it with a couple of `CALL` subqueries:
```sql
WITH &#39;ABC&#39; AS signalTag
CALL {
    WITH signalTag
    MATCH (i WHERE i.signalTag = signalTag AND i.IOType STARTS WITH &#39;A&#39;)
    MERGE (aa:AnalogAlarm {tag: signalTag})
    MERGE (i)-[:IS_ALARM]-&gt;(aa)
}
CALL {
    WITH signalTag
    MATCH (j WHERE j.signalTag = signalTag AND j.IOType STARTS WITH &#39;D&#39;)
    MERGE (dig:DigitalAlarm {tag: signalTag})
    MERGE (j)-[:IS_ALARM]-&gt;(dig)
}
```
The `CALL` subqueries are necessary so that the cardinality of the contained `MATCH` clauses don&#39;t affect each other.


","","","","false","https://stackoverflow.com/a/77831897","","0","Answer","FOREACH syntax in NEO4J","false","77831897","",,,,,
"931",":Answer","","","Your query has many syntax errors and the use case is a bit too complex for the `FOREACH` clause, especially since there are better alternatives that were introduced to simplify such use cases.

*Note: my answers assume that `signalTag` should actually be `i.signalTag`, in which case your `WHERE` tests are not needed.*

### Snippet using [CALL subquery POST-UNION processing](https://neo4j.com/docs/cypher-manual/current/subqueries/call-subquery/#call-post-union):
```
...

CALL {
  WITH i
  WITH i WHERE i.IOType STARTS WITH &#39;A&#39;
  MERGE (a:AnalogAlarm {tag: i.signalTag})
  MERGE (i)-[:IS_ALARM]-&gt;(a)
  RETURN a

  UNION ALL

  WITH i
  WITH i WHERE i.IOType STARTS WITH &#39;D&#39;
  MERGE (a:DigitalAlarm {tag: i.signalTag})
  MERGE (i)-[:IS_ALARM]-&gt;(a)
  RETURN a

  UNION ALL

  WITH i
  WITH i WHERE NOT LEFT(i.IOType, 1) IN [&#39;A&#39;, &#39;D&#39;]
  RETURN NULL AS a
}

// Remainder of query
...
```

The remainder of the query can access `a`, which will be `NULL` if `i.IOType` does not start with &#39;A&#39; or &#39;D&#39;.

### Snippet using [apoc.do.case](https://neo4j.com/docs/apoc/current/overview/apoc/apoc.do.case/)

```
...

CALL apoc.do.case([
  i.IOType STARTS WITH &#39;A&#39;,
    &#39;MERGE(a:AnalogAlarm {tag: i.signalTag}) MERGE (i)-[:IS_ALARM]-&gt;(a) RETURN a&#39;,
  i.IOType STARTS WITH &#39;D&#39;,
    &#39;MERGE(a:DigitalAlarm {tag: i.signalTag}) MERGE (i)-[:IS_ALARM]-&gt;(a) RETURN a&#39;
  ],
  &#39;RETURN NULL AS a&#39;,
  {i: i}
) YIELD value

// Remainder of query
...
```

The remainder of the query can access `a` (via `value.a`), which will be `NULL` if `i.IOType` does not start with &#39;A&#39; or &#39;D&#39;.","","","","false","https://stackoverflow.com/a/77842328","","0","Answer","FOREACH syntax in NEO4J","false","77842328","",,,,,
"932",":Comment","","","","","","","","https://stackoverflow.com/questions/77831258/foreach-syntax-in-neo4j#comment137212065_77831258","","0","Comment","","false","137212065","",,,,,
"933",":User","","","","","knittl","","","","","","User","","false","112968","",,,,,
"934",":Comment","","","","","","","","https://stackoverflow.com/questions/77831258/foreach-syntax-in-neo4j#comment137212169_77831258","","0","Comment","","false","137212169","",,,,,
"935",":Comment","","","","","","","","https://stackoverflow.com/questions/77831258/foreach-syntax-in-neo4j#comment137212173_77831258","","0","Comment","","false","137212173","",,,,,
"936",":Comment","","","","","","","","https://stackoverflow.com/questions/77831258/foreach-syntax-in-neo4j#comment137220931_77831258","","0","Comment","","false","137220931","",,,,,
"937",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/azure-openai","azure-openai","","Tag","","false","","",,,,,
"938",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/openaiembeddings","openaiembeddings","","Tag","","false","","",,,,,
"939",":Answer","","","There are two versions of APOC, APOC Core and APOC Extended. APOC Core is officially supported by Neo4j and is available in Aura (the cloud hosted version of Neo4j), Extended is not. The embedding methods are, however, only available in APOC Extended, so one reason could be that you installed APOC Core.

But in version 5.15.0 of Neo4j you no longer need APOC to do embeddings, there are officially supported versions of the embedding procedures/functions with this version that are also available in Aura (or will be very soon).

If you host your own database you need to install a package called neo4j-genai-plugin-5.XX.0.jar (copy it from the products folder to plugins and restart Neo4j). In Aura they are available by default.

The embedding methods are now called:

    genai.vector.encode
    genai.vector.encodeBatch

You use them like this (assuming you use OpenAI. It also support VertexAI and AWS Bedrock):

    WITH genai.vector.encode($phrase, &quot;OpenAI&quot;, {token: $apiKey}) AS embedding

where $phrase is a single string to embed

or

    CALL genai.vector.encodeBatch([$phrase1, $phrase2], &quot;OpenAI&quot;, {token: $apiKey}) yield index, resource, vector

if you have multiple phrases that you want to batch embed

So with your example it would be

    WITH genai.vector.encode(&quot;Are there any news regarding return to office policies?&quot;, &quot;OpenAI&quot;, {token: &quot;{openai_api_key}&quot;}) AS embedding
    MATCH (c:Chunk) WITH c, gds.similarity.cosine(c.embedding, embedding) AS score ORDER BY score DESC LIMIT 3 RETURN c.text, score","","","","false","https://stackoverflow.com/a/77830710","","0","Answer","Can we use apoc.ml.openai.embediing with Neo$j desktop?","false","77830710","",,,,,
"940",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-parallel-runtime","neo4j-parallel-runtime","","Tag","","false","","",,,,,
"941",":Answer","","","It is not guaranteed. Here is what the Cypher manual says about it:

&gt; When ORDER BY is present on a WITH clause , the immediately following
&gt; clause will receive records in the specified order. The order is not
&gt; guaranteed to be retained after the following clause, unless that also
&gt; has an ORDER BY subclause.

Slotted and Pipelined will likely preserve ordering, even if not guaranteed, but Parallel will likely not.

https://neo4j.com/docs/cypher-manual/current/clauses/order-by/#order-with","","","","true","https://stackoverflow.com/a/77831248","","2","Answer","Neo4j Cypher ORDER BY in the middle of the query and expected behaviour on PARALLEL runtime","false","77831248","",,,,,
"942",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-aura","neo4j-aura","","Tag","","false","","",,,,,
"943",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neovis","neovis","","Tag","","false","","",,,,,
"944",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/apoc-extended","apoc-extended","","Tag","","false","","",,,,,
"945",":Comment","","","","","","","","https://stackoverflow.com/questions/77814894/neo4j-on-parallel-runtime-returns-different-results-different-elements-order-c#comment137205500_77814894","","1","Comment","","false","137205500","",,,,,
"946",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/maven","maven","","Tag","","false","","",,,,,
"947",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-block-store","neo4j-block-store","","Tag","","false","","",,,,,
"948",":Answer","","","You can pass the format in as an environment variable like this:

--env NEO4J_db_format=block","","","","true","https://stackoverflow.com/a/77813285","","2","Answer","Try Neo4j’s Next-Gen Graph-Native Store Format and Docker initialization","false","77813285","",,,,,
"949",":User","","","","","Dave Fauth","","","","","","User","","false","3952697","",,,,,
"950",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/spring-data-jpa","spring-data-jpa","","Tag","","false","","",,,,,
"951",":Answer","","","[Spring Data JPA](https://spring.io/projects/spring-data-jpa/) is for *relational* databases. Since Neo4j is a *graph* database, you would need to use [Spring Data Neo4j](https://spring.io/projects/spring-data-neo4j/) (SDN) to get something functionally similar to JPA. However, JPA-specific interfaces like `JpaSpecificationExecutor` do not exist in SDN.","","","","false","https://stackoverflow.com/a/77810182","","1","Answer","is there any api for neo4j like JpaSpecificationExecutor api?","false","77810182","",,,,,
"952",":Comment","","","","","","","","https://stackoverflow.com/questions/77809929/is-there-any-api-for-neo4j-like-jpaspecificationexecutor-api#comment137178834_77809929","","1","Comment","","false","137178834","",,,,,
"953",":User","","","","","toyota Supra","","","","","","User","","false","4136999","",,,,,
"954",":Answer","","","I would suggest to use cypher projection (https://neo4j.com/docs/graph-data-science/current/management-ops/graph-creation/graph-project-cypher-projection/#cypher-aggregation-relationship-properties).
The linked example projects a graph with a relationship property. 

Replace your last return clause with the projection.
","","","","false","https://stackoverflow.com/a/77808039","","0","Answer","How to use result of cypher query output in GDS algorithm","false","77808039","",,,,,
"955",":User","","","","","florentin","","","","","","User","","false","22051375","",,,,,
"956",":Answer","","","You can&#39;t project virtual relationships to a GDS graph (your second query has other syntax errors but as the approach isn’t going to work, it&#39;s not worth fixing them).

Instead you can use a `UNION` query (shown here in the `CALL` braces) to project both the `ACCESSED` relationships that already exist in your graph as well as the &#39;virtual&#39; `HAS_COMMON_DOCS` relations:

```sql
CALL {
    MATCH (source:ClientInfo)-[:ACCESSED]-&gt;()&lt;-[:ACCESSED]-(target:ClientInfo)
    WHERE source &lt; target
    RETURN source, target, &#39;HAS_COMMON_DOCS&#39; AS relType, {commonDocs: count(*)} AS props
    UNION
    MATCH (source:ClientInfo)-[:ACCESSED]-&gt;(target)
    RETURN source, target, &#39;ACCESSED&#39; AS relType, {} AS props
}
WITH gds.graph.project(
    &#39;common_docs&#39;,
    source,
    target,
    { 
        sourceNodeLabels: labels(source),
        targetNodeLabels: labels(target),
        relationshipProperties: props {.*},
        relationshipType: relType 
    }
) AS g
RETURN g
```

You can add `WHERE` clauses in the `UNION` query to filter on e.g. user ids etc. I left out `n1Docs` and `n2Docs` as they aren&#39;t used in your example.","","","","true","https://stackoverflow.com/a/77808186","","0","Answer","How to use result of cypher query output in GDS algorithm","false","77808186","",,,,,
"957",":Answer","","","GDS does not allow you to project virtual nodes or relationships. You can, however, use [Cypher projection](https://neo4j.com/docs/graph-data-science/current/management-ops/graph-creation/graph-project-cypher-projection/) to put relationships in the projection that do not actually exist in the database (along with the associated nodes), which may be equivalent to what you are trying to do.

This version of @FinbarGood&#39;s answer may do roughly what you are trying to do in your second query:

    MATCH (n1:ClientInfo)-[:ACCESSED]-&gt;()&lt;-[:ACCESSED]-(n2:ClientInfo)
    WHERE n1 &lt; n2 AND NOT 310962818 IN [n1.peopleCode, n2.peopleCode]
    WITH n1, n2, COUNT(*) as commonDocs
    WHERE commonDocs &gt;= 5
    WITH gds.graph.project(
        &#39;users&#39;,
        n1, n2, 
        { relationshipProperties: {commonDocs: commonDocs},
          relationshipType: &#39;HAS_COMMON_DOCS&#39; }
    ) AS g
    RETURN g.graphName AS graph, g.nodeCount AS nodes, g.relationshipCount AS rels;

Notes:
- `n1 &lt; n2` lets us avoid using the same pair of `ClientInfo` nodes twice.
- The projection will only contain the generated `HAS_COMMON_DOCS` relationships and their associated nodes.","","","","false","https://stackoverflow.com/a/77809618","","0","Answer","How to use result of cypher query output in GDS algorithm","false","77809618","",,,,,
"958",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/py2neo","py2neo","","Tag","","false","","",,,,,
"959",":Comment","","","","","","","","https://stackoverflow.com/questions/77793850/cant-connect-to-neo4j-via-py2neo#comment137144503_77793850","","0","Comment","","false","137144503","",,,,,
"960",":User","","","","","jose_bacoy","","","","","","User","","false","7371893","",,,,,
"961",":Comment","","","","","","","","https://stackoverflow.com/questions/77793850/cant-connect-to-neo4j-via-py2neo#comment137144582_77793850","","0","Comment","","false","137144582","",,,,,
"962",":Comment","","","","","","","","https://stackoverflow.com/questions/77793850/cant-connect-to-neo4j-via-py2neo#comment137146931_77793850","","0","Comment","","false","137146931","",,,,,
"963",":Answer","","","The `( )` in your first `MATCH` could be interpreted as a single node pattern. But you can declare at most a single variable in each node pattern, and so `(a, b)` raises a syntax error. 

In any case, it doesn&#39;t look like you really need the first two lines. This is a valid query (if `n` is replaced with a positive integer), that binds to start nodes with name `&#39;node1name&#39;` and end nodes with name `&#39;node2name&#39;`:
```sql
MATCH path = (a)-[*..n]-(b)
WHERE all(relName IN [&#39;relname1&#39;, &#39;relname2&#39;] 
            WHERE any(rel IN relationships(path) WHERE rel.display_name = relName)) 
AND a.name = &#39;node1name&#39; and b.name = &#39;node2name&#39;
RETURN path
```","","","","true","https://stackoverflow.com/a/77788459","","1","Answer","Neo4j Cypher query for all paths that contain certain nodes and relations","false","77788459","",,,,,
"964",":Answer","","","**Simple case with no cycles**

If you are using Neo4j 5.9+, you can use the following [quantified path pattern](https://neo4j.com/docs/cypher-manual/current/patterns/reference/#quantified-path-patterns) to get each distinct rule chain:
```sql
MATCH path = (:Rule {name: &#39;rule_1&#39;}) 
        (()-[:targets]-&gt;(:Variable)&lt;-[:depends_on]-(:Rule))+ (r) 
WHERE NOT EXISTS { (r)-[:targets]-&gt;(:Variable)&lt;-[:depends_on]-(:Rule) }
RETURN [n IN nodes(path) WHERE n:Rule | n.name] AS ruleChain
```

The `WHERE NOT EXISTS` is there to ensure the results include only the complete rule chains and not any subsets of them, as it makes sure there are no more rules to expand the rule chain to.

**Handling cycles in the rules graph**

If there are cycles in the rules graph, the above will return all unique pathways. In such a case, separating out the cycle-free rule chains from the cycles attached to those rules would be useful. This query returns the cycle-free rule chains:
```sql
MATCH (a:Rule {name: &#39;rule_1&#39;})
MATCH path = (a) (()-[:targets]-&gt;(:Variable)&lt;-[:depends_on]-(:Rule))+ (b) 
WHERE NOT EXISTS { (b)-[:targets]-&gt;(:Variable)&lt;-[:depends_on]-(:Rule) } 
AND COUNT { WITH path UNWIND nodes(path) AS n RETURN DISTINCT n } =
    size(nodes(path))
RETURN [n IN nodes(path) WHERE n:Rule | n.name] AS ruleChain
```
This returns all cycles that those rule chains encounter, including the variables they target:
```sql
MATCH (a:Rule {name: &#39;rule_1&#39;})
MATCH path = (a) (()-[:targets]-&gt;(:Variable)&lt;-[:depends_on]-(:Rule))+
UNWIND [n IN nodes(path) WHERE n:Rule] AS node
WITH DISTINCT node
MATCH path = (node) (()-[:targets]-&gt;(:Variable)&lt;-[:depends_on]-(:Rule))+ (node)
WHERE COUNT { WITH path UNWIND nodes(path)[..-1] AS n RETURN DISTINCT n } =
      size(nodes(path)[..-1])
RETURN [n IN nodes(path) | n.name] AS cycle
```","","","","true","https://stackoverflow.com/a/77779757","","2","Answer","How to fetch all nodes in neo4j for relationship (Node A)-[Relation A]-&gt;(Node B)-[Relation B]-&gt;(Node C)","false","77779757","",,,,,
"965",":Answer","","","This answer attempts to improve @FinbarGood&#39;s answer.

In the real world (and I presume in your use case as well), it is very common for a rule to both set *and* depend on the same variable (e.g., the rule may increment a numeric variable).

So, let&#39;s add some more rules to your sample graph:

    MATCH (r1:Rule {name:&#39;rule_1&#39;}), (v3:Variable {name:&#39;variable_3&#39;}), (v7:Variable {name:&#39;variable_7&#39;})
    CREATE
      (r5:Rule {name:&#39;rule_5&#39;}),
      (r6:Rule {name:&#39;rule_6&#39;}),
      (v8:Variable {name:&#39;variable_8&#39;}),
      (v9:Variable {name:&#39;variable_9&#39;}),
      (v10:Variable {name:&#39;variable_10&#39;})
    CREATE (r1)-[:targets]-&gt;(v8)&lt;-[:depends_on]-(r1)
    CREATE (r1)-[:targets]-&gt;(v9)&lt;-[:depends_on]-(r5)-[:targets]-&gt;(v10)&lt;-[:depends_on]-(r1)
    CREATE (r6)-[:depends_on]-&gt;(v7)
    CREATE (r1)-[:depends_on]-&gt;(v3)

The resulting graph will look like this:

![enter image description here](https://i.stack.imgur.com/XPuR1.png)

In the resulting chains, we should include &quot;looping&quot; chains that start and end at the same `Rule`, since those are valid rule paths. But once we have returned to the starting `Rule`, I will assume that we want to stop expanding any further (if there are multiple possible paths from that `Rule`), to avoid redundancy.

Here is a query that returns the names of the rules and variables along each chain (variable names are included because there can be multiple ways to connect the same sequence of rules):

    MATCH path = (r0:Rule {name: &#39;rule_1&#39;}) (()-[:targets]-&gt;(:Variable)&lt;-[:depends_on]-(:Rule))+ (r)
    WHERE (r = r0 AND NOT r0 IN NODES(path)[1..-1]) OR
      NOT (r0 IN NODES(path)[1..] OR EXISTS((r)-[:targets]-&gt;(:Variable)&lt;-[:depends_on]-(:Rule)))
    RETURN [n IN NODES(path)|n.name] AS chain

The results are as expected:

    ╒══════════════════════════════════════════════════════════════════════╕
    │chain                                                                 │
    ╞══════════════════════════════════════════════════════════════════════╡
    │[&quot;rule_1&quot;, &quot;variable_8&quot;, &quot;rule_1&quot;]                                    │
    ├──────────────────────────────────────────────────────────────────────┤
    │[&quot;rule_1&quot;, &quot;variable_3&quot;, &quot;rule_1&quot;]                                    │
    ├──────────────────────────────────────────────────────────────────────┤
    │[&quot;rule_1&quot;, &quot;variable_9&quot;, &quot;rule_5&quot;, &quot;variable_10&quot;, &quot;rule_1&quot;]           │
    ├──────────────────────────────────────────────────────────────────────┤
    │[&quot;rule_1&quot;, &quot;variable_3&quot;, &quot;rule_3&quot;, &quot;variable_7&quot;, &quot;rule_6&quot;]            │
    ├──────────────────────────────────────────────────────────────────────┤
    │[&quot;rule_1&quot;, &quot;variable_2&quot;, &quot;rule_2&quot;, &quot;variable_4&quot;, &quot;rule_4&quot;, &quot;variable_3│
    │&quot;, &quot;rule_1&quot;]                                                          │
    ├──────────────────────────────────────────────────────────────────────┤
    │[&quot;rule_1&quot;, &quot;variable_2&quot;, &quot;rule_2&quot;, &quot;variable_4&quot;, &quot;rule_4&quot;, &quot;variable_3│
    │&quot;, &quot;rule_3&quot;, &quot;variable_7&quot;, &quot;rule_6&quot;]                                  │
    └──────────────────────────────────────────────────────────────────────┘

NOTE: To avoid endless looping in the rule chain, rules like `rule_1` may need to be forced to only run once. This is actually rather easy to do using `MATCH` clauses, since a `MATCH` clause will only return results in which a relationship appears at most once.","","","","false","https://stackoverflow.com/a/77782956","","1","Answer","How to fetch all nodes in neo4j for relationship (Node A)-[Relation A]-&gt;(Node B)-[Relation B]-&gt;(Node C)","false","77782956","",,,,,
"966",":Comment","","","","","","","","https://stackoverflow.com/questions/77778088/how-to-fetch-all-nodes-in-neo4j-for-relationship-node-a-relation-a-node-b#comment137117541_77778088","","0","Comment","","false","137117541","",,,,,
"967",":Comment","","","","","","","","https://stackoverflow.com/questions/77778088/how-to-fetch-all-nodes-in-neo4j-for-relationship-node-a-relation-a-node-b#comment137117785_77778088","","1","Comment","","false","137117785","",,,,,
"968",":Comment","","","","","","","","https://stackoverflow.com/questions/77778088/how-to-fetch-all-nodes-in-neo4j-for-relationship-node-a-relation-a-node-b#comment137117891_77778088","","0","Comment","","false","137117891","",,,,,
"969",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/optimization","optimization","","Tag","","false","","",,,,,
"970",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/linear-programming","linear-programming","","Tag","","false","","",,,,,
"971",":Comment","","","","","","","","https://stackoverflow.com/questions/77769536/question-about-linear-programming-optimisation-in-graph-data-base-like-neo4j#comment137159405_77769536","","1","Comment","","false","137159405","",,,,,
"972",":User","","","","","Erwin Kalvelagen","","","","","","User","","false","5625534","",,,,,
"973",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/java","java","","Tag","","false","","",,,,,
"974",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/spring-boot","spring-boot","","Tag","","false","","",,,,,
"975",":Answer","","","I got the solution.

You need to write the query to return the specific result.

    MATCH path = (n:NodeABC)-[]-(i:NodeXYZ)
    WHERE n.name = &#39;iqwe&#39; 
    RETURN { id : id(n), labels : labels(n), properties: properties(n) } as instance, relationships(path)

Instead of return &#39;n&#39;, you need to specify like this &#39;

&gt; { id : id(n), labels : labels(n), properties: properties(n) }

&#39;

Thanks,

Atul","","","","false","https://stackoverflow.com/a/77768359","","1","Answer","Neo4j - get ID, Labels properties from the resultset","false","77768359","",,,,,
"976",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/kubernetes","kubernetes","","Tag","","false","","",,,,,
"977",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/terraform","terraform","","Tag","","false","","",,,,,
"978",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/kubernetes-helm","kubernetes-helm","","Tag","","false","","",,,,,
"979",":Answer","","","Okay, i figure out how this work, because the API version v1a1pha1 is deprecated So instead using the default api, use this:
apiVersion: client.authentication.k8s.io/v1beta1
Change this in file ~/.kube/config","","","","true","https://stackoverflow.com/a/77769042","","0","Answer","Terraform- Helm: Kubernetes cluster unreachable:exec plugin: invalid apiVersion &quot;client.authentication.k8s.io/v1alpha1&quot; while deploy neo4jHelm","false","77769042","",,,,,
"980",":Comment","","","","","","","","https://stackoverflow.com/questions/77768125/terraform-helm-kubernetes-cluster-unreachableexec-plugin-invalid-apiversion#comment137104826_77768125","","0","Comment","","false","137104826","",,,,,
"981",":User","","","","","David Maze","","","","","","User","","false","10008173","",,,,,
"982",":Answer","","","Disable &quot;Connect result nodes&quot; in the settings dialog at the bottom left:

[![Neo4j settings dialog: Graph Visualization][1]][1]

If the setting is enabled (which it is by default), then all connections between two nodes will always be shown, even if not explicitly returned by your query.

  [1]: https://i.stack.imgur.com/Y8EI6.png","","","","true","https://stackoverflow.com/a/77767414","","1","Answer","Neo4J WHERE cause not strict?","false","77767414","",,,,,
"983",":Comment","","","","","","","","https://stackoverflow.com/questions/77767333/neo4j-where-cause-not-strict#comment137102185_77767333","","1","Comment","","false","137102185","",,,,,
"984",":Answer","","","**For Neo4j 5.9+**

To return the subgraph up to but excluding any nodes beyond any relationships with `Action = &#39;ODC&#39;`:
```sql
MATCH (:Customer {customer_id: 4})-[r WHERE r.Action &lt;&gt; &#39;ODC&#39;]-*(n)
RETURN DISTINCT n
```
To return the subgraph up to and *including* those nodes:
```sql
MATCH path = (:Customer {customer_id: 4})-[r WHERE r.Action &lt;&gt; &#39;ODC&#39;]-*
               ()-[{Action: &#39;ODC&#39;}]-()
UNWIND nodes(path) AS n
RETURN DISTINCT n
```

**For Neo4j &lt; 5.9**

To return the subgraph up to but excluding any nodes beyond any relationships with `Action = &#39;ODC&#39;`:
```sql
MATCH (:Customer {customer_id: 4})-[r*0..]-(n)
WHERE all(rel IN r WHERE rel.Action &lt;&gt; &#39;ODC&#39;)
RETURN DISTINCT n
```
To return the subgraph up to and *including* those nodes:
```sql
MATCH path = (:Customer {customer_id: 4})-[r*0..]-()-[{Action: &#39;ODC&#39;}]-()
WHERE all(rel IN r WHERE rel.Action &lt;&gt; &#39;ODC&#39;)
UNWIND nodes(path) AS n
RETURN DISTINCT n
```","","","","true","https://stackoverflow.com/a/77757853","","2","Answer","In Neo4j how do i iteratively traverse the nodes and relationships paths obtained from the startnode till particular relationship property is reached?","false","77757853","",,,,,
"985",":Comment","","","","","","","","https://stackoverflow.com/questions/77756246/in-neo4j-how-do-i-iteratively-traverse-the-nodes-and-relationships-paths-obtaine#comment137089925_77756246","","0","Comment","","false","137089925","",,,,,
"986",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/igraph","igraph","","Tag","","false","","",,,,,
"987",":Comment","","","","","","","","https://stackoverflow.com/questions/77753801/query-pythons-igraph-as-if-it-would-be-a-neo4j-db#comment137079097_77753801","","0","Comment","","false","137079097","",,,,,
"988",":Comment","","","","","","","","https://stackoverflow.com/questions/77753801/query-pythons-igraph-as-if-it-would-be-a-neo4j-db#comment137079297_77753801","","0","Comment","","false","137079297","",,,,,
"989",":Comment","","","","","","","","https://stackoverflow.com/questions/77753801/query-pythons-igraph-as-if-it-would-be-a-neo4j-db#comment137083175_77753801","","0","Comment","","false","137083175","",,,,,
"990",":Comment","","","","","","","","https://stackoverflow.com/questions/77753801/query-pythons-igraph-as-if-it-would-be-a-neo4j-db#comment137089999_77753801","","0","Comment","","false","137089999","",,,,,
"991",":Comment","","","","","","","","https://stackoverflow.com/questions/77753801/query-pythons-igraph-as-if-it-would-be-a-neo4j-db#comment137094545_77753801","","0","Comment","","false","137094545","",,,,,
"992",":Comment","","","","","","","","https://stackoverflow.com/questions/77753801/query-pythons-igraph-as-if-it-would-be-a-neo4j-db#comment137099564_77753801","","0","Comment","","false","137099564","",,,,,
"993",":Answer","","","If I understand your requirements correctly, you want to find paths containing just outgoing relationships in which only the last relationship has the `Action` value of either &#39;ODC&#39; or &#39;ODSN&#39;. If the value is &#39;ODC&#39;, then you want all the nodes in the path returned, else you only want the last node.

That use case does not need to use APOC. For example:

    MATCH (c:Customer {customer_id: 4})-[rels1 *0..8]-&gt;()-[rel2:Action]-&gt;(n)
    WHERE rel2.Action IN [&#39;ODC&#39;, &#39;ODSN&#39;] AND NONE(r1 IN rels1 WHERE r1.Action IN [&#39;ODC&#39;, &#39;ODSN&#39;])
    WITH rel2.Action AS action, c, rels1, n
    RETURN action, CASE action WHEN &#39;ODC&#39; THEN [c] + [r2 IN rels1 | ENDNODE(r2)] + n ELSE [n] END AS nodes

Since it is best practice to put a reasonable upper bound on [variable length relationship](https://neo4j.com/docs/cypher-manual/current/patterns/reference/#variable-length-relationships) patterns (to avoid taking too long or running out of memory), this query searches paths up to 9 (i.e., 8 + 1) relationships deep (adjust as necessary to suit your actual data).

If `action` is &#39;ODC&#39;, then all the nodes in the path are returned in the `nodes` list, else the list contains only the last node.","","","","false","https://stackoverflow.com/a/77748593","","0","Answer","How to use apoc.path.subgraphAll procedure in Neo4j","false","77748593","",,,,,
"994",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/spring-batch","spring-batch","","Tag","","false","","",,,,,
"995",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-ogm","neo4j-ogm","","Tag","","false","","",,,,,
"996",":Comment","","","","","","","","https://stackoverflow.com/questions/77744069/spring-batch-still-compatible-and-usable-with-spring-data-neo4j-7-2-1#comment137205151_77744069","","1","Comment","","false","137205151","",,,,,
"997",":Answer","","","If you are using the Java Driver, see [here](https://neo4j.com/docs/java-manual/current/session-api/#java-driver-simple-transaction-fn) for some relevant documentation.

If you are using the Java API, see [here](https://neo4j.com/docs/java-reference/current/transaction-management/)","","","","false","https://stackoverflow.com/a/77733990","","0","Answer","Are transactions In Neo4j default or should I manually handle it.I am using Neo4j from Java using the neo4j driver.How should i manage transactions?","false","77733990","",,,,,
"998",":Comment","","","","","","","","https://stackoverflow.com/questions/77728734/database-neo4j-not-up-to-the-requested-version#comment137032554_77728734","","1","Comment","","false","137032554","",,,,,
"999",":Comment","","","","","","","","https://stackoverflow.com/questions/77728734/database-neo4j-not-up-to-the-requested-version#comment137032564_77728734","","0","Comment","","false","137032564","",,,,,
"1000",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/parquet","parquet","","Tag","","false","","",,,,,
"1001",":Comment","","","","","","","","https://stackoverflow.com/questions/77725935/neo4j-to-load-parquet-file-multiple-element-with-the-same-key-found-but-the-el#comment137032515_77725935","","0","Comment","","false","137032515","",,,,,
"1002",":Comment","","","","","","","","https://stackoverflow.com/questions/77725935/neo4j-to-load-parquet-file-multiple-element-with-the-same-key-found-but-the-el#comment137034624_77725935","","0","Comment","","false","137034624","",,,,,
"1003",":Answer","","","An error message like &quot;Unable to register procedure, because the name apoc.atomic.add is already in use.&quot; usually indicates that there are multiple APOC plugins.

Check your docker configuration to make sure it does not install multiple APOC plugins.","","","","false","https://stackoverflow.com/a/77728832","","0","Answer","Neo4j not able to start using apoc plugin","false","77728832","",,,,,
"1004",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/ruby-on-rails","ruby-on-rails","","Tag","","false","","",,,,,
"1005",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/ruby-on-rails-5.2","ruby-on-rails-5.2","","Tag","","false","","",,,,,
"1006",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/ruby-2.7","ruby-2.7","","Tag","","false","","",,,,,
"1007",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/ubuntu","ubuntu","","Tag","","false","","",,,,,
"1008",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/networking","networking","","Tag","","false","","",,,,,
"1009",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/connection","connection","","Tag","","false","","",,,,,
"1010",":Answer","","","I just tried the default configuration, which I assumed would only work locally, and to my surprise it started responding to remote requests through the domain name.
```
    curl http://&lt;server-domain&gt;:7474
    
    {
      &quot;bolt_routing&quot; : &quot;neo4j://&lt;server-domain&gt;:7687&quot;,
      &quot;transaction&quot; : &quot;http://&lt;server-domain&gt;:7474/db/{databaseName}/tx&quot;,
      &quot;bolt_direct&quot; : &quot;bolt://&lt;server-domain&gt;:7687&quot;,
      &quot;neo4j_version&quot; : &quot;5.15.0&quot;,
      &quot;neo4j_edition&quot; : &quot;community&quot;
    }
```

So despite I did not set the specific server domain name nor the server&#39;s public IP address, Neo4j accepted connections through those.

Looking closer the Operation Manual documentation for the [server.default_listen_address setting][1] it reads:

&gt; To listen for connections on all interfaces, use &quot;0.0.0.0&quot;.

So my interpretation is that changing the default value &quot;localhost&quot; to &quot;0.0.0.0&quot; in the configuration parameters was enough and all the other specific settings are redundant in this case:

```
    --env NEO4J_server_default__listen__address=0.0.0.0 \
```

  [1]: https://neo4j.com/docs/operations-manual/current/configuration/configuration-settings/#config_server.default_listen_address","","","","false","https://stackoverflow.com/a/77728125","","0","Answer","Docker Neo4j 5.15.0 community error when using public IP address","false","77728125","",,,,,
"1011",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/google-drive-api","google-drive-api","","Tag","","false","","",,,,,
"1012",":Comment","","","","","","","","https://stackoverflow.com/questions/77722165/read-my-json-files-from-google-drive-with-python-i-want-to-transfer-to-neo4j-dat#comment137024223_77722165","","0","Comment","","false","137024223","",,,,,
"1013",":Comment","","","","","","","","https://stackoverflow.com/questions/77722165/read-my-json-files-from-google-drive-with-python-i-want-to-transfer-to-neo4j-dat#comment137142982_77722165","","0","Comment","","false","137142982","",,,,,
"1014",":Answer","","","verify that the two containers (services) are in the same network. 

And you need to specify that you want to start the Second container when the first one  have finish.","","","","false","https://stackoverflow.com/a/77722181","","-1","Answer","How to dockerize springboot app with Neo4j","false","77722181","",,,,,
"1015",":User","","","","","peti Nono","","","","","","User","","false","8863301","",,,,,
"1016",":Comment","","","","","","","","https://stackoverflow.com/questions/77720317/how-to-dockerize-springboot-app-with-neo4j#comment137019906_77720317","","0","Comment","","false","137019906","",,,,,
"1017",":Comment","","","","","","","","https://stackoverflow.com/questions/77720317/how-to-dockerize-springboot-app-with-neo4j#comment137026256_77720317","","0","Comment","","false","137026256","",,,,,
"1018",":Comment","","","","","","","","https://stackoverflow.com/questions/77720317/how-to-dockerize-springboot-app-with-neo4j#comment137029375_77720317","","0","Comment","","false","137029375","",,,,,
"1019",":Comment","","","","","","","","https://stackoverflow.com/questions/77720317/how-to-dockerize-springboot-app-with-neo4j#comment137034677_77720317","","0","Comment","","false","137034677","",,,,,
"1020",":Comment","","","","","","","","https://stackoverflow.com/questions/77720317/how-to-dockerize-springboot-app-with-neo4j#comment137034696_77720317","","0","Comment","","false","137034696","",,,,,
"1021",":Comment","","","","","","","","https://stackoverflow.com/questions/77720317/how-to-dockerize-springboot-app-with-neo4j#comment137035373_77720317","","0","Comment","","false","137035373","",,,,,
"1022",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/json","json","","Tag","","false","","",,,,,
"1023",":Answer","","","### Workaround

I wrote a little python script to convert the exported json in to a cypher `CREATE` instruction. It should create the database content as exported previously.

If the exported json has additional properties that are not treated by this script, it prints at least a list of &quot;errors&quot; which are just these ignored parts of the json input, so that the user can manually check.

```python
import argparse
import json

def main(file_path):
    with open(file_path) as my_file:
        
        data = []
        for line in my_file:
            data.append(json.loads(line))
        
        instruction = &#39;CREATE\n&#39;
        for json_obj in data:
            if json_obj[&#39;type&#39;] == &#39;node&#39;:
                node_id = json_obj[&#39;id&#39;]
                json_obj.pop(&#39;id&#39;)
                label_clause = &#39;&#39;
                if &#39;labels&#39; in json_obj:
                    for label in json_obj[&#39;labels&#39;]:
                        label_clause = label_clause + &#39;:&#39; + label
                    json_obj.pop(&#39;labels&#39;)
                property_clause = &#39;&#39;
                if &#39;properties&#39; in json_obj:
                    property_clause += &#39;{  &#39;
                    for key in json_obj[&#39;properties&#39;]:
                        property_clause += key
                        if isinstance(json_obj[&#39;properties&#39;][key], str):
                            property_clause += &quot; : \&quot;&quot;
                            property_clause += json_obj[&#39;properties&#39;][key]
                            property_clause += &quot;\&quot;, &quot;
                        else:
                            property_clause += &quot; : &quot;
                            property_clause += str(json_obj[&#39;properties&#39;][key])
                            property_clause += &quot;, &quot;
                        
                    property_clause = property_clause[:-2]
                    property_clause += &#39;}&#39;
                    json_obj.pop(&#39;properties&#39;)
                instruction += &#39; (node_{}{}{}),\n&#39;.format(node_id, label_clause, property_clause)
        for json_obj in data:
            if json_obj[&#39;type&#39;] == &#39;relationship&#39;:
                relationship_id = json_obj[&#39;id&#39;]
                json_obj.pop(&#39;id&#39;)
                from_id = json_obj[&#39;start&#39;][&#39;id&#39;]
                json_obj.pop(&#39;start&#39;)
                to_id = json_obj[&#39;end&#39;][&#39;id&#39;]
                json_obj.pop(&#39;end&#39;)
                
                label_clause = &#39;&#39;
                if &#39;label&#39; in json_obj:
                    label_clause = &#39;:{}&#39;.format(json_obj[&#39;label&#39;])
                    json_obj.pop(&#39;label&#39;)
                
                relation_clause = &#39;relationship_{}{}&#39;.format(relationship_id, label_clause)
                
                instruction += &#39; (node_{})-[{}]-&gt;(node_{}),\n&#39;.format(from_id, relation_clause, to_id)
        print(&#39;ERRORS:\n&#39;) # should print anything from the original json which has been ignored by the code above
        for json_obj in data:
            json_obj.pop(&#39;type&#39;)
            if bool(json_obj):
                print(json_obj)
                print()
        
        print()
        print()
        print()
        print()
        
        
        instruction = instruction[:-2] + &#39;;\n&#39;
        
        with open(&quot;instruction.txt&quot;, &#39;w&#39;) as out_file:
            out_file.write(instruction)
        print(data)
    

    
if __name__ == &#39;__main__&#39;:
    parser = argparse.ArgumentParser(description=&#39;input parser&#39;)
    parser.add_argument(&#39;--file&#39;, metavar=&#39;path&#39;, required=True,
                        help=&#39;the path to the exported json file&#39;)
    args = parser.parse_args()
    print(args.file)
    main(file_path=args.file)
```","","","","false","https://stackoverflow.com/a/77731803","","0","Answer","Migrating neo4j database content / apoc.import.json not working","false","77731803","",,,,,
"1024",":Comment","","","","","","","","https://stackoverflow.com/questions/77715125/migrating-neo4j-database-content-apoc-import-json-not-working#comment137024159_77715125","","0","Comment","","false","137024159","",,,,,
"1025",":Comment","","","","","","","","https://stackoverflow.com/questions/77715125/migrating-neo4j-database-content-apoc-import-json-not-working#comment137037414_77715125","","0","Comment","","false","137037414","",,,,,
"1026",":Comment","","","","","","","","https://stackoverflow.com/questions/77715125/migrating-neo4j-database-content-apoc-import-json-not-working#comment137041290_77715125","","0","Comment","","false","137041290","",,,,,
"1027",":Answer","","","To begin with, when you do two MATCH statements in a row like that you will create a cartesian product, which is always a danger in Cypher. The result will be one row for every combination of two :ENCODING relationships in the database. If you have 1000 :ENCODING relationships you will get 1000000 rows. You limit this with WHERE elementId(bgc1) &lt; elementId(bgc2) but you will already have created the cartesian product.

So we need to rewrite it to remove the need for that.

Secondly I get a feeling that the calculation of notCommon is incorrect. You base it on the number of paths, not the number of nodes. So it will be correct in the image you show, but not in your example data (at least if I understand you formula correctly).

Finally, you match two paths, the direct paths and the indirect paths. But in the formula you only use the sum of the two, i.e. all paths. So you don&#39;t really care what is direct and indirect. Due to this we only need one path match that covers both direct and indirect by changing 1..5 to 0..5. This also means that we can use this as the base MATCH instead of the cartesian product.

I have made a version that looks like this. Here I start first by just counting the number of proteins in the graph, to later use it to calculate notCommon:

    MATCH (p:protein)
    WITH COUNT(p) AS proteinCount
    
    MATCH pathAll = (bgc1:bgc)-[:ENCODING]-&gt;(:protein)-[:MMSEQS_90*0..5]-(:protein)&lt;-[:ENCODING]-(bgc2:bgc)
    WHERE elementId(bgc1) &lt; elementId(bgc2)
    
    WITH bgc1, bgc2, SUM(SIZE([n IN nodes(pathAll) WHERE &quot;protein&quot; IN labels(n)])) AS commonProteins, COUNT(DISTINCT pathAll) AS pathsAll, proteinCount
    WITH bgc1, bgc2, pathsAll, proteinCount-commonProteins AS notCommon
    
    WITH bgc1, bgc2, 100 * pathsAll / (pathsAll + notCommon) AS similarity_score
    WHERE similarity_score &gt; 0.0  
    
    MERGE (bgc1)-[:IS_SIMILAR {score: similarity_score}]-&gt;(bgc2)
    
    RETURN bgc1.id AS BGC1, bgc2.id AS BGC2, similarity_score
    ORDER BY similarity_score DESC, BGC1, BGC2

I don&#39;t get the same results as you get, but when I try to apply the formula manually I get the same results as my version. It might be that I have misunderstood your formula, but hopefully you can use something from my version anyway.

By the way, really nice that you provided all the MERGE statements to create your example graph. It made it a lot easier to help you :)","","","","false","https://stackoverflow.com/a/77702826","","1","Answer","Neo4J: How to calculate similarity score based on number of existing paths?","false","77702826","",,,,,
"1028",":Answer","","","Your first 2 clauses create a [cartesian product](https://stackoverflow.com/questions/33352673/why-does-neo4j-warn-this-query-builds-a-cartesian-product-between-disconnected), which one should try to avoid:

    MATCH (bgc1:bgc)-[:ENCODING]-&gt;(p1:protein)
    MATCH (bgc2:bgc)-[:ENCODING]-&gt;(p2:protein)

This especially applies when the cartesian product produces mostly unwanted results. In your use case, I suspect that the vast majority of `bcg` pairs (which could be in the millions if you have thousands of encodings) would end up being dropped by your query anyway (if it ever completed).

A better approach would be to use a single `MATCH` that finds wanted paths (both direct and indirect) between `bcg` nodes. That way, you not only simplify the query but you also naturally only get wanted `bcg` pairs:

    MATCH (bgc1:bgc)-[:ENCODING]-&gt;()-[:MMSEQS_90*0..5]-()&lt;-[:ENCODING]-(bgc2:bgc)
    WHERE elementId(bgc1) &lt; elementId(bgc2)
    
    WITH bgc1, bgc2,
      100 * COUNT(*) / (COUNT {(b)-[:ENCODING]-&gt;() WHERE b IN [bgc1, bgc2]} - COUNT(*)) AS similarity_score

    MERGE (bgc1)-[:IS_SIMILAR {score: similarity_score}]-&gt;(bgc2)
    RETURN bgc1.id AS BGC1, bgc2.id AS BGC2, similarity_score
    ORDER BY similarity_score DESC, BGC1, BGC2;

Notes:
 1. I fixed what seems like a bug in your query. In the `notCommon` calculation, I used a [COUNT subquery](https://neo4j.com/docs/cypher-manual/current/subqueries/count/) (introduced in neo4j 5.0) to count the number of `ENCODING` relationships for `bgc1` and `bgc2`. This produces your expected results.

 2. The `0` lower bound in the variable length path pattern `0..5` allows &quot;direct&quot; paths to be matched.

 3. If the `score` ever changed between a pair of nodes, then the `MERGE` clause above would create an additional `IS_SIMILAR` relationship. If this is a concern, you can avoid that by replacing that `MERGE` clause with:

        MERGE (bgc1)-[s:IS_SIMILAR]-&gt;(bgc2)
        SET s.score = similarity_score","","","","true","https://stackoverflow.com/a/77705741","","1","Answer","Neo4J: How to calculate similarity score based on number of existing paths?","false","77705741","",,,,,
"1029",":Answer","","","Well formulated question!! Kudos

In addition to the other suggestions, two other thoughts ...

1) the neo4j.conf file memory setting might be increased to avoid any RAM issues.

2) I often collect the item to be iterated and then unwind if with a call statement. This is generally more efficient in therms of code and CPUs used. In you case you may need nested calls.

    with w, collect (x) as y
    unwind y as z
    call
    {
    with z
    ... do something ...
    return answers 
    }
    ... more code with w and answer..


 


","","","","false","https://stackoverflow.com/a/77711481","","0","Answer","Neo4J: How to calculate similarity score based on number of existing paths?","false","77711481","",,,,,
"1030",":User","","","","","David A Stumpf","","","","","","User","","false","4414246","",,,,,
"1031",":Answer","","","Sooo, parenthesis are my enemy.

```
var maybeRecord = session.executeRead(tx -&gt; tx.run(&quot;MATCH (c:Category { id:$id }) RETURN c&quot;, parameters(&quot;bggId&quot;, id)))
                    .stream()
                    .findFirst();
```

Should be:
```
var maybeRecord = session.executeRead(tx -&gt; tx.run(&quot;MATCH (c:Category { id:$id }) RETURN c&quot;, parameters(&quot;bggId&quot;, id))
                    .stream()
                    .findFirst());
```

Thanks @shmosel for the comment that answered this question.","","","","false","https://stackoverflow.com/a/77694845","","0","Answer","Why can&#39;t I stream transaction results from Neo4J Bolt Driver","false","77694845","",,,,,
"1032",":Comment","","","","","","","","https://stackoverflow.com/questions/77694771/why-cant-i-stream-transaction-results-from-neo4j-bolt-driver#comment136973508_77694771","","0","Comment","","false","136973508","",,,,,
"1033",":User","","","","","shmosel","","","","","","User","","false","1553851","",,,,,
"1034",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/nginx","nginx","","Tag","","false","","",,,,,
"1035",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/kubernetes-ingress","kubernetes-ingress","","Tag","","false","","",,,,,
"1036",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/azure-aks","azure-aks","","Tag","","false","","",,,,,
"1037",":Answer","","","To configure two separate Neo4j instances in an AKS cluster and direct traffic to them using Nginx Ingress based on URL paths, follow these instructions:

#### **Step 1: Install Nginx Ingress Controller**

Firstly, add the Helm repository for Nginx Ingress and install it:

    helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
    helm repo update
    helm install ingress-nginx ingress-nginx/ingress-nginx --create-namespace --namespace ingress-nginx

![enter image description here](https://i.imgur.com/JtRZL04.png)

#### **Step 2: Deploy Neo4j Instances**

Create Kubernetes deployment files for each Neo4j instance.  For the first database (`db-1`):
```yaml
#File: db1-deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: neo4j-db1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: neo4j-db1
  template:
    metadata:
      labels:
        app: neo4j-db1
    spec:
      containers:
        - name: neo4j
          image: neo4j:latest
          env:
            - name: NEO4J_AUTH
              value: &quot;neo4j/your_password_here&quot;
          ports:
            - containerPort: 7474
              name: http
            - containerPort: 7687
              name: bolt
```

For the second database (`db-2`):

```yaml
#File: db2-deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: neo4j-db2
spec:
  replicas: 1
  selector:
    matchLabels:
      app: neo4j-db2
  template:
    metadata:
      labels:
        app: neo4j-db2
    spec:
      containers:
        - name: neo4j
          image: neo4j:latest
          env:
            - name: NEO4J_AUTH
              value: &quot;neo4j/your_password_here&quot;
          ports:
            - containerPort: 7474
              name: http
            - containerPort: 7687
              name: bolt
```
Deploy these configurations using:

```bash
kubectl apply -f db1-deployment.yaml 
kubectl apply -f db2-deployment.yaml
```
![enter image description here](https://i.imgur.com/jWGK0Ec.png)

#### **Step 3: Expose Neo4j Services**

Now, define services for each Neo4j deployment. 
For `db-1`:

```yaml
# db1-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: neo4j-db1-service
spec:
  type: ClusterIP
  ports:
    - name: http
      protocol: TCP
      port: 7474
      targetPort: 7474
    - name: bolt
      protocol: TCP
      port: 7687
      targetPort: 7687
  selector:
    app: neo4j-db1
```
For `db-2`:

```yaml
# db2-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: neo4j-db2-service
spec:
  type: ClusterIP
  ports:
    - name: http
      protocol: TCP
      port: 7474
      targetPort: 7474
    - name: bolt
      protocol: TCP
      port: 7687
      targetPort: 7687
  selector:
    app: neo4j-db1
```

apply them:
```bash
kubectl apply -f db1-service.yaml
kubectl apply -f db2-service.yaml
```
![enter image description here](https://i.imgur.com/hXo33vE.png)

#### **Step 4: Configure Ingress for Routing**

Set up an Ingress resource to route the external requests:

```yaml
# File: neo4j-ingress.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: neo4j-ingress
spec:
  ingressClassName: nginx
  rules:
    - http:
        paths:
          - path: /db1
            pathType: Prefix
            backend:
              service:
                name: neo4j-db1-service
                port:
                  number: 7474
          - path: /db2
            pathType: Prefix
            backend:
              service:
                name: neo4j-db2-service
                port:
                  number: 7474
```

apply it using `kubectl apply -f neo4j-ingress.yaml`

![enter image description here](https://i.imgur.com/dAbQtcH.png)

Once you&#39;ve applied the above configurations, create a ConfigMap for TCP routing:
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-ingress-tcp
  namespace: ingress-nginx
data:
  &quot;7687&quot;: &quot;default/neo4j-db1-service:7687&quot;
```
Apply the ConfigMap: 
`kubectl apply -f tcp-routing-configmap.yaml`
![enter image description here](https://i.imgur.com/anqXD8P.png)

Then, update the Nginx Ingress Controller deployment to use this ConfigMap for TCP services:
`kubectl edit deployment ingress-nginx-controller -n ingress-nginx`

Add the `--tcp-services-configmap=default/nginx-ingress-tcp` argument under `spec.template.spec.containers[0].args`.

![enter image description here](https://i.imgur.com/CYbplyw.png)

After applying the above configurations, you should be able to access your Neo4j instances at `http://&lt;external-ip&gt;/db1` for HTTP and `&lt;external-ip&gt;:7687` for Bolt. Find the external IP of your Nginx ingress controller with:

    kubectl get svc -n ingress-nginx
![enter image description here](https://i.imgur.com/DuWSHNP.png)","","","","false","https://stackoverflow.com/a/77702006","","0","Answer","Unable to access specific neo4j database exposed using AKS","false","77702006","",,,,,
"1038",":User","","","","","Arko","","","","","","User","","false","22600697","",,,,,
"1039",":Comment","","","","","","","","https://stackoverflow.com/questions/77689238/unable-to-access-specific-neo4j-database-exposed-using-aks#comment136964720_77689238","","0","Comment","","false","136964720","",,,,,
"1040",":Comment","","","","","","","","https://stackoverflow.com/questions/77689238/unable-to-access-specific-neo4j-database-exposed-using-aks#comment136966292_77689238","","0","Comment","","false","136966292","",,,,,
"1041",":Comment","","","","","","","","https://stackoverflow.com/questions/77689238/unable-to-access-specific-neo4j-database-exposed-using-aks#comment136966616_77689238","","0","Comment","","false","136966616","",,,,,
"1042",":Comment","","","","","","","","https://stackoverflow.com/questions/77689238/unable-to-access-specific-neo4j-database-exposed-using-aks#comment136967058_77689238","","0","Comment","","false","136967058","",,,,,
"1043",":Comment","","","","","","","","https://stackoverflow.com/questions/77684255/about-crashing-during-a-2hop-query-operation-in-neo4j#comment136960274_77684255","","2","Comment","","false","136960274","",,,,,
"1044",":Comment","","","","","","","","https://stackoverflow.com/questions/77684255/about-crashing-during-a-2hop-query-operation-in-neo4j#comment136971629_77684255","","0","Comment","","false","136971629","",,,,,
"1045",":Answer","","","[UPDATED]

You are asking the Browser to **display** 103 MB of data, which may be overtaxing it. The Browser is not really designed to display that much data all at once.

TO BE CLEAR: the issue is not that the neo4j server cannot handle huge amounts of inout data (it certainly can), but with asking the Browser to display huge amounts of data.

#### If JSON file contains an array of objects

In this case, the `apoc.load.json` procedure returns each object in a separate row. Try showing just a portion of the array (say, the first 50 items, which will still take up about 800 KB):

    CALL apoc.load.json(&quot;file:///&lt;client_name&gt;/data_dump/&lt;file_name.json&gt;&quot;) YIELD value
    RETURN value
    LIMIT 50

#### If JSON file contains an object that contains an array of sub-objects

In this case, the `apoc.load.json` procedure will return the outer object (with all 103 MB of data) in a single row. If   &quot;items&quot; is the key of the array in the outer object, you can show just a portion of the array (say, the first 50 items) this way:

    CALL apoc.load.json(&quot;file:///&lt;client_name&gt;/data_dump/&lt;file_name.json&gt;&quot;) YIELD value
    UNWIND value.items AS item
    RETURN item
    LIMIT 50","","","","false","https://stackoverflow.com/a/77687158","","0","Answer","Neo4j Browser blank screen with error when loading json using apoc.load.json","false","77687158","",,,,,
"1046",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/node.js","node.js","","Tag","","false","","",,,,,
"1047",":Answer","","","Solved it, 

Needed to add this to context

```
 sessionConfig: { database: &quot;myNeoGraph&quot; }
```","","","","false","https://stackoverflow.com/a/77682353","","0","Answer","Cannot query nodes","false","77682353","",,,,,
"1048",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neomodel","neomodel","","Tag","","false","","",,,,,
"1049",":Answer","","","I think it&#39;s because you have `ID` capitalized. 

Also, it looks like you&#39;re naming the python variable with `id`. That&#39;s already a [python function](https://docs.python.org/3/library/functions.html), so I&#39;d recommend naming the variable something like `databaseId`. You code would become...

```python
from neomodel import db
query=&quot;MATCH (n:Message) WHERE id(n)=&quot;+databaseId+&quot; SET n.type=&#39;&quot;+str(ans)+&quot;&#39;, n.reprimands=&#39;&quot;+str(ans2)+&quot;&#39;&quot;
db.cypher_query(query)
```

The cypher would look something like this:

```cypher
MATCH (n:Message)
  WHERE id(n) = 123
SET n.type = &quot;some type&quot;,
    n.reprimands = &quot;some reprimands&quot;
```","","","","false","https://stackoverflow.com/a/77847239","","0","Answer","Neo4j- How can I match by using the internal ID","false","77847239","",,,,,
"1050",":User","","","","","B D T","","","","","","User","","false","9312373","",,,,,
"1051",":Comment","","","","","","","","https://stackoverflow.com/questions/77674898/neo4j-how-can-i-match-by-using-the-internal-id#comment136949651_77674898","","1","Comment","","false","136949651","",,,,,
"1052",":Answer","","","Your `MATCH` clause must specify the *node label* (in addition to the node property) associated with a node index in order for the Cypher planner to consider using that index.

This query should be much faster:

    CALL apoc.periodic.iterate(
    &quot;LOAD CSV WITH HEADERS FROM &#39;file:///cleaned_follows_output.csv&#39; AS row RETURN row&quot;,
    &quot;MATCH (u1:User {id: row._s}), (u2:User {id: row._t}) MERGE (u1)-[:FOLLOWING]-&gt;(u2)&quot;,
    {batchSize: 10000, parallel: true}
    );","","","","true","https://stackoverflow.com/a/77681301","","2","Answer","Neo4J- Improve LoadCSV relations query time","false","77681301","",,,,,
"1053",":Comment","","","","","","","","https://stackoverflow.com/questions/77674781/neo4j-improve-loadcsv-relations-query-time#comment136950207_77674781","","1","Comment","","false","136950207","",,,,,
"1054",":User","","","","","InverseFalcon","","","","","","User","","false","92359","",,,,,
"1055",":Comment","","","","","","","","https://stackoverflow.com/questions/77660729/failed-to-invoke-apoc-procedure-that-was-working-just-a-minute-ago#comment136914674_77660729","","0","Comment","","false","136914674","",,,,,
"1056",":Comment","","","","","","","","https://stackoverflow.com/questions/77660729/failed-to-invoke-apoc-procedure-that-was-working-just-a-minute-ago#comment137286650_77660729","","0","Comment","","false","137286650","",,,,,
"1057",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/sorting","sorting","","Tag","","false","","",,,,,
"1058",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/entity","entity","","Tag","","false","","",,,,,
"1059",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/bloom","bloom","","Tag","","false","","",,,,,
"1060",":Answer","","","In Bloom at the bottom right of the perspective view you can select the layout algorithm to use to display nodes and relationships: in your case you could use a hierarchical layout or if you have measurable and meaningful properties you could use the coordinate layout and distribute your nodes based on those.


[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/OwXsO.jpg","","","","false","https://stackoverflow.com/a/77685267","","0","Answer","Does Neo4j Bloom can sort the entities in visualization?","false","77685267","",,,,,
"1061",":User","","","","","yetanotheruser","","","","","","User","","false","23100558","",,,,,
"1062",":Comment","","","","","","","","https://stackoverflow.com/questions/77657328/does-neo4j-bloom-can-sort-the-entities-in-visualization#comment136934352_77657328","","0","Comment","","false","136934352","",,,,,
"1063",":User","","","","","AztecCodes","","","","","","User","","false","13867124","",,,,,
"1064",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/browser","browser","","Tag","","false","","",,,,,
"1065",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/localhost","localhost","","Tag","","false","","",,,,,
"1066",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/cloud","cloud","","Tag","","false","","",,,,,
"1067",":Answer","","","You could create a neo4j AuraDB free instance, then you can connect to it through your local neo4j browser through neo4j desktop:

 - create a new project
 - click on Add -&gt; remote connection
 - insert the credential you got after creating the AuraDB instance
 - click connect and open neo4j browser","","","","false","https://stackoverflow.com/a/77659778","","1","Answer","How can i migrate from localhost neo4j browser to cloud?","false","77659778","",,,,,
"1068",":Answer","","","For dynamic Cypher statements, the apoc library (https://neo4j.com/docs/apoc/current/cypher-execution/running-cypher/) offers the possibilities you need. ","","","","false","https://stackoverflow.com/a/77654754","","0","Answer","neo4j table where a list of node keys defines the columns for RETURN","false","77654754","",,,,,
"1069",":User","","","","","Graphileon","","","","","","User","","false","1734996","",,,,,
"1070",":Answer","","","Your second query should fail because the `RETURN *` is projecting out variables that have already been declared in the outer scope e.g. `v_globalcustid`.

To address your original problem, just return `null`:
```sql
CALL {
  // other stuff
  CALL apoc.merge.relationship(
    m, 
    r.relationship.label,
    { 
      createdate: r.relationship.createdate, 
      enddate: r.relationship.enddate, 
      value: r.relationship.value
    },
    {},
    tag_node,
    {}
  ) YIELD rel
  RETURN null AS discard
} IN TRANSACTIONS OF 10000 ROWS
RETURN null
```
This is necessary because `CALL` subqueries have to conclude with either a `RETURN` or a write operation such as `CREATE`. Although `apoc.merge.relationship` does perform writes, Cypher treats it as a read operation that has to return a value.","","","","false","https://stackoverflow.com/a/77652644","","0","Answer","Neo4j process a json file in batch","false","77652644","",,,,,
"1071",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/express","express","","Tag","","false","","",,,,,
"1072",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-admin","neo4j-admin","","Tag","","false","","",,,,,
"1073",":Comment","","","","","","","","https://stackoverflow.com/questions/77646287/neo4j-dump-fails-with-integer-overflow-error#comment136893109_77646287","","0","Comment","","false","136893109","",,,,,
"1074",":Answer","","","In the topmost MATCH statement, I didn&#39;t define a name for the Relationships, such as r1, so the returned data did not include these relationships. Oddly enough, the browser managed to return data using the unnamed Cypher, which might involve some behind-the-scenes processing. By modifying the Cypher query, I have resolved this issue.","","","","false","https://stackoverflow.com/a/77633889","","0","Answer","The same Cypher query yields inconsistent results between the SDK and the browser, with several Relationships missing","false","77633889","",,,,,
"1075",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-browser","neo4j-browser","","Tag","","false","","",,,,,
"1076",":Answer","","","In the neo4j browser, the `connect result nodes` option is enabled by default. 

[![enter image description here][1]][1]

When you return nodes from queries, the browser will make in the background an additional query for finding relationships between the nodes and automatically display them.

For example, if I would return only two nodes with Cypher

```
MATCH (n:Person {name: &quot;Christophe&quot;})
MATCH (s:Song {title: &quot;Numb&quot;})
RETURN n, s
```

It will find there is an existing relationship between them in the background and will fetch it from the database and display it

[![enter image description here][2]][2]


  [1]: https://i.stack.imgur.com/f1cL7.png
  [2]: https://i.stack.imgur.com/TcVZr.png","","","","false","https://stackoverflow.com/a/77631068","","0","Answer","Neo4j Web Browser : Display phantom data (data does not exists on server)","false","77631068","",,,,,
"1077",":Comment","","","","","","","","https://stackoverflow.com/questions/77630912/neo4j-web-browser-display-phantom-data-data-does-not-exists-on-server#comment136880299_77630912","","0","Comment","","false","136880299","",,,,,
"1078",":Comment","","","","","","","","https://stackoverflow.com/questions/77630912/neo4j-web-browser-display-phantom-data-data-does-not-exists-on-server#comment136880615_77630912","","0","Comment","","false","136880615","",,,,,
"1079",":Answer","","","The frequency of graph changes will determine if you should batch or not.

To your main question, FastRP depends on a node and its neighbors, the neighbors of those, the neighbors of those, etc.

There&#39;s a configuration parameter IterationWeights which does two things:
1. Determines the number of neighbor-neighbor-neighbors to look at.
2. Determines how relevant each degree of separation is.

If you set IterationWeights to [1.0], FastRP will only look at immediate neighbors.

&lt;s&gt;If you use [0.0, 1.0] then first and second-degree neighbors will be used, weighted equally.&lt;/s&gt;

The above should be more accurately stated as &quot;The first iteration looks only at direct neighbors. The second iteration looks at direct and 2nd degree neighbors. Using [0.0, 1.0] set the number of iterations at 2 and means the second iteration results will be used exclusively.&quot; It was not correct to say &quot;weighted equally.&quot;

To update your embeddings when changes occur, let&#39;s say you&#39;re using second-degree neighbors and your node A changes. Create a projection with just A, its neighbors and neighbor-neighbors, and run FastRP in write mode.

Same idea for batch updates, just select the nodes that have changed and everything up to 2 hops out from those.","","","","true","https://stackoverflow.com/a/77622086","","2","Answer","Updating Neo4j Embeddings on Graph Change","false","77622086","",,,,,
"1080",":User","","","","","Vincent Rupp","","","","","","User","","false","4024409","",,,,,
"1081",":Answer","","","Assuming `id` and `type` are properties, this works:
```sql
MATCH (n0 {id: &quot;A&quot;})--(n1 {type:2})--(n2)
WHERE n2.id IN [&quot;D&quot;, &quot;E&quot;]
WITH collect(DISTINCT [n0, n1]) AS r1, collect(DISTINCT [n1, n2]) AS r2
WITH 
    COLLECT {
        WITH r1
        UNWIND r1 AS r
        WITH r[0].id AS lhs, &#39;type&#39; + r[1].type AS rhs, count(*) AS num
        RETURN {lhs: lhs, rhs: rhs, num: num }
    } AS first, 
    COLLECT {
        WITH r2
        UNWIND r2 AS r
        WITH &#39;type&#39; + r[0].type AS lhs, r[1].id AS rhs, count(*) AS num
        RETURN {lhs: lhs, rhs: rhs, num: num }
    } AS second
UNWIND first + second AS cn
RETURN 
    cn.lhs + &#39; to &#39; + cn.rhs + &#39;: &#39; + cn.num + 
    CASE 
      WHEN cn.num = 1 THEN &#39; connection&#39; 
      ELSE &#39; connections&#39; 
    END AS result
```
It&#39;s not pretty ...","","","","false","https://stackoverflow.com/a/77615121","","0","Answer","Count distinct node pairings in a multihop match","false","77615121","",,,,,
"1082",":Answer","","","This query might suffice (it repeats the same `A_to_type2` count in each result row):

    MATCH ({id: &quot;A&quot;})-[r1]-({type:2})-[r2]-(n2)
    WHERE n2.id IN [&quot;D&quot;, &quot;E&quot;]
    WITH COUNT(DISTINCT r1) AS A_to_type2, COLLECT({n2Id: n2.id, r2: r2}) AS data
    UNWIND data AS d
    RETURN A_to_type2, d.n2Id AS n2Id, COUNT(DISTINCT d.r2) AS type2_to_n2Id

Output for your sample data:

    ╒══════════╤════╤═════════════╕
    │A_to_type2│n2Id│type2_to_n2Id│
    ╞══════════╪════╪═════════════╡
    │2         │&quot;D&quot; │2            │
    ├──────────┼────┼─────────────┤
    │2         │&quot;E&quot; │1            │
    └──────────┴────┴─────────────┘

Or, to return a single row with a collection of the type2_to_n2Id counts:

    MATCH ({id: &quot;A&quot;})-[r1]-({type:2})-[r2]-(n2)
    WHERE n2.id IN [&quot;D&quot;, &quot;E&quot;]
    WITH COUNT(DISTINCT r1) AS A_to_type2, COLLECT({n2Id: n2.id, r2: r2}) AS data
    UNWIND data AS d
    WITH A_to_type2, d.n2Id AS n2Id, COUNT(DISTINCT d.r2) AS cnt
    RETURN A_to_type2, COLLECT({n2Id: n2Id, count: cnt}) AS type2_to_n2Id

Sample result:

    ╒══════════╤══════════════════════════════════════════════╕
    │A_to_type2│type2_to_n2Id                                 │
    ╞══════════╪══════════════════════════════════════════════╡
    │2         │[{count: 2, n2Id: &quot;D&quot;}, {count: 1, n2Id: &quot;E&quot;}]│
    └──────────┴──────────────────────────────────────────────┘","","","","false","https://stackoverflow.com/a/77616605","","0","Answer","Count distinct node pairings in a multihop match","false","77616605","",,,,,
"1083",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/shortest-path","shortest-path","","Tag","","false","","",,,,,
"1084",":Answer","","","If you want to only find paths where the relationships are in one direction e.g. outbound, you can either prepend `&lt;` to the relationship type for inbound, or append `&gt;` for outbound. 

To only follow outbound `ROAD_SEGMENT` relationships, your query would become:
```sql
MATCH (a:Address)-[:NEAREST_INTERSECTION]-&gt;(source:Intersection)
WHERE a.full_address CONTAINS &quot;410 E 5TH AVE SAN MATEO, CA&quot;
MATCH (poi:Address)-[:NEAREST_INTERSECTION]-&gt;(dest:Intersection) 
WHERE poi.full_address CONTAINS &quot;39 GRAND BLVD SAN MATEO, CA&quot;
CALL apoc.algo.aStarConfig(source, dest, &quot;ROAD_SEGMENT&gt;&quot;, 
  {pointPropName: &quot;location&quot;, weight: &quot;length&quot;}) 
YIELD weight, path
RETURN *
``` ","","","","false","https://stackoverflow.com/a/77609396","","0","Answer","Shortest path of weighted and directed graph in Neo4j","false","77609396","",,,,,
"1085",":Comment","","","","","","","","https://stackoverflow.com/questions/77608911/shortest-path-of-weighted-and-directed-graph-in-neo4j#comment136835752_77608911","","0","Comment","","false","136835752","",,,,,
"1086",":Answer","","","With the first query, you are probably getting an error telling you that `classId` is not defined. In which case, no nodes are being created.

If you are just looking to test the properties of the first created node, you can modify your existing query to declare a variable e.g. `n` in the node pattern. You can then access node properties with the dot notation in the `RETURN` clause:
```sql
LOAD CSV WITH HEADERS FROM &#39;file:///Badges.csv&#39; AS row
CREATE (n:Badges {
  classid: toInteger(row.Class),
  name: row.Name,
  badgeId: toInteger(row.Id)
})
RETURN n.classid, n.name, n.badgeId 
LIMIT 1;
```","","","","false","https://stackoverflow.com/a/77608932","","0","Answer","I can not import from csv files into Neo4j","false","77608932","",,,,,
"1087",":Comment","","","","","","","","https://stackoverflow.com/questions/77608338/i-can-not-import-from-csv-files-into-neo4j#comment136820331_77608338","","1","Comment","","false","136820331","",,,,,
"1088",":Answer","","","Based on your comments, I will assume your data model looks something like this (nodes can have more properties than shown):

    (:Complaints {complaint_id: 7})-[:Complaint_Details_complaint_id]-&gt;(:Complaint_Details {complaint_id: 7, detail_id: 123})--&gt;(:Foo {detail_id: 123})

Where `Foo` is just one of any number of labels for the child nodes of a `Complaint_Details` node.

In that case, when deleting a `Complaints` node you can also delete its `Complaint_Details` nodes and remove the `detail_id` properties of their children this way:

    MATCH (c:Complaints)-[:Complaint_Details_complaint_id]-&gt;(d:Complaint_Details)
    WHERE c.complaint_id = $complaint_id
    OPTIONAL MATCH (d)--&gt;(f)
    REMOVE f.details_id
    DETACH DELETE d, c

The query assumes that the desired `complaint_id` value is passed as a `$complaint_id` [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/).","","","","false","https://stackoverflow.com/a/77642610","","1","Answer","In Neo4j I want to obtain the path emerging from a particular node,I then want to iterate each node in the path and delete it based on stored action","false","77642610","",,,,,
"1089",":Comment","","","","","","","","https://stackoverflow.com/questions/77577493/in-neo4j-i-want-to-obtain-the-path-emerging-from-a-particular-node-i-then-want-t#comment136777083_77577493","","2","Comment","","false","136777083","",,,,,
"1090",":User","","","","","Marj","","","","","","User","","false","5831358","",,,,,
"1091",":Comment","","","","","","","","https://stackoverflow.com/questions/77577493/in-neo4j-i-want-to-obtain-the-path-emerging-from-a-particular-node-i-then-want-t#comment136835176_77577493","","1","Comment","","false","136835176","",,,,,
"1092",":Comment","","","","","","","","https://stackoverflow.com/questions/77577493/in-neo4j-i-want-to-obtain-the-path-emerging-from-a-particular-node-i-then-want-t#comment136848854_77577493","","0","Comment","","false","136848854","",,,,,
"1093",":Comment","","","","","","","","https://stackoverflow.com/questions/77577493/in-neo4j-i-want-to-obtain-the-path-emerging-from-a-particular-node-i-then-want-t#comment136849162_77577493","","0","Comment","","false","136849162","",,,,,
"1094",":Answer","","","```sql
MATCH (n:Commercial) 
WITH count(n) AS grosssales 
MATCH (c:Commercial) 
WITH grosssales,count(c) AS distinctcustomer, c.customer_id AS customer, tofloat(grosssales/count(c)) AS salesreach 
RETURN imp AS grosssales, distinctcustomer, customer, salesreach
```
","","","","false","https://stackoverflow.com/a/77576432","","0","Answer","Cypher Nested Query","false","77576432","",,,,,
"1095",":Answer","","","You can simplify the query by using the new [COUNT subquery](https://neo4j.com/docs/cypher-manual/current/subqueries/count/) (in neo4j 5.0+) to count the total number of `Commercial` nodes. Although `COUNT()` is an aggregating function, a COUNT subquery is not -- so it is not affected by the `customer` grouping key.

    MATCH (c:Commercial) 
    WITH COUNT{ (:Commercial) } AS grosssales, COUNT(c) AS distinctcustomer, c.customer_id AS customer
    RETURN grosssales, distinctcustomer, customer, TOFLOAT(grosssales/distinctcustomer) AS salesreach

","","","","false","https://stackoverflow.com/a/77617346","","0","Answer","Cypher Nested Query","false","77617346","",,,,,
"1096",":Comment","","","","","","","","https://stackoverflow.com/questions/77576343/cypher-nested-query#comment136817513_77576343","","0","Comment","","false","136817513","",,,,,
"1097",":Answer","","","If you are asking about how to use embedded neo4j in Spring Data Neo4j application, - indeed it is possible, even though officially is [not supported](https://gist.github.com/michael-simons/d3137f64ac0b13713fae8e7e1a69367e?permalink_comment_id=4756611#gistcomment-4756611) (I wonder where it is officially proclaimed). 

This is how it can be done:
1. Add neo4j to dependencies:
```xml
&lt;dependency&gt;
		&lt;groupId&gt;org.neo4j&lt;/groupId&gt;
		&lt;artifactId&gt;neo4j&lt;/artifactId&gt;
		&lt;version&gt;5.13.0&lt;/version&gt;
&lt;/dependency&gt;
```
2. Add these beans to your Spring Boot configuration class:
```java
@Bean
	public Configuration cypherDslConfiguration() {
		return Configuration.newConfig().withDialect(Dialect.NEO4J_5).build();
	}

//https://neo4j.com/docs/java-reference/current/java-embedded/setup/
@Bean
public DatabaseManagementService databaseManagementService() {
	DatabaseManagementService managementService = new 
		DatabaseManagementServiceBuilder(new File(&quot;target/mydb&quot;).toPath())
			.setConfig(GraphDatabaseSettings.transaction_timeout, Duration.ofSeconds( 60 ) )
			.setConfig( BoltConnector.enabled, true )
			.setConfig(BoltConnector.encryption_level, BoltConnector.EncryptionLevel.DISABLED)
			.build();
	
	registerShutdownHook(managementService);
	return managementService;
}

@Bean
public GraphDatabaseService graphDatabaseService(DatabaseManagementService managementService) {
	GraphDatabaseService graphDb =
		managementService.database(GraphDatabaseSettings.DEFAULT_DATABASE_NAME);
	log.info(&quot;Neo4j database Embedded instance is available: {}&quot;, graphDb.isAvailable());
	return graphDb;
}
private static void registerShutdownHook(final DatabaseManagementService managementService) {
	Runtime.getRuntime().addShutdownHook(new Thread() {
		@Override
		public void run() {
			managementService.shutdown();
		}
	});
}
```
3. Annotate your Spring Boot `@SpringBootApplication` with `@EnableNeo4jRepositories`.
4. SDN repositories now will work. 

Fully working example can be found [in this Gist](https://gist.github.com/Podbrushkin/54518ad6c4835706fd3344f01ea6acc9),  place those files in correct subdirectories and execute `mvn clean spring-boot:run`, you will see repositories are working. Application will break only if you will enable HttpConnector.

I hope this is what you&#39;ve asked for.

duplicate: https://stackoverflow.com/questions/76901420/how-to-connect-spring-data-neo4j-to-embedded-neo4j-server","","","","true","https://stackoverflow.com/a/77574246","","1","Answer","Spring Boot neo4j","false","77574246","",,,,,
"1098",":Answer","","","To follow all paths composed of relationships with either type `Sync` and direction outbound, or type `Async` and direction inbound, the following [quantified path pattern][1] will work:
```sql
MATCH (s {type: &#39;service&#39;}) 
        ((n)-[r]-() WHERE (n = startNode(r) AND r:Sync) 
          OR (n = endNode(r) AND r:Async))+ (dependent)
RETURN s, collect(DISTINCT dependent) AS allDependentNodes
```


  [1]: https://neo4j.com/docs/cypher-manual/current/patterns/concepts/#quantified-path-patterns","","","","true","https://stackoverflow.com/a/77565897","","1","Answer","How to match nodes in Cypher query based on different directions per relationship type","false","77565897","",,,,,
"1099",":Comment","","","","","","","","https://stackoverflow.com/questions/77565696/how-to-match-nodes-in-cypher-query-based-on-different-directions-per-relationshi#comment136743815_77565696","","0","Comment","","false","136743815","",,,,,
"1100",":Comment","","","","","","","","https://stackoverflow.com/questions/77565696/how-to-match-nodes-in-cypher-query-based-on-different-directions-per-relationshi#comment136743829_77565696","","0","Comment","","false","136743829","",,,,,
"1101",":Comment","","","","","","","","https://stackoverflow.com/questions/77565696/how-to-match-nodes-in-cypher-query-based-on-different-directions-per-relationshi#comment136744039_77565696","","0","Comment","","false","136744039","",,,,,
"1102",":Answer","","","Assuming you want to continuously follow a pattern of sent emails, you could use quantified path patterns to do so:

```
MATCH (p1:Person where p1.name=&#39;Jeff&#39;) (()-[:EMAIL_FROM]-&gt;(:Email)-[:EMAIL_TO]-&gt;(:Person))+ (p2)
RETURN DISTINCT p2
```

This will repeat the last part of the pattern with a lower bound of 1 and no upper bound. For any non-trivial graph this may not finish, and you may have heap issues. We would recommend setting an upper bound if possible.

Another approach would be to use APOC Procedures, the path explorer procedures, as those might be more efficient in finding distinct reachable nodes.

```
MATCH (p1:Person where p1.name=&#39;Jeff&#39;) 
CALL apoc.path.subgraphNodes(p1, {relationshipFilter:&#39;EMAIL_FROM&gt;, EMAIL_TO&gt;&#39;, labelFilter:&#39;&gt;Person&#39;}) YIELD node
RETURN node
```

This will repeat outgoing :EMAIL_FROM and :EMAIL_TO relationships, returning only :Person nodes, and the uniqueness used by this procedure should only return distinct end nodes.","","","","true","https://stackoverflow.com/a/77560648","","2","Answer","Neo4j: Variable-length-relationship with intermediary node","false","77560648","",,,,,
"1103",":Comment","","","","","","","","https://stackoverflow.com/questions/77560500/neo4j-variable-length-relationship-with-intermediary-node#comment136734663_77560500","","1","Comment","","false","136734663","",,,,,
"1104",":Answer","","","Looking at the output from print(dir(connector)) , the message is correct - there is no attribute named &#39;run&#39;

&gt; [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;,
&gt; &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getstate__&#39;,
&gt; &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;,
&gt; &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;,
&gt; &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;,
&gt; &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;_driver&#39;, &#39;close&#39;, &#39;driver&#39;]


I&#39;d look at connector.driver.execute_query as that will likely achieve what you are looking to do. 

","","","","false","https://stackoverflow.com/a/77555954","","0","Answer","How to fix &quot;Type &#39;Neo4jConnector&#39; doesn&#39;t have expected attribute &#39;run&#39; &quot; in python file","false","77555954","",,,,,
"1105",":User","","","","","Jonathan Giffard","","","","","","User","","false","22214354","",,,,,
"1106",":Answer","","","Some of your functions e.g. `edit_inbound_rule` call a method  `run` that the class `Neo4jConnector` does not have. One fix is to work with the GraphDatabase.driver, as is done in `create_inbound_rule`. 

For example, rewrite `edit_inbound_rule` like so:
```python
def edit_inbound_rule(connector, new_profile_id, new_message, new_processingflag1):
    s_id = dict[&quot;s_id&quot;]
    return_name = &#39;Rule Edit Successfully&#39;
    query = (
        &quot;MATCH (r:Rule) WHERE r.id_name = $s_id &quot;
        &quot;SET r.profileid = $new_profile_id, &quot;
        &quot;    r.message = $new_message, &quot;
        &quot;    r.processingflag1 = $new_processingflag1 &quot;
    )

    with connector._driver.session() as session:
        session.write_transaction(lambda tx: tx.run(query, new_profile_id=new_profile_id,
                  new_message=new_message, new_processingflag1=new_processingflag1, s_id=s_id))

    return return_name
```","","","","true","https://stackoverflow.com/a/77556024","","0","Answer","How to fix &quot;Type &#39;Neo4jConnector&#39; doesn&#39;t have expected attribute &#39;run&#39; &quot; in python file","false","77556024","",,,,,
"1107",":Comment","","","","","","","","https://stackoverflow.com/questions/77555016/how-to-fix-type-neo4jconnector-doesnt-have-expected-attribute-run-in-pyt#comment136724575_77555016","","0","Comment","","false","136724575","",,,,,
"1108",":User","","","","","ti7","","","","","","User","","false","4541045","",,,,,
"1109",":Answer","","","If you want the count of nodes to which the `SET` was applied, return the count of rows:

```sql
MATCH (n:Student) WHERE n.id IN $idList 
SET n.isRegistered = true
RETURN count(*) AS numAffected
```

If you want the count of nodes whose value of `isRegistered` was changed, remove nodes that already have `isRegistered = true` with the `WHERE` clause:

```sql
MATCH (n:Student) 
WHERE n.id IN $idList AND NOT coalesce(n.isRegistered, false) 
SET n.isRegistered = true
RETURN count(*) AS numAffected
```

(I&#39;ve just formatted as stand-alone Cypher to make it easier read.)","","","","false","https://stackoverflow.com/a/77551513","","0","Answer","Spring Data Neo4j return count of affected nodes after update operation","false","77551513","",,,,,
"1110",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/cpu","cpu","","Tag","","false","","",,,,,
"1111",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/apoc","apoc","","Tag","","false","","",,,,,
"1112",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/vector","vector","","Tag","","false","","",,,,,
"1113",":Answer","","","I was able to solve this in 2 steps

## Step 1: Fix the header file
```
id:ID,:LABEL,amount:double,measureUnit:string,gramWeight:double,embedding:float[]
```
Note the `float[]` as the type

## Step 2: Importing array
This involved 2 steps
### Step 2.1: Create a valid delimiter for array

```
const embedding = await createEmbedding(embeddingInput);
const embeddingString = embedding.join(ARRAY_DELIMITER);
```
Where `ARRAY_DELIMITER` is `|`

### Step 2.2 Update import command to tell about delimiter
```
neo4j-admin database import full --array-delimiter=&#39;|&#39; // and so on...
```
Note `--array-delimiter=&#39;|&#39;` here.

This helped me fix the issue.","","","","false","https://stackoverflow.com/a/77526008","","0","Answer","Importing Vector Embedding in Neo4J via neo4j-admin import is failing with unknown property type &#39;LIST&lt;FLOAT&gt;&#39;","false","77526008","",,,,,
"1114",":Answer","","","You could try a query like this:

```
MATCH (n:Resource)
WHERE EXISTS {
    MATCH (n)-[*0..1]-&gt;(x)
    WHERE (x:Resource OR x:Tag)
    AND any(prop IN [&#39;name&#39;, &#39;description&#39;, &#39;legal_name&#39;, &#39;organization_type&#39;, &#39;tag&#39;] WHERE x[prop] CONTAINS &#39;school&#39;)
}

WITH n, [(n)-[]-&gt;(m) | m] as resources
RETURN n, resources;
```

This uses an EXISTS {} subquery to say that you&#39;re looking for a node (that could be the same node, or could be a connected node) that is a :Resource or :Tag node that has any of the given properties with the property value contains &#39;school&#39;.

For the resulting nodes that pass that filter, THEN you can match out to and collect the connected nodes (though in this case I&#39;m using a pattern comprehension to do so, which will be more efficient).

EDIT: Fixed up the grouping of the AND and OR operators, that should ensure the any() list predicate must always be considered.","","","","true","https://stackoverflow.com/a/77525820","","0","Answer","[Neo4j][Cypher Query] Filter On Node or Relationship Node Properties and Then Return All Nodes and Their Relationship Nodes","false","77525820","",,,,,
"1115",":Answer","","","The `Tags` look a lot like labels. Their one property, `tag`,  could just as easily be the label identifier. With the tags as labels, the predicates can be simplified like so:
```sql
WITH [&#39;name&#39;, &#39;description&#39;, &#39;legal&#39;, &#39;organization_type&#39;] AS props
MATCH (n:Resource)--&gt;(m) 
WHERE n:School OR any(prop IN props WHERE m[prop] CONTAINS &#39;school&#39;)
RETURN n, collect(m);
```","","","","false","https://stackoverflow.com/a/77539656","","0","Answer","[Neo4j][Cypher Query] Filter On Node or Relationship Node Properties and Then Return All Nodes and Their Relationship Nodes","false","77539656","",,,,,
"1116",":Comment","","","","","","","","https://stackoverflow.com/questions/77524947/neo4jcypher-query-filter-on-node-or-relationship-node-properties-and-then-re#comment136673875_77524947","","0","Comment","","false","136673875","",,,,,
"1117",":Comment","","","","","","","","https://stackoverflow.com/questions/77524947/neo4jcypher-query-filter-on-node-or-relationship-node-properties-and-then-re#comment136675002_77524947","","0","Comment","","false","136675002","",,,,,
"1118",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/database-connection","database-connection","","Tag","","false","","",,,,,
"1119",":Answer","","","One thing I see is that you have a long pattern, and within that pattern you have a condition that uses a property of a node in that pattern.

That is, you match on t1 and require `{movOre: t1.nutel}`, and the same thing again when you use a REBIX relationship property to filter on `t2: Tel`

This means every t1 has to be found, and every value of `t1.nuTel` used in the pattern. If you have 1000 Tel nodes, you have 1000 nuTel properties. Basically, the possibilities for nuTel and movBene are exploding.

You might refactor to split this into multiple MATCH statements:

```
MATCH (t1:Tel {TB:true})
WITH distinct t1.nuTel as t1nuTel
MATCH (t1:Tel {TB:true, nulTel:t1nuTel})&lt;-[:TelBIZ]-(:ACC {TB:true})-[or:REBIZ {movOre: t1nuTel}]-&gt;(:ACC {TB:true})-&gt;(t2:Tel {TB:true, nuTel: or.movBene})
WHERE t1.nuTel &lt;&gt; t2.nuTel
RETURN t1, t2, count(or) as Ope, sum(or.imp) as Total, 10^3 as Precision, max(or.Txt) as mRB
```

That may not be the best solution for your graph, and there&#39;s still the issue with `or.movBene` being used as a filter when it&#39;s part of a pattern, but hopefully I&#39;ve communicated the idea and you can refine from there.

Also, indexes on nuTel, movBene, and TB will be incredibly faster, if you don&#39;t haver them already.","","","","false","https://stackoverflow.com/a/77607672","","0","Answer","Optimization of a MATCH statement","false","77607672","",,,,,
"1120",":Comment","","","","","","","","https://stackoverflow.com/questions/77522450/optimization-of-a-match-statement#comment136668341_77522450","","0","Comment","","false","136668341","",,,,,
"1121",":Comment","","","","","","","","https://stackoverflow.com/questions/77522450/optimization-of-a-match-statement#comment136668426_77522450","","0","Comment","","false","136668426","",,,,,
"1122",":Comment","","","","","","","","https://stackoverflow.com/questions/77522450/optimization-of-a-match-statement#comment136668432_77522450","","0","Comment","","false","136668432","",,,,,
"1123",":Comment","","","","","","","","https://stackoverflow.com/questions/77522450/optimization-of-a-match-statement#comment136670159_77522450","","0","Comment","","false","136670159","",,,,,
"1124",":Comment","","","","","","","","https://stackoverflow.com/questions/77522450/optimization-of-a-match-statement#comment136670739_77522450","","0","Comment","","false","136670739","",,,,,
"1125",":Comment","","","","","","","","https://stackoverflow.com/questions/77522450/optimization-of-a-match-statement#comment136672265_77522450","","0","Comment","","false","136672265","",,,,,
"1126",":Answer","","","I&#39;m not sure if I&#39;m doing it right, but I&#39;ve encountered this problem myself and haven&#39;t found a better solution than simply creating a new object of the class I need and populating it with values that I extract from the `InternalNode`.

For example:

    InternalNode internalNode = (InternalNode) weightedCriteriaArrayElement.get(&quot;criterion&quot;);
    
    Criterion criterion = new Criterion(); // my entity class
    Map&lt;String, Object&gt; nodeProperties = new HashMap&lt;&gt;(internalNode.asMap());
    BeanUtils.populate(criterion, nodeProperties);
    criterion.setGraphId(internalNode.id());","","","","false","https://stackoverflow.com/a/77549953","","0","Answer","Spring data Neo4j can&#39;t convert InternalNode back to entity class when retrieving paths","false","77549953","",,,,,
"1127",":Answer","","","You could try this ...

    MATCH (n:YourNodeLabel)
    RETURN apoc.convert.toHex(n.yourByteArrayProperty) AS hexValue

I&#39;ve created a  [hex-ORDPATH][1] in a Neo4j user defined function (UDF). That code might help if you want to write a custom UDF. 


  [1]: https://github.com/waigitdas/Neo4j-Genealogy-PlugIns/blob/main/java%20classes/graph/ordpath.java","","","","false","https://stackoverflow.com/a/77524665","","0","Answer","Display byte array as hex string in Neo4j Browser","false","77524665","",,,,,
"1128",":Answer","",""," Due the the Parallel nature of `Neo4j` these situations stem  as reasons for what you experienced. 

 - Results may not be deterministic, as different threads may finish at different times - use the `ORDER BY` clause 
 - `PARALLEL runtime` does not support updating queries, such as those using the `CREATE, MERGE, SET, DELETE, or REMOVE` - updating the graph in parallel may cause conflicts or inconsistencies to use  the same to  read  ,use `:begin` and `:commit` commands in `Cypher Shell` to control the transactions or another runtime, such as `SLOTTED or PIPELINED`, for the write queries.
 - Also it does not support reading data that has been modified in the same transaction, as this may cause `concurrency` issues or `stale reads` aka you cannot use the `apoc.cypher.mapParallel2` procedure to read data that you have updated in the same transaction  - use another procedure, such as `apoc.cypher.doIt`, or split  transaction into two parts. 

For situational restrictions  so mentioned , I doubt if they have plans to update. ","","","","true","https://stackoverflow.com/a/77576603","","0","Answer","Neo4j PARALLEL runtime query returns different result","false","77576603","",,,,,
"1129",":User","","","","","user1874594","","","","","","User","","false","1874594","",,,,,
"1130",":Answer","","","You&#39;re looking for the `ANY` predicate

```
MATCH p =(mFirst:MoveNode)-[:NEXT_MOVE*${patternLength - 1}]-&gt;(:MoveNode)
WHERE ANY(
  x IN $patterns 
  WHERE ( mFirst.move = head(x) AND [m IN nodes(p) | m.move] = x )
)
```","","","","true","https://stackoverflow.com/a/77508731","","2","Answer","Practical Way of Doing Equality Against Multiple Possible Values in Cypher","false","77508731","",,,,,
"1131",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4j-embedded","neo4j-embedded","","Tag","","false","","",,,,,
"1132",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/parallel-processing","parallel-processing","","Tag","","false","","",,,,,
"1133",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/gpu","gpu","","Tag","","false","","",,,,,
"1134",":Answer","","","The Parallel Runtime is a very powerful mechanism for certain queries to parallelise the processing of a single query (though parallel processing isn&#39;t new when you have multiple parallel queries).

However, GPU&#39;s are not supported by the parallel runtime and it is not really foreseen either.","","","","true","https://stackoverflow.com/a/77502358","","0","Answer","Neo4j parallel runtime and GPU","false","77502358","",,,,,
"1135",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/recursion","recursion","","Tag","","false","","",,,,,
"1136",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/tree","tree","","Tag","","false","","",,,,,
"1137",":Answer","","","To get the path `p` from the root `GameNode` up to and including the sequence of moves `[&#39;rm&#39;,&#39;ro&#39;]`, you can write the following in Neo4j 5.9+:
```sql
MATCH p = (g:GameNode)-[:NEXT_MOVE]-&gt;+(m1:MoveNode)-[:NEXT_MOVE]-&gt;(m2:MoveNode)
WHERE m1.move = &#39;rm&#39; AND m2.move = &#39;ro&#39;
RETURN p
```
To get the whole path, up to the last move in the sequence, you need to add a check that there are no further moves:
```sql
MATCH p = (g:GameNode)-[:NEXT_MOVE]-&gt;+(m1:MoveNode)-[:NEXT_MOVE]-&gt;
  (m2:MoveNode)-[:NEXT_MOVE]-&gt;*(lastMove:MoveNode)
WHERE m1.move = &#39;rm&#39; AND m2.move = &#39;ro&#39;
  AND NOT EXISTS { (lastMove)-[:NEXT_MOVE]-&gt;(:MoveNode) }
RETURN p
```
It would be surprising if there were performance issues: specific enough patterns over small graphs representing each game should not be slow. ","","","","false","https://stackoverflow.com/a/77497956","","1","Answer","How to (Efficiently) Find Subpaths in Recursive Trees through Cypher (Graph vs Regex)","false","77497956","",,,,,
"1138",":Answer","","","The query below should be fairly performant in returning the moves in every game that contains the desired sequence of moves. It assumes you:
- Have an [index](https://neo4j.com/docs/cypher-manual/current/indexes-for-search-performance/) on `MoveNode.move`,
- Pass the list of desired moves in the `$moves` [parameter](),
- Adjust the length of the variable-length relationship in the first `MATCH` to be 1 less than the length of `$moves`. For example, if `$moves` has 2 items, use `*1` instead of `*2`. *This is admittedly ugly, but Cypher does not support dynamic bounds.*

#### Query

    MATCH p1=(m1:MoveNode)-[:NEXT_MOVE*2]-&gt;(m2)
    WHERE m1.move = HEAD($moves) AND [m IN TAIL(NODES(p1)) | m.move] = TAIL($moves)
    MATCH p2 = (m2)-[:NEXT_MOVE*0..]-&gt;(end) WHERE NOT (end)-[:NEXT_MOVE]-&gt;()
    MATCH p3 = (g:GameNode)-[:NEXT_MOVE*]-&gt;(m1)
    RETURN [a IN NODES(p3)[1..-1] | a.move] + $moves + [b IN NODES(p2)[1..] | b.move]

The index is used to limit and anchor the search by quickly finding the `m1` nodes (the `MoveNode`s matching the first item in `$moves`), instead of wading through all paths from every `GameNode`. Then the query:
- Filters `m1` by requiring that it is followed by a subpath satisfying the rest of the `$moves` list,
- Finds the sequence of moves that follow each subpath,
- Works backwards from the surviving `m1` nodes to find the corresponding `GameNode`s.
- Constructs and returns the sequence of moves for each matching game.

So, this query starts off by using the index to find the first set of relevant nodes, and keeps adding relationships (and end nodes) to what was already found until it finally has the desired results. There is never a need to scan through irrelevant data.","","","","true","https://stackoverflow.com/a/77499034","","1","Answer","How to (Efficiently) Find Subpaths in Recursive Trees through Cypher (Graph vs Regex)","false","77499034","",,,,,
"1139",":Answer","","","If each query execution is for a single chain of moves that are in order of play, and the parent `GameNode` already exists, then you can use the following:
```sql
UNWIND $moveNodes AS move
CALL {
    WITH move
    MATCH (parent:GameNode|MoveNode {game_id: $gameId, id: move.parentId})
    CREATE (parent)-[:NEXT_MOVE]-&gt;(m:MoveNode {game_id: $gameId, id: move.id})
}
```","","","","true","https://stackoverflow.com/a/77495682","","1","Answer","How to Recursively Create a Tree with Cypher (Neo4j)","false","77495682","",,,,,
"1140",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/apache-spark","apache-spark","","Tag","","false","","",,,,,
"1141",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/pyspark","pyspark","","Tag","","false","","",,,,,
"1142",":Answer","","","It is certainly possible.
Are you aware of the [Neo4j Spark connector][1]?

    df.write \
      .format(&quot;org.neo4j.spark.DataSource&quot;) \
      .mode(&quot;ErrorIfExists&quot;) \
      .option(&quot;url&quot;, &quot;bolt://localhost:7687&quot;) \
      .option(&quot;labels&quot;, &quot;:Person&quot;) \
      .save()

Above is an example on the command on how you can save from Spark to Neo4j. In this case it saves &quot;:Person&quot; nodes.


Of course you will need to create your dataframe in such a format that it makes sense as graph data. 

Probably something like Source,Destination,Weight or something like that. 
Or as nodes like the code above.

Without knowing the schema of your data I cant help any more I am afraid.


  [1]: https://neo4j.com/docs/spark/current/python/","","","","false","https://stackoverflow.com/a/77493083","","1","Answer","Connect APIs, Parse the result using pyspark and store it in neo4j","false","77493083","",,,,,
"1143",":User","","","","","mamonu","","","","","","User","","false","2081152","",,,,,
"1144",":Answer","","","With respect to the `KeyError: &#39;input_variables&#39;` error: as [documented](https://python.langchain.com/docs/modules/model_io/prompts/prompt_templates/), the `PromptTemplate` parameter for input variables is named `input_variables`. So you need to change your `variables` parameter name to `input_variables`.

*And, yes, the error message should be much better worded.*","","","","false","https://stackoverflow.com/a/77492979","","1","Answer","Query GPT4All local model with Langchain and many .txt files - KeyError: &#39;input_variables&#39;","false","77492979","",,,,,
"1145",":Comment","","","","","","","","https://stackoverflow.com/questions/77492026/query-gpt4all-local-model-with-langchain-and-many-txt-files-keyerror-input#comment136616228_77492026","","0","Comment","","false","136616228","",,,,,
"1146",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/spring-data","spring-data","","Tag","","false","","",,,,,
"1147",":Answer","","","You could modify your mapping code to
```
MapValue nodePair = (MapValue) record.get(&quot;nodePair&quot;);
var src = mappingFunction.apply(typeSystem, nodePair.get(&quot;src&quot;));
if (!nodePair.get(&quot;target&quot;).isNull()) {
	var target = mappingFunction.apply(typeSystem, nodePair.get(&quot;target&quot;));
	return new NodePair(src, target);
}
return new NodePair(src, null);
```
and check the `null` value that the driver returns in this case.

(Also answered this at https://github.com/spring-projects/spring-data-neo4j/issues/2821 but wanted to be sure that the answer can be discovered also here by others having the same problem)","","","","false","https://stackoverflow.com/a/77501827","","0","Answer","Spring data neo4j client throws exception when there&#39;s no match in database","false","77501827","",,,,,
"1148",":Answer","","","It is achievable with the following query ( added comments )

```cypher
// simulate your input
WITH &quot;a.b.c.d&quot; AS pkg 
// split on the dot, producing an array 
WITH split(pkg, &quot;.&quot;) AS parts [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]
// iterating of the array
UNWIND parts AS part 
// MERGE (match or create) the module with the name as id ( up to you which property to use )
MERGE (m:Module {id: part}) 
// break and introduce a variable being an array of the nodes created or matched
WITH collect(m) AS modules 
// use APOC to link those nodes together with the NEXT relationship
CALL apoc.nodes.link(modules,&#39;NEXT&#39;) 
```

It produces such graph

[![enter image description here][1]][1]

Later on, if you try to do the same with module paths that do already exist, it will do nothing, for eg after the above, the following query will not create anything

```
WITH &quot;a.b.c&quot; AS pkg
WITH split(pkg, &quot;.&quot;) AS parts
UNWIND parts AS part
MERGE (m:Module {id: part})
WITH collect(m) AS modules
CALL apoc.nodes.link(modules,&#39;NEXT&#39;)
```

[![enter image description here][2]][2]


  [1]: https://i.stack.imgur.com/gVSf0.png
  [2]: https://i.stack.imgur.com/G7VIG.png","","","","false","https://stackoverflow.com/a/77490681","","0","Answer","Create all nonexistent nodes and edges if path doesn&#39;t exist","false","77490681","",,,,,
"1149",":Answer","","","You can use a pure Cypher approach with the following:
```
FOREACH (i IN range(0, size($module_path) - 2) | 
           MERGE (l:Module {name: $module_path[i]})
           MERGE (r:Module {name: $module_path[i+1]})          
           MERGE (l)-[:contains]-&gt;(r) );
```
You can test how this works with the data in your question:
```
UNWIND [[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;],[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;e&#39;],[&#39;a&#39;],[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],
        [&#39;a&#39;,&#39;b&#39;]] AS modules
FOREACH (i IN range(0, size(modules) - 2) | 
            MERGE (l:Module {name: modules[i]})
            MERGE (r:Module {name: modules[i+1]})          
            MERGE (l)-[:contains]-&gt;(r) )
```
Here is the result:
[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/T7cEA.png","","","","false","https://stackoverflow.com/a/77491575","","1","Answer","Create all nonexistent nodes and edges if path doesn&#39;t exist","false","77491575","",,,,,
"1150",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/if-statement","if-statement","","Tag","","false","","",,,,,
"1151",":Answer","","","It looks like you are looking for `WHERE`:
```
MATCH (n:person)&lt;-[r:aetei]-(m:person)
WHERE m.ai &gt;= 2 
RETURN n, m, r
```","","","","true","https://stackoverflow.com/a/77482258","","0","Answer","testing value in NEO4j","false","77482258","",,,,,
"1152",":Comment","","","","","","","","https://stackoverflow.com/questions/77482002/testing-value-in-neo4j#comment136597240_77482002","","0","Comment","","false","136597240","",,,,,
"1153",":Comment","","","","","","","","https://stackoverflow.com/questions/77482002/testing-value-in-neo4j#comment136597284_77482002","","0","Comment","","false","136597284","",,,,,
"1154",":Answer","","","If you are inferring the possible properties from the `Person` nodes in the `MATCH`, then you can get the count of non-empty properties with the following:
```sql
MATCH (p:Person)
UNWIND keys(p) AS key
WITH key, CASE WHEN p[key] &lt;&gt; &quot;&quot; THEN 1 ELSE 0 END AS isNonEmpty
RETURN key, sum(isNonEmpty) AS cnt
ORDER BY key
```
Note that because Neo4j treats null properties as non-existent, then if none of the nodes returned by the `MATCH` statement has the property, those properties can&#39;t be inferred.

The `CASE` can easily be adapted to exclude other property values from the count. For example, to exclude empty lists, you can write:

```sql
MATCH (p:Person)
UNWIND keys(p) AS key
WITH key, 
     CASE p[key]
       WHEN [] THEN 0 
       WHEN &quot;&quot; THEN 0
       WHEN 0 THEN 0
       ELSE 1 
     END AS isNonEmpty
RETURN key, sum(isNonEmpty) AS cnt
ORDER BY key
```

If you know the properties in advance because, for example, you know the schema, then you could provide them as a list or set of records. For example, if the properties were `&#39;a&#39;` through to `&#39;g&#39;`, you could use the following:
```sql
UNWIND [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] AS key
MATCH (p)
WITH key, CASE WHEN p[key] &lt;&gt; &quot;&quot; THEN 1 ELSE 0 END AS isNonEmpty
RETURN key, sum(isNonEmpty) AS cnt
ORDER BY key
```","","","","true","https://stackoverflow.com/a/77473606","","1","Answer","Noe4j : how to get property names with count of non-null or non-empty value for a given node label","false","77473606","",,,,,
"1155",":Answer","","","[UPDATED]

[Aggregating functions](https://neo4j.com/docs/cypher-manual/current/functions/aggregating/) like `COUNT` already group by non-aggregating expressions like `key`, so `DISTINCT` is not needed. And comparisons to `NULL` are considered `false` by `WHERE`, so an explicit `NULL` test would be redundant.

Here is a query that uses:
- [ISEMPTY](https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-isempty) to detect all &quot;empty&quot; properties (with `&quot;&quot;`, `[]`, or `{}` values).
- [TOINTEGER](https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tointeger) to convert booleans to 1 (for `true`) or 0.

It will also return a `0` count for properties that are always empty.

    MATCH (p:Person)
    UNWIND KEYS(p) AS key
    RETURN key, SUM(TOINTEGER(NOT ISEMPTY(p[key]))) AS cnt 
    ORDER BY key

You should [PROFILE](https://neo4j.com/docs/cypher-manual/current/planning-and-tuning/query-tuning/#how-do-i-profile-a-query) the queries in the proposed answers to your question see which one uses the fewest DB hits.

Also, if it makes sense, you should consider removing all properties that have an empty string value if they should be considered as non-existent. That would allow you to use evern simpler and faster queries.","","","","false","https://stackoverflow.com/a/77475985","","0","Answer","Noe4j : how to get property names with count of non-null or non-empty value for a given node label","false","77475985","",,,,,
"1156",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/query-optimization","query-optimization","","Tag","","false","","",,,,,
"1157",":Answer","","","In `(childDStatCriterionAvgVoteWeight = 0 OR childDStatCriterionAvgVoteWeight &lt;= criterionAvgVoteWeight OR criterionAvgVoteWeight IS NULL)`:

- You should test `criterionAvgVoteWeight IS NULL` first. That way, if it is `NULL`, then you would not waste time testing with a `NULL` value in the `childDStatCriterionAvgVoteWeight &lt;= criterionAvgVoteWeight` expression (which would be considered `false`), and you would also not need to test `childDStatCriterionAvgVoteWeight = 0`. This could be a big win if the value is frequently `NULL`.
- If `criterionAvgVoteWeight` is always &gt;= 0 (when it is not `NULL`), then the `childDStatCriterionAvgVoteWeight = 0` test can be eliminated completely.

In short, you could consider using this expression instead: `(criterionAvgVoteWeight IS NULL OR childDStatCriterionAvgVoteWeight &lt;= criterionAvgVoteWeight)`.

Similar considerations apply to `(childDStatCriterionExperienceMonth = 0 OR childDStatCriterionExperienceMonth &lt;= criterionExperienceMonth OR criterionExperienceMonth IS NULL)`.

These changes may save some time, depending on your actual data characteristics, but filtering is not free.","","","","true","https://stackoverflow.com/a/77476221","","1","Answer","Neo4j Cypher query performnce optimization with WHERE condition","false","77476221","",,,,,
"1158",":Comment","","","","","","","","https://stackoverflow.com/questions/77471207/neo4j-cypher-query-performnce-optimization-with-where-condition#comment136584787_77471207","","0","Comment","","false","136584787","",,,,,
"1159",":Comment","","","","","","","","https://stackoverflow.com/questions/77471207/neo4j-cypher-query-performnce-optimization-with-where-condition#comment136585549_77471207","","0","Comment","","false","136585549","",,,,,
"1160",":Comment","","","","","","","","https://stackoverflow.com/questions/77471207/neo4j-cypher-query-performnce-optimization-with-where-condition#comment136586553_77471207","","0","Comment","","false","136586553","",,,,,
"1161",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/jupyter-notebook","jupyter-notebook","","Tag","","false","","",,,,,
"1162",":Comment","","","","","","","","https://stackoverflow.com/questions/77467579/why-is-the-graph-data-science-library-plug-in-preventing-me-from-starting-a-data#comment136575752_77467579","","0","Comment","","false","136575752","",,,,,
"1163",":Answer","","","There are several issues with both of your queries.

For example, `REL_VIRTUAL2` is just a temporary variable name, not a relationship type. `COAUTHORS_WITH_VIRTUAL2` is the relationship type you should have used in the projection. However, changing that would still not fix things because **GDS does not support projecting virtual nodes or relationships**.

Your first approach should work, but you may need to solve some other issues first. For example, the projection should use `[&#39;node1&#39;, &#39;node2&#39;]` instead of just `&#39;node1&#39;` for the node labels,. And you can replace `ON CREATE SET x = y ON MATCH SET x = y` with just `SET x = y`.","","","","true","https://stackoverflow.com/a/77448519","","1","Answer","Neo4j: use in a projection a virtual relationship with weights","false","77448519","",,,,,
"1164",":Answer","","","I suspect the problem lies in evaluating node equality.

Instead of `WHERE p = $person` try `WHERE id(p) = id($person)`

UPDATE: Based on this post, I could be mistaken:
https://stackoverflow.com/questions/59844124/should-nodes-be-compared-directly-or-they-must-be-going-through-id-first","","","","false","https://stackoverflow.com/a/77483393","","0","Answer","Passing domain object as argument to custom Cypher query in Spring Data Neo4j","false","77483393","",,,,,
"1165",":Answer","","","There are 2 ways of passing fields.

**Note:** I used Spring Boot 3.2, SDN v7.2.2 and Neo4j v5. 

1) Use a Map without saving the Node:

**Model:**    

    @Setter
    @Getter
    @Node
    public class Car {
    
        @Id
        @GeneratedValue
        private Long id;
    
        @Property(name = &quot;model&quot;)
        private String model;

        public Car(){} // have an empty constructor to save
    }
**Repository class:**

    public interface CarRepository extends Neo4jRepository&lt;Car, Long&gt; {
        
        @Query(&quot;WITH $car AS c &quot; +
                &quot;RETURN c[&#39;model&#39;] AS model&quot;)
        String getCarModel(@Param(&quot;car&quot;) Map&lt;String, Object&gt; carMap); 
    }

**Testing:**

     private void testCar() {
            Car car = new Car();
            car.setModel(&quot;Tesla Model S&quot;);
    
            Map&lt;String, Object&gt; carMap = new HashMap&lt;&gt;();
            carMap.put(&quot;model&quot;, car.getModel());
            String model = carRepository.getCarModel(carMap);
            System.out.println(&quot;\nModel: &quot; + model);
    
        }



2) Save the Node and use Id to access the parameters


**Repository:**
The important part is to use `__id__` here. &quot;*.id*&quot; did not work in tests.

     public interface CarRepository extends Neo4jRepository&lt;Car, Long&gt; {
            @Query(&quot;MATCH (c:car) WHERE id(c) = $car.__id__ &quot; +
                    &quot;RETURN c.model as model&quot;)
            String getCarModel(@Param(&quot;car&quot;) Car car);
        }


**Testing:**

        private void testCar() {
            Car car = new Car();
            car.setModel(&quot;Tesla Model S&quot;);
        
            carRepository.save(car); //this will save it with an ID
            System.out.println(&quot;\nModel: &quot; + 
            carRepository.getCarModel(car));
            carRepository.delete(car);//if you want
        }


","","","","false","https://stackoverflow.com/a/77831344","","0","Answer","Passing domain object as argument to custom Cypher query in Spring Data Neo4j","false","77831344","",,,,,
"1166",":User","","","","","Cugomastik","","","","","","User","","false","3332879","",,,,,
"1167",":Answer","","","## Solution
```java
public interface ImageRepositoryNeo4j extends Neo4jRepository&lt;Image, String&gt; {
@Query(&quot;&quot;&quot;
    MATCH (i:Image) -[:DEPICTS] -&gt; (p:Person)
    WHERE id(p) = toInteger(split($person.__id__, &#39;:&#39;)[-1])
    RETURN count(i)
    &quot;&quot;&quot;)
public Integer countImagesDepictingPerson(@Param(&quot;person&quot;) Person person);
```
Ugly, but it works. Note: Person.id is of type String. Maybe you wouldn&#39;t need all this hassle if your Person.id is of type Integer or Long.

## Explanation
When we have 
```java
@Node(&quot;Person&quot;)
public class Person {
    
    @Id
    @GeneratedValue
    private String id;
```
This is what exactly neo4j generates as an id:
```java
var freshPerson = personRepository.findOneByBirthday(LocalDate.of(1993,3,3));
log.info(&quot;freshPerson.getId()={}&quot;, freshPerson.getId());
// freshPerson.getId()=4:a8bd1c80-0f61-4a2b-b094-7e7aed736caf:2
```
As you can see, freshPerson.id is a long string.

But if you will call this cypher:
```java
@Query(&quot;&quot;&quot;
    MATCH (p:Person {name: &#39;Roy&#39;})
    RETURN id(p)
    &quot;&quot;&quot;)
public Integer getRoyIdInt();
```
You will get an Integer (and a warning message about `id()` function being deprecated).

And if you will call this cypher:
```java
@Query(&quot;&quot;&quot;
    MATCH (p:Person {name: &#39;Roy&#39;})
    RETURN p.id
    &quot;&quot;&quot;)
public String getRoyId();
```
You will get null instead of String and this warning:
```
WARN 7164 --- [           main] o.s.data.neo4j.cypher.unrecognized       : Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
        MATCH (p:Person {name: &#39;Roy&#39;})
        RETURN p.id
                 ^
    One of the property names in your query is not available in the database, make sure you didn&#39;t misspell it or that the label is available when you run this statement in your application (the missing property name is: id)
```
This is unexpected, because obviously we have `id` property in our Person class, even though it is annotated with `@Id @GeneratedValue`.

Integer in the end of `4:a8bd1c80-0f61-4a2b-b094-7e7aed736caf:2` is actually what `id()` function returns, so we can extract it and find a node by it. This is exactly what is happening in Solution section.

Also we can extract it in java, check out last section. I&#39;ve made it verbose so it will be clear what is going on.

## Solution 2
Declare neo4j repo method which takes Integer as an arg:
```java
@Query(&quot;&quot;&quot;
    MATCH (i:Image) -[:DEPICTS] -&gt; (p:Person)
    WHERE id(p) = $id
    RETURN count(i)
    &quot;&quot;&quot;)
public Integer countImagesDepictingPersonWithId(@Param(&quot;id&quot;) Integer id);
```

Use this method:
```java
// Create Greg with birthday:
Person greg = new Person(&quot;Greg&quot;, LocalDate.of(1993,3,3));
greg = personRepository.save(greg);

// Create image depicting Greg:
var img2 = new Image(&quot;/blabla2.jpg&quot;);
img2.getPeople().add(greg);

// Find someone by birthday (we know it&#39;s Greg):
var freshPerson = personRepository.findOneByBirthday(LocalDate.of(1993,3,3));

// Extract Integer id from String id:
String[] tokens = freshPerson.getId().split(&quot;:&quot;);
String lastToken = tokens[tokens.length - 1];
Integer gregId = Integer.parseInt(lastToken);

// Count images depicting Greg:
var count = imageRepository.countImagesDepictingPersonWithId(gregId);
log.info(&quot;Greg1993 is depicted in {} images.&quot;, count); //1
```

We just moved String splitting logic from Cypher to Java.","","","","false","https://stackoverflow.com/a/77840765","","0","Answer","Passing domain object as argument to custom Cypher query in Spring Data Neo4j","false","77840765","",,,,,
"1168",":Comment","","","","","","","","https://stackoverflow.com/questions/77446718/passing-domain-object-as-argument-to-custom-cypher-query-in-spring-data-neo4j#comment136584823_77446718","","0","Comment","","false","136584823","",,,,,
"1169",":Comment","","","","","","","","https://stackoverflow.com/questions/77446718/passing-domain-object-as-argument-to-custom-cypher-query-in-spring-data-neo4j#comment136594097_77446718","","0","Comment","","false","136594097","",,,,,
"1170",":Answer","","","I found an answer [here][1]

I&#39;ve updated it to look like this

```
MATCH (doc:Captions)
MATCH (p:Pillars {name: &#39;Feel Good&#39;})
MATCH (doc)-[:HAS_PILLAR]-(p)
MATCH (c:Categories {id: &#39;ne0MtinOO6DXryRvqMxS&#39;})
MATCH (doc)-[:HAS_CATEGORY]-(c)
WITH count(*) as docCount, collect(doc) as parts
UNWIND parts as a
RETURN docCount,a 
limit 12
```

I have Updated based off @cyberSam&#39;s comment

```typescript
const hasPillar = pageOptionsDto.pillar
  ? `(p:Pillars {id: &#39;${pageOptionsDto.pillar}&#39;})&lt;-[:HAS_PILLAR]-`
  : &#39;&#39;;
const hasCat = pageOptionsDto.category
  ? `-[:HAS_CATEGORY]-&gt;(c:Categories {id:&#39;${pageOptionsDto.category}&#39;})`
  : &#39;&#39;;
const hasOrderBy = pageOptionsDto.orderBy
  ? `ORDER BY doc.${pageOptionsDto.order}, r.date`
  : &#39;ORDER BY r.date&#39;;
const res = await this.neo4jService.read(`
  MATCH ${hasPillar}(doc:${collection} {active: true})${hasCat}
  WITH count(*) as docCount, collect(doc) as docs
  UNWIND docs as doc
  OPTIONAL MATCH (u:Users {id: &#39;${activeUserData.sub}&#39;})&lt;-[r:USED_BY]-(doc)
  OPTIONAL MATCH (c:Categories)&lt;-[cr:HAS_CATEGORY]-(doc)
  OPTIONAL MATCH (doc)-[:HAS_PILLAR]-&gt;(p:Pillars)
  WITH docCount, doc, r, cr, c, p
  ${hasOrderBy}
  RETURN docCount, doc, COLLECT(r) as rs, COLLECT(c) as crs, COLLECT(p) as prs
  SKIP ${pageOptionsDto.skip} LIMIT ${pageOptionsDto.limit}
`);

return res;
```


  [1]: https://stackoverflow.com/questions/29593998/can-you-get-the-full-count-of-result-even-when-using-limit-clause-with-neo4j","","","","false","https://stackoverflow.com/a/77434200","","0","Answer","Neo4j Query set of node with 2 relationships and set value for each relationship node","false","77434200","",,,,,
"1171",":Answer","","","A simple answer is to traverse the graph once and collect the nodes:

```
MATCH (doc:Captions)-[:HAS_CATEGORY]-(:Categories {id: &#39;ne0MtinOO6DXryRvqMxS&#39;})
MATCH (doc:Captions)-[:HAS_PILLAR]-(p:Pillars {name: &#39;Feel Good&#39;})
with collect(doc) as Docs
with [i in range(0,12) | Docs[i] ] as MyDocs, size(Docs) as docCount
unwind MyDocs as Doc
return Doc, docCount
```
This will return 12 lines. Each line is a node and the count of the docs.

Your comment above says the doc could have a pillar or a category. This query will only find docs that have _both_.

To avoid that, collect the docs from the first match statement, collect the docs from the second, and then join the lists before procedding.

The other option is to match on the docs first, then `optional match` the two possible paths.","","","","false","https://stackoverflow.com/a/77475327","","0","Answer","Neo4j Query set of node with 2 relationships and set value for each relationship node","false","77475327","",,,,,
"1172",":Comment","","","","","","","","https://stackoverflow.com/questions/77434080/neo4j-query-set-of-node-with-2-relationships-and-set-value-for-each-relationship#comment136512735_77434080","","1","Comment","","false","136512735","",,,,,
"1173",":Answer","","","To get the first and last `SECTION` in your path, declare a variable in the node patterns either side of the `NEXT_SECTION` variable length portion:
```
MATCH (start:CITY {Name: &quot;London&quot;})
MATCH (end:CITY {Name: &quot;Edinburgh&quot;})
MATCH path = (start)-[:HAS_STATION]-&gt;(:STATION)-[:BOARDS]-&gt;
             (first:SECTION)-[:NEXT_SECTION*]-&gt;(last:SECTION)-[:UNBOARDS]-&gt;
             (:STATION)&lt;-[:HAS_STATION]-(end)
RETURN first, last
```","","","","false","https://stackoverflow.com/a/77430467","","1","Answer","Neo4j Cypher show first and last connected node","false","77430467","",,,,,
"1174",":Answer","","","The title asks for the first and last sections.

Your text asks to find &quot;every section that is directly connected to a station from the path.&quot; For that, we&#39;ll find the path and then filter for the station nodes.

```
MATCH (start:CITY {Name: &quot;London&quot;})
MATCH (end:CITY {Name: &quot;Edinburgh&quot;})
match path = (start)-[mid:HAS_STATION|BOARDS|NEXT_SECTION|UNBOARDS*]-(end)
with mid
where mid:STATION
return mid
```

","","","","false","https://stackoverflow.com/a/77475549","","0","Answer","Neo4j Cypher show first and last connected node","false","77475549","",,,,,
"1175",":Comment","","","","","","","","https://stackoverflow.com/questions/77430266/neo4j-cypher-show-first-and-last-connected-node#comment136505500_77430266","","1","Comment","","false","136505500","",,,,,
"1176",":Comment","","","","","","","","https://stackoverflow.com/questions/77430266/neo4j-cypher-show-first-and-last-connected-node#comment136505633_77430266","","0","Comment","","false","136505633","",,,,,
"1177",":User","","","","","H&#229;kan L&#246;fqvist","","","","","","User","","false","2259302","",,,,,
"1178",":Comment","","","","","","","","https://stackoverflow.com/questions/77430266/neo4j-cypher-show-first-and-last-connected-node#comment136511968_77430266","","0","Comment","","false","136511968","",,,,,
"1179",":Answer","","","Looks like it is Neo4j Browser is that you&#39;re interested in, not Neo4j Desktop. Most straightforward way is to connect Neo4j Browser to your embedded database while your app is running. But also indeed you can export whole database to a file and import it in Neo4j Browser which is connected to some other db, preferably empty.

## Connect from Neo4j Browser in Neo4j Desktop

If you have started Neo4j Embedded with these settings:
```
.setConfig( BoltConnector.enabled, true )`
.setConfig(BoltConnector.encryption_level, BoltConnector.EncryptionLevel.DISABLED)
```

then you can connect to it while application is running by pointing Neo4j Browser to localhost:7687 and `No authentication` option:

[![connect to db with neo4j browser in neo4j desktop][1]][1]

---

## Connect from Neo4j Browser in Docker Neo4j image

If you have **Docker**, you can access database created by your application without application itself and without *Neo4j Desktop* installed.

If you are creating your embedded db like that:
```
DatabaseManagementService managementService = 
    new  DatabaseManagementServiceBuilder(new File(&quot;target/mydb&quot;).toPath())
```
it means database is located at `/target/mydb/` directory. It stays there even after application is stopped.

You can run a new neo4j server with this database by executing this bash command in directory with `pom.xml` once your application is stopped:
```
sudo docker run --rm -p 7474:7474 -p 7687:7687 -v $PWD/target/mydb/data:/data --name neo4j-1 neo4j
```

I am using powershell and actual commands I execute are:
```
$neo4jDataDir = &#39;./target/mydb/data/&#39;
docker run --name neo4j-1 --rm -v $neo4jDataDir`:/data -p 7474:7474 -p 7687:7687 -e NEO4J_AUTH=neo4j/qwertyuiop -d neo4j
# Checkout what&#39;s happening:
docker logs neo4j-1
# Stop server:
docker stop neo4j-1
```

Once server is up and running, **Neo4j Browser** becomes available at localhost:7474 in web browser.

Also I&#39;ve noticed when you stop server, **Neo4j Browser** keeps working until you will close it&#39;s tab in web browser.

## Export database and import in Neo4j Browser

If for some reason you can&#39;t connect to your database with Neo4j Browser, you can dump your db to a file and import it afterwards in Neo4j Browser which is connected to a different db, preferably empty. For this you will need external plugin Apoc.

1. Add these dependencies to project:
```
&lt;dependency&gt;
	&lt;groupId&gt;org.neo4j.procedure&lt;/groupId&gt;
	&lt;artifactId&gt;apoc-core&lt;/artifactId&gt;
	&lt;version&gt;${neo4j.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.neo4j.procedure&lt;/groupId&gt;
	&lt;artifactId&gt;apoc-common&lt;/artifactId&gt;
	&lt;version&gt;${neo4j.version}&lt;/version&gt;
&lt;/dependency&gt;
```

2. Register procedure you will use:
```java
...
GraphDatabaseService db = graphDb.database(GraphDatabaseSettings.DEFAULT_DATABASE_NAME);
registerProcedure(db,
		apoc.export.cypher.ExportCypher.class);
...
public static void registerProcedure(GraphDatabaseService db, Class&lt;?&gt;... procedures) {
	GlobalProcedures globalProcedures = ((GraphDatabaseAPI) db).getDependencyResolver()
			.resolveDependency(GlobalProcedures.class);
	for (Class&lt;?&gt; procedure : procedures) {
		try {
			globalProcedures.registerProcedure(procedure);
			globalProcedures.registerFunction(procedure);
			globalProcedures.registerAggregationFunction(procedure);
		} catch (KernelException e) {
			throw new RuntimeException(&quot;while registering &quot; + procedure, e);
		}
	}
}
```

3. Enable exporting to a file:
```java
ApocConfig.apocConfig().setProperty(ApocConfig.APOC_EXPORT_FILE_ENABLED, true);
```

4. Execute procedure:
```java
try (
	var driver = GraphDatabase.driver(&quot;bolt://localhost:7687&quot;, AuthTokens.none());
	var session = driver.session()) {
	var query = &quot;&quot;&quot;
			CALL apoc.export.cypher.all(&quot;all-plain.cypher&quot;, {
				format: &quot;plain&quot;,
				useOptimizations: {type: &quot;UNWIND_BATCH&quot;, unwindBatchSize: 20}
			})
			&quot;&quot;&quot;;
	session.executeRead(t -&gt; t.run(query).consume());
}
```

5. Find a `./target/mydb/all-plain.cypher` text file with all your data in Cypher format.

6. Drag and drop it to Neo4j Browser or copy-paste it&#39;s contents. 

Fully working example of dumping database to a file can be found [in this Gist](https://gist.github.com/Podbrushkin/3f16feb9b9da22ab27ee2878c38633aa).

  [1]: https://i.stack.imgur.com/PHRyl.gif","","","","true","https://stackoverflow.com/a/77503708","","0","Answer","Embedded database to neo4j desktop","false","77503708","",,,,,
"1180",":Comment","","","","","","","","https://stackoverflow.com/questions/77426516/creating-a-neo4j-node-with-multiple-relationships-and-bi-directional-relationshi#comment136503835_77426516","","0","Comment","","false","136503835","",,,,,
"1181",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/apache-kafka","apache-kafka","","Tag","","false","","",,,,,
"1182",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/apache-kafka-connect","apache-kafka-connect","","Tag","","false","","",,,,,
"1183",":Answer","","","I tried rebuilding the artifact and discovered my java version was outdated. Upgrading to java 11 resolved the issue for me.","","","","true","https://stackoverflow.com/a/77429408","","1","Answer","Apache Kafka Neo4j Connector issues","false","77429408","",,,,,
"1184",":Comment","","","","","","","","https://stackoverflow.com/questions/77424154/apache-kafka-neo4j-connector-issues#comment136497730_77424154","","0","Comment","","false","136497730","",,,,,
"1185",":User","","","","","OneCricketeer","","","","","","User","","false","2308683","",,,,,
"1186",":Answer","","","Because you&#39;re only counting relationships for a single node, either version will take milliseconds, so performance isn&#39;t relevant. Only where counts were being done for many nodes would you consider it. In any case, without profiling, the best way would be to actually measure it.

I compared the following Cypher and APOC versions for different numbers of relationships (the actual `MATCH` double counts, but that doesn&#39;t matter for this):

**Cypher**
```sql
MATCH (n)-[r]-()
RETURN 
  CASE 
    WHEN (startNode(r) = n) THEN type(r) + &#39;&gt;&#39; 
    ELSE &#39;&lt;&#39; + type(r)
  END AS type, 
  count(r) AS count
```

**APOC**
```sql
MATCH (n)
CALL {
    WITH n
    WITH n, apoc.node.relationship.types(n) AS types
    CALL {
        WITH n, types
        UNWIND types as type
        RETURN &#39;&lt;&#39;+type AS type, apoc.node.degree.in(n, type) as count
    UNION ALL 
        WITH n, types
        UNWIND types as type
        RETURN type+&#39;&gt;&#39; AS type, apoc.node.degree.out(n, type) as count
    }
    RETURN type, count
}
RETURN type, sum(count)
```

Here is a comparison (based on running the DB locally):

[![enter image description here][1]][1]

There may be a more efficient version for the APOC query, but in any case, the Cypher here is faster.

  [1]: https://i.stack.imgur.com/rIvld.png","","","","false","https://stackoverflow.com/a/77418774","","1","Answer","Neo4j count relationships of each type for given node","false","77418774","",,,,,
"1187",":Answer","","","There is actually a faster approach that also fixes a potential problem in your current queries. If `n` has any self-relationships (relationships that start/end at `n`), then such relationships would be counted twice (as both inbound and outbound relationships). In other words, the sum of the counts could be greater than the actual number of relationships.

This query should be fast and also solve the self-relationship problem:

    MATCH (n)-[r]-() WHERE id(n) = 0
    RETURN
      CASE n WHEN ENDNODE(r) THEN &#39;&lt;&#39; ELSE &#39;&#39; END +
      TYPE(r) +
      CASE n WHEN STARTNODE(r) THEN &#39;&gt;&#39; ELSE &#39;&#39; END AS type,
      COUNT(*) AS count

An inbound `REL` relationship would be represented as `&lt;REL`, an outbound one as `REL&gt;`, and a self-relationship as `&lt;REL&gt;`. And the sum of the counts would equal the actual number of relationships.

#### Including endnode labels
Here is a slightly altered query that returns a count of each distinct combination of type and end node labels (a node can have multiple labels):

    MATCH (n)-[r]-(m) WHERE id(n) = 0
    RETURN
      CASE n WHEN ENDNODE(r) THEN &#39;&lt;&#39; ELSE &#39;&#39; END +
      TYPE(r) +
      CASE n WHEN STARTNODE(r) THEN &#39;&gt;&#39; ELSE &#39;&#39; END AS type,
      LABELS(m) AS endNodeLabels,
      COUNT(*) AS count

Reading how [aggregating functions](https://neo4j.com/docs/cypher-manual/current/functions/aggregating/) work will help you understand these 2 queries.","","","","true","https://stackoverflow.com/a/77419012","","1","Answer","Neo4j count relationships of each type for given node","false","77419012","",,,,,
"1188",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/memgraphdb","memgraphdb","","Tag","","false","","",,,,,
"1189",":Comment","","","","","","","","https://stackoverflow.com/questions/77417303/memgraph-with-spring-data-neo4j#comment136485504_77417303","","0","Comment","","false","136485504","",,,,,
"1190",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/podman","podman","","Tag","","false","","",,,,,
"1191",":Answer","","","Here&#39;s the command I have used successfully with podman in the past.  I have the volumes located in sub-folders of my home folder

```
podman run -dt \
    --name=neo4jdb01 \
    --env=NEO4J_ACCEPT_LICENSE_AGREEMENT=yes \
    --env=NEO4J_AUTH=neo4j/password \
    --userns=keep-id
    --publish=7474:7474 --publish=7687:7687 \
    --volume=$HOME/Projects/neo4j/data:/data \
    --volume=$HOME/Projects/neo4j/conf:/conf \
    --volume=$HOME/Projects/neo4j/logs:/logs \
    --volume=$HOME/Projects/neo4j/plugins:/plugins \
    neo4j:enterprise
```","","","","false","https://stackoverflow.com/a/77410440","","0","Answer","podman neo4j unable to mount volume to persist data","false","77410440","",,,,,
"1192",":Comment","","","","","","","","https://stackoverflow.com/questions/77409903/podman-neo4j-unable-to-mount-volume-to-persist-data#comment136517934_77409903","","0","Comment","","false","136517934","",,,,,
"1193",":User","","","","","sh0umik","","","","","","User","","false","2202757","",,,,,
"1194",":Comment","","","","","","","","https://stackoverflow.com/questions/77409903/podman-neo4j-unable-to-mount-volume-to-persist-data#comment136520426_77409903","","0","Comment","","false","136520426","",,,,,
"1195",":Answer","","","Simple delete is ok!

DETACH DELETE is a shorter way of doing a delete relationship then delete node. So instead of doing two steps of Delete node then Delete relationship, we use DETACH DELETE in one go.

For relationship, you are NOT detach(ing) it from a node, you simply deleting it. So using detach is not needed but neo4j will flag it as an error if you do DETACH DELETE for a relationship.  It understands the redundancy and deletes it anyway.","","","","false","https://stackoverflow.com/a/77409391","","0","Answer","Optimization of a cypher query which deletes duplicate relationships","false","77409391","",,,,,
"1196",":Answer","","","`DETACH DELETE` will delete _all_ relationships attached to a given node before deleting that node. In your case, you are deleting specified relationships, so the `DETACH` keyword has no effect.

As you are using Neo4j 3.5, you could use the following as an optimized version of your query—assuming you have apoc installed:

```
CALL apoc.periodic.iterate(
    &quot;MATCH (n)-[r:R]-&gt;(m)
     WHERE exists((n)-[r]-&gt;(m)&lt;-[:R {id: r.id}]-(n))
     WITH r.id AS id, tail(collect(r)) AS branches
     UNWIND branches AS branch
     RETURN branch&quot;,
    &quot;DELETE branch&quot;,
    {batchSize: 10000, parallel: true}
)
```

Using `r.id` as the grouping key works because its value is the same for all relationships that are duplicates of each other. The `exists` also assumes that the duplicate relationships have the same source and target nodes.

If you are on Neo4j 5, you could do a safer batched version of the above with `CALL IN TRANSACTIONS`:
```
MATCH (n)-[r:R]-&gt;(m) 
WHERE EXISTS { (n)-[r]-&gt;(m)&lt;-[:R {id: r.id}]-(n) }
WITH r.id AS id, tail(collect(r)) AS branches
UNWIND branches AS branch
CALL { 
    WITH branch
    DELETE branch
} IN TRANSACTIONS OF 10000 ROWS
```","","","","false","https://stackoverflow.com/a/77410965","","0","Answer","Optimization of a cypher query which deletes duplicate relationships","false","77410965","",,,,,
"1197",":Answer","","","You have inconsistencies in your sample data.

- `scenario2` says it has 3 parents, but there are only 2 `GAP` nodes containing the `s2` key.
- `scenario3` says it has 1 parent, but there are actually 2 `GAP` nodes containing the `s3` key.

Here is a query that should work, assuming you fix your data to be consistent:

    MATCH (gap:GAP)
    WHERE gap.name IN $gaps
    UNWIND SPLIT(gap.next, &#39;,&#39;) AS sKey
    WITH sKey, COUNT(*) AS cnt
    WITH COLLECT({sKey: sKey, cnt: cnt}) AS data
    MATCH (s:SCENARIO)
    WHERE ANY(d IN data WHERE d.sKey = s.key AND d.cnt = s.parents)
    RETURN s.name AS ScenarioName;

The query assumes that the list of `GAP` names is provided as a `$gaps` [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/).

#### Suggested new model

You should strongly consider changing your data model, however. You are not using any relationships, which is the main strength of a graph database. `GAP` and `SCENARIO` nodes should not store relationship information as properties, but should be linked by actual relationships. I would also recommend conforming to the [recommended neo4j naming convention](https://neo4j.com/docs/cypher-manual/current/syntax/naming/#_recommendations), where labels are camel-cased.

For example, this could conceptually be your new data model (without the `next` and `parents` properties):

    (g:Gap {name, key, desc})-[:HAS_SCENARIO]-&gt;(s:Scenario {name, key, desc})

With this new model, the query for your use case would simply be:

    MATCH (g:Gap)-[:HAS_SCENARIO]-&gt;(s:Scenario)
    WHERE g.name IN $gaps
    WITH s, COUNT(g) AS cnt
    WHERE COUNT{ ()-[:HAS_SCENARIO]-&gt;(s) } = cnt
    RETURN s.name AS scenarioName;
","","","","true","https://stackoverflow.com/a/77405263","","1","Answer","Cypher Query to Filter SCENARIO Nodes Based on GAP Nodes","false","77405263","",,,,,
"1198",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/confluent-schema-registry","confluent-schema-registry","","Tag","","false","","",,,,,
"1199",":Answer","","","You deleted `timestamp` from the source instance&#39;s `neo4j.source.query` value, but presumably kept the `neo4j.streaming.property` still assigned to &quot;timestamp&quot;.

According to [the documentation](https://neo4j.com/docs/kafka/kafka-connect/configuration/), the optional `neo4j.streaming.property` property is:

&gt; The name of the property that we need to consider in order to
&gt; determinate the last queried record; if not defined we use an internal
&gt; value given from the last performed check. We use this value for
&gt; injecting it in the provided query defined in `neo4j.source.query` as
&gt; `$lastCheck` parameter.

*I fixed a typo in the above quote.*

Try deleting the optional `neo4j.streaming.property` property so that the internal value can be used instead.","","","","true","https://stackoverflow.com/a/77411430","","1","Answer","Kafka-Neo4J-Connector: $lastCheck not updating if no timestamp is returned","false","77411430","",,,,,
"1200",":Comment","","","","","","","","https://stackoverflow.com/questions/77403628/kafka-neo4j-connector-lastcheck-not-updating-if-no-timestamp-is-returned#comment136459846_77403628","","0","Comment","","false","136459846","",,,,,
"1201",":Comment","","","","","","","","https://stackoverflow.com/questions/77403628/kafka-neo4j-connector-lastcheck-not-updating-if-no-timestamp-is-returned#comment136466184_77403628","","0","Comment","","false","136466184","",,,,,
"1202",":Answer","","","For all that the current Docker documentation shows examples with `version: &#39;3.9&#39;`, that was never actually a [Compose file format version](https://docs.docker.com/compose/compose-file/compose-versioning/).  The most recent numbered versions are `2.4` (with extended plain-Docker options) and `3.8` (with extended Swarm-oriented options) and I&#39;d use one of these.

Docker states that they no longer support the Python-based Compose 1.x as of June 2023.  The Go-plugin-based Compose 2.x completely ignores the `version:` field, which is why the documentation examples that show `version: &#39;3.9&#39;` apparently work.  (I&#39;ve also seen some SO questions declaring `version: &#39;1.2&#39;` but Compose file format version 1 didn&#39;t support a `version:` field.)  Upgrading to the newer Compose will also make the file you show work.","","","","true","https://stackoverflow.com/a/77403478","","0","Answer","Version in &quot;neo4j-uat.yaml&quot; is unsupported. you&#39;re using the wrong Compose file version","false","77403478","",,,,,
"1203",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/version","version","","Tag","","false","","",,,,,
"1204",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/upgrade","upgrade","","Tag","","false","","",,,,,
"1205",":Answer","","","I frequently use `neo4j-admin copy` to migrate databases, and it works really well.

It recreates a fresh copy of your existing DB into the target format of the new Neo4j version.

There is a tutorial describing how to use it to migrate from `3.5` to `4.x`. That works the same way for `4.2` to `4.4` :
https://neo4j.com/docs/upgrade-migration-guide/current/version-4/tutorials/online-backup-copy-database/

**Update**: this ^^ works only for with the enterprise edition. With the community edition, you can upgrade 4.2 -&gt; 4.3 -&gt; 4.4 using a 4.3 community version downloadable [here][1].


  [1]: https://neo4j.com/download-thanks/?edition=community&amp;release=4.3.23&amp;flavour=winzip","","","","true","https://stackoverflow.com/a/77415493","","0","Answer","Can I upgrade Neo4j from version 4.2.4 straight to version 4.4.26?","false","77415493","",,,,,
"1206",":User","","","","","nmervaillie","","","","","","User","","false","1132615","",,,,,
"1207",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/openapi","openapi","","Tag","","false","","",,,,,
"1208",":Answer","","","Have you tried using qa_prompt??

    chain = GraphCypherQAChain.from_llm(
        llm=llm,
        graph=graph,
        verbose=True,
        return_intermediate_steps=True,
        cypher_prompt=cypher_prompt,
        qa_prompt=qa_prompt
    )

Something like this:

    cypher_qa_prompt = &quot;&quot;&quot;You are an assistant that helps to form nice and human understandable answers.
    The information part contains the provided information that you must use to construct an answer.
    The provided information is authoritative, you must never doubt it or try to use your internal knowledge to correct it.
    Make the answer sound as a response to the question. Do not mention that you based the result on the given information.
    If the provided information is empty, say that you don&#39;t know the answer.
    Final answer should be easily readable and structured.
    Information:
    {context}

    Question: {question}
    Helpful Answer:&quot;&quot;&quot;

    qa_prompt = PromptTemplate(
    input_variables=[&quot;context&quot;, &quot;question&quot;], template=cypher_qa_prompt
)


","","","","false","https://stackoverflow.com/a/77830259","","0","Answer","Langchain neo4j integration return no result","false","77830259","",,,,,
"1209",":Comment","","","","","","","","https://stackoverflow.com/questions/77397307/langchain-neo4j-integration-return-no-result#comment136447050_77397307","","0","Comment","","false","136447050","",,,,,
"1210",":Comment","","","","","","","","https://stackoverflow.com/questions/77397307/langchain-neo4j-integration-return-no-result#comment136453964_77397307","","0","Comment","","false","136453964","",,,,,
"1211",":Comment","","","","","","","","https://stackoverflow.com/questions/77397307/langchain-neo4j-integration-return-no-result#comment136459455_77397307","","0","Comment","","false","136459455","",,,,,
"1212",":Comment","","","","","","","","https://stackoverflow.com/questions/77397307/langchain-neo4j-integration-return-no-result#comment136461221_77397307","","0","Comment","","false","136461221","",,,,,
"1213",":Answer","","","You have set the `undirectedRelationshipTypes` incorrectly. Use the following instead:

```
MATCH (src:Subnet)-[r:SUB_OF|CONNECT_TO]-&gt;(trg:Network|TGW)
RETURN gds.graph.project(
  &#39;cypherGraph10&#39;,
  src,
  trg,
  {relationshipType: type(r)},
  {undirectedRelationshipTypes: [&#39;*&#39;]})
```

The problem lay with you setting the `undirectedRelationshipTypes` dynamically. The graph projection will only set to undirected those relationships that have the type to whatever value `type(r)` has for its first invocation i.e. the type of the relationship `r` in whatever happens to be the first record from the `MATCH` clause. For example, if the first record happens to have relationship with type `SUB_OF`, then only those relationships will be undirected in the projection.

The reason this matters is that APSP will only traverse directed relationships following their direction. If you look at your graph, if all the `CONNECT_TO` relationships were directed, then the graph would be partitioned at the green `TGW` nodes:

[![enter image description here][1]][1]

And in that case, you will get no paths connecting sub2 to sub6.   


  [1]: https://i.stack.imgur.com/nObiC.png","","","","false","https://stackoverflow.com/a/77413581","","1","Answer","Why is All Pairs Shortest Paths not finding some paths between subnets?","false","77413581","",,,,,
"1214",":Answer","","","You must have parentheses around the nodes in the match, so it should be like this:

    match (n:Yonetmen)
    where n.title=&quot;Stephen King&quot;
    match (n)-[:WRITE]-&gt;(Movie)
    return Movie ","","","","false","https://stackoverflow.com/a/77396986","","0","Answer","Neo4j Invalid input &#39;n&#39;: expected &quot;(&quot;, &quot;ALL&quot;, &quot;ANY&quot; or &quot;SHORTEST&quot;)","false","77396986","",,,,,
"1215",":Answer","","","[As documented](https://neo4j.com/docs/bloom-user-guide/current/bloom-visual-tour/legend-panel/#_default_styling), you now set the properties to display in Bloom in the `Legend Panel`&#39;s `Text` tab.

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/RaItD.png","","","","true","https://stackoverflow.com/a/77398164","","0","Answer","How to change caption of nodes from nodetype to fully specified name property?","false","77398164","",,,,,
"1216",":Answer","","","Both queries have a `LIMIT 10`, but the second query is not qualified by any `WHERE` clause, so it can simply return you the first 10 it finds.

It just finds 10 and stops.

The first query, with the additional `WHERE`, means your returned 10 *must* have a path length &gt; 3, which means it must traverse all the shorter paths and discard them, keeping track in memory of the paths it has tried. You are only looking for the longer paths. So it is simply more computation effort. And maybe more computation effort than we have patience for waiting.

","","","","false","https://stackoverflow.com/a/77395391","","0","Answer","Why does this neo4j query not finish?","false","77395391","",,,,,
"1217",":User","","","","","Stewart","","","","","","User","","false","167745","",,,,,
"1218",":Answer","","","The [answer][1] by Stewart correctly answers your question as to why the `WHERE` changes the performance. 

But to actually improve the performance of your first query, move the criteria into the lower bound for the length of paths matched:
```
MATCH path = (start:A)-[*4..]-&gt;(end:A)
WHERE start.fen = &#39;abc&#39;
WITH DISTINCT path AS distinct_path
RETURN distinct_path
LIMIT 10
```


  [1]: https://stackoverflow.com/a/77395391/2258090","","","","false","https://stackoverflow.com/a/77395476","","0","Answer","Why does this neo4j query not finish?","false","77395476","",,,,,
"1219",":Comment","","","","","","","","https://stackoverflow.com/questions/77394339/how-to-create-a-copy-of-an-existing-graph-and-perform-operations-on-it#comment136913230_77394339","","0","Comment","","false","136913230","",,,,,
"1220",":Answer","","","Since your query did not return any nodes, relationships, or paths, no *graph visualization* is possible.

For example, if you want the Neo4j Browser to display the `a` nodes in a graph visualization, your `RETURN` clause will also have to include `a` as a term (not just `a.name`, which is only a string property and not the entire node). ","","","","false","https://stackoverflow.com/a/77390440","","0","Answer","How to graph relationships between movies and actors (that they performed in common) in Neo4J movies database?","false","77390440","",,,,,
"1221",":Comment","","","","","","","","https://stackoverflow.com/questions/77390261/how-to-graph-relationships-between-movies-and-actors-that-they-performed-in-com#comment136433550_77390261","","0","Comment","","false","136433550","",,,,,
"1222",":User","","","","","ravenspoint","","","","","","User","","false","16582","",,,,,
"1223",":Answer","","","You can use the APOC procedure [`apoc.do.when`](https://neo4j.com/labs/apoc/4.2/overview/apoc.do/apoc.do.when/) to do conditional if-then-else writes. There is also a more general procedure, [`apoc.do.case`](https://neo4j.com/labs/apoc/4.2/overview/apoc.do/apoc.do.case/) for more complex conditional writes.

For example:

    CREATE (u:User)-[v:VOTES_ON {points: $points}]-&gt;(i:Item)
    WITH u, v, i
    CALL apoc.do.when(
      $points &gt; 0,
      &#39;SET i.points_up = COALESCE(i.points_up, 0) + points RETURN i&#39;,
      &#39;SET i.points_down = COALESCE(i.points_down, 0) + points RETURN i&#39;,
      { i: i, points: $points }
    )
    YIELD value AS _
    SET i.points = COALESCE(i.points, 0) + $points
    RETURN u, v, i

(Note the `RETURN i` statement in the `apoc.do.when` call, so that we get back the value and then return it later on.)","","","","true","https://stackoverflow.com/a/77390382","","1","Answer","How to Conditionally SET in Cypher depending on parameter?","false","77390382","",,,,,
"1224",":Answer","","","In a `WITH` or `RETURN` clause, an [aggregating function](https://neo4j.com/docs/cypher-manual/current/functions/aggregating/) (like [COLLECT](https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect)) aggregates over the [grouping keys](https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#grouping-keys) (i.e., non-aggregating expressions) in the same clause.

Therefore:

 1. In `WITH p1, p2, interest, COUNT(interest) AS conto`:
    - `conto` is the number of `interest` nodes associated with each unique set of `p1`, `p2`, and `interest` values.
 2. In `RETURN p1.name, p2.name, COUNT(interest), conto, COLLECT(interest.name) AS interessi`:
    - `COUNT(interest)` is the number of `interest` nodes associated with each unique set of `p1.name`, `p2.name`, and `conto` values.
    - `interessi` is a collection of `interest.name` values associated with each unique set of `p1.name`, `p2.name`, and `conto` values.

In summary, since #1 and #2 have different grouping keys, the `COUNT(interest`) values are different as well.
 ","","","","false","https://stackoverflow.com/a/77390212","","1","Answer","Cypher queries: misuse of the with clause","false","77390212","",,,,,
"1225",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/raft","raft","","Tag","","false","","",,,,,
"1226",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/ongdb","ongdb","","Tag","","false","","",,,,,
"1227",":Answer","","","This is resolved. 
I had added one node at a time to the cluster so the first added node missed the new node IPs in the config. After adding all nodes in the current cluster, and restarting the neo4j server, the cluster was up.","","","","false","https://stackoverflow.com/a/77393259","","0","Answer","neo4j ongdb: Member is not getting added to cluster after restart","false","77393259","",,,,,
"1228",":Answer","","","Your main problem is that relationships always have 1 and only 1 type. You need to reconsider how to carry out your use case.

I also have a lot of observations.

 1. `X` and `Y` are not defined, so queries 1 and 2 would fail anyway.
 2. You are incorrectly using the term &quot;label&quot;, which only applies to nodes (for example, `c` has the label `Companies`). Every relationship has **1 and only 1** &quot;type&quot;.
 3. The `SET` clause syntaxes you used are only for copying *properties*, not node labels or relationship types. In fact, you cannot change a relationship instance&#39;s type, so there is no way to do that in Cypher.
 4. Your third query is missing a `SET` clause, which I assume was accidentally omitted from your question.
 5. For better performance, filtering should always be done as soon as possible (like, right after the relevant `MATCH`).
    - Option 1: move the `c.CompanyID = 477` test immediately after `MATCH
    (c:Companies)-[r:Rel_Office]-(o:Companies)`.
    - Option 2, combine the 2 `MATCH` clauses, like this: `MATCH (c:Companies)-[r:Rel_Office]-(o:Companies), (n:Companies)`

","","","","false","https://stackoverflow.com/a/77376560","","1","Answer","Neo4j/cypher - copy relationship labels to another","false","77376560","",,,,,
"1229",":Answer","","","Your question can be treated as &quot;copy or duplicate all relationships from : Rel_Office into a new one called : Props.  Thus below query will work.

    MATCH (c:Companies)-[r:Rel_Office]-(o:Companies)
    MERGE (c)-[rn:Props]-(o)
    SET rn = properties(r)

 [![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/Ziald.png","","","","false","https://stackoverflow.com/a/77376601","","1","Answer","Neo4j/cypher - copy relationship labels to another","false","77376601","",,,,,
"1230",":Comment","","","","","","","","https://stackoverflow.com/questions/77376071/neo4j-cypher-copy-relationship-labels-to-another#comment136409654_77376071","","0","Comment","","false","136409654","",,,,,
"1231",":Comment","","","","","","","","https://stackoverflow.com/questions/77376071/neo4j-cypher-copy-relationship-labels-to-another#comment136409672_77376071","","0","Comment","","false","136409672","",,,,,
"1232",":Comment","","","","","","","","https://stackoverflow.com/questions/77376071/neo4j-cypher-copy-relationship-labels-to-another#comment136409975_77376071","","0","Comment","","false","136409975","",,,,,
"1233",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/csv-import","csv-import","","Tag","","false","","",,,,,
"1234",":Comment","","","","","","","","https://stackoverflow.com/questions/77374200/how-to-import-multiple-values-for-a-property-from-csv-file-in-neo4j#comment136409014_77374200","","1","Comment","","false","136409014","",,,,,
"1235",":User","","","","","Community","","","","","","User","","false","-1","",,,,,
"1236",":Comment","","","","","","","","https://stackoverflow.com/questions/77374200/how-to-import-multiple-values-for-a-property-from-csv-file-in-neo4j#comment136420928_77374200","","0","Comment","","false","136420928","",,,,,
"1237",":Comment","","","","","","","","https://stackoverflow.com/questions/77374200/how-to-import-multiple-values-for-a-property-from-csv-file-in-neo4j#comment137286438_77374200","","0","Comment","","false","137286438","",,,,,
"1238",":Answer","","","It is visible until you end its scope with a `WITH` statement or `RETURN`.

e.g.

    MATCH (p:Person)
    UNWIND [1, 2, 3] AS x
    WITH p // no x behind this WITH

or keep it visible

    MATCH (p:Person)
    UNWIND [1, 2, 3] AS x
    WITH p,x // x is still visible after

","","","","true","https://stackoverflow.com/a/77366917","","1","Answer","What is the scope of unwind in neo4j","false","77366917","",,,,,
"1239",":User","","","","","Michael Hunger","","","","","","User","","false","728812","",,,,,
"1240",":Answer","","","Since your original query returns a path, you can try using [apoc.path.expand](https://neo4j.com/docs/apoc/current/graph-querying/expand-paths/) instead of `apoc.path.subgraphAll`:

    @Query(&quot;&quot;&quot;
       MATCH (ord:Order {id: $orderId})
       CALL apoc.path.expand(ord, null, null, 0, -1) YIELD path
       RETURN path
    &quot;&quot;&quot;)
    List&lt;Order&gt; getOrders(@Param(&quot;orderId&quot;) Long orderId);

*NOTE: The above specifies a lower bound of `0`, so a path containing just `ord` would be returned if that node has no relationships, which I think is maybe what you intended. But this behavior is different than your original query&#39;s, which used a (defaulted) lower bound of 1 and would return nothing if `ord` has no relationships. If the latter is what you intended, change my `0` to `1`.*

Alternatively, if acceptable, a simple workaround would be to limit the length of the variable-length path search. For example, to limit the search to at most 10 hops, you could replace `[*]` with `[*..10]` (or, to use `0` lower bound: `[*0..10]`) in your original query. With my query, use `10` instead of `-1`.","","","","false","https://stackoverflow.com/a/77362433","","0","Answer","Running APOC subGraphAll() in Spring Data Neo4j","false","77362433","",,,,,
"1241",":Answer","","","That `database` config parameter [does not seem to be documented](https://neo4j.com/docs/api/javascript-driver/current/class/lib6/types.js~Config.html).

Try following the [documented approach to specifying the database](https://neo4j.com/docs/graphql/current/driver-configuration/#_specifying_the_neo4j_database). That is, specify the database name the server should use when creating driver sessions:

    await startStandaloneServer(server, {
        context: async ({ req }) =&gt; ({ req, sessionConfig: { database: &quot;mydb_name&quot; }}),
    });","","","","true","https://stackoverflow.com/a/77361712","","0","Answer","Error ACCESS on database &#39;neo4j&#39; is not allowed for user on se of neo4j/graphql","false","77361712","",,,,,
"1242",":Comment","","","","","","","","https://stackoverflow.com/questions/77359216/error-access-on-database-neo4j-is-not-allowed-for-user-on-se-of-neo4j-graphql#comment136383033_77359216","","0","Comment","","false","136383033","",,,,,
"1243",":Answer","","","Try to use &quot;neo4j+ssc&quot; on the uri like this 
URI = &quot;neo4j+ssc://838f9df7.databases.neo4j.io&quot;","","","","false","https://stackoverflow.com/a/77369794","","0","Answer","Cannot connect to Neo4j in Python to push data","false","77369794","",,,,,
"1244",":User","","","","","Samuel Fran&#231;a","","","","","","User","","false","5595816","",,,,,
"1245",":Comment","","","","","","","","https://stackoverflow.com/questions/77353888/cannot-connect-to-neo4j-in-python-to-push-data#comment136370372_77353888","","0","Comment","","false","136370372","",,,,,
"1246",":Answer","","","It appears that there is no sequence of relationships from `parent` to `gap` that passes through a `FACT` relationship.

If that is true, then your query is working as expected and should not find any `FACT` relationships.

#### Answer 1

Here is one way to display each path `p` and a list of the &quot;factoids&quot; for the nodes in that path.

    MATCH p=(parent:FEATURE)-[*]-&gt;(gap:GAP)
    WHERE parent.name = &quot;Update Profile&quot; AND gap.name contains &quot;CSRF&quot;
    UNWIND NODES(p) AS n
    RETURN p, REDUCE(
      s = [], t IN COLLECT({n: n, facts: [(n)&lt;-[r:FACT]-(f) | {rel: f, fact: f}]}) |
      CASE WHEN SIZE(t.facts) &gt; 0 THEN s + t ELSE s END) AS factoids

A &quot;factoid&quot; is a map with these properties:
  - `n` is a node in the path that has an incoming `FACT` relationship (even if that relationship is not on the path)
  - `rel` is the `FACT` relationship
  - `fact` is the source node of that `FACT` relationship

#### Answer 2

@Graphileon&#39;s fine answer is more compact, but its result contains a superfluous empty list for every path node that has no incoming `FACT` relationship.

This version of his answer uses [apoc.coll.removeAll](https://neo4j.com/docs/apoc/current/overview/apoc.coll/apoc.coll.removeAll/) to remove the empty lists:

    MATCH p=(parent:FEATURE)-[*]-&gt;(gap:GAP)
    WHERE parent.name = &quot;Update Profile&quot; AND gap.name contains &quot;CSRF&quot;
    RETURN p,
           apoc.coll.removeAll(
             [node IN NODES(p) | [fp = (node)&lt;-[:FACT]-(f) | fp ]],
             [[]]) AS factPaths

Using`apoc.coll.removeAll` to remove empty lists is for convenience and readability, but not necessary. For example, we could use `REDUCE` instead, as in Answer #1.","","","","false","https://stackoverflow.com/a/77347595","","1","Answer","Displaying hidden nodes in Neo4j","false","77347595","",,,,,
"1247",":Answer","","","I would go for something like this:

    MATCH p=(parent:FEATURE)-[*]-&gt;(gap:GAP)
    WHERE parent.name = &quot;Update Profile&quot; AND gap.name contains &quot;CSRF&quot;
    RETURN p,
           [node IN nodes(p) |
    	       [ factPath = (node)&lt;-[:FACT]-(f) | factPath ]
    	   ] AS factPaths

So you basically loop through the nodes on the path p, and pick up any incoming paths with FACT relationships

In case you want to filter out the empty lists (for nodes that do not have incoming FACT rels) it can be done with an additional WHERE

    MATCH p=(parent:FEATURE)-[*]-&gt;(gap:GAP)
    WHERE parent.name = &quot;Update Profile&quot; AND gap.name contains &quot;CSRF&quot;
    RETURN p,
         [node IN nodes(p) WHERE EXISTS((node)&lt;-[:FACT]-()) |
    	       [ factPath = (node)&lt;-[:FACT]-(f) | factPath ]
    	 ] AS factPaths

 NOTE: factPaths is returned as a nested array of paths. Depending on what you want to do with it (to the viz) or further processing, you may want to use apoc.coll.flatten() to ..eh .. flatten it","","","","false","https://stackoverflow.com/a/77348149","","1","Answer","Displaying hidden nodes in Neo4j","false","77348149","",,,,,
"1248",":Answer","","","AFAIK, Cypher does not support dynamic labels. But the apoc library does: See 

https://neo4j.com/labs/apoc/4.1/overview/apoc.merge/apoc.merge.node/","","","","false","https://stackoverflow.com/a/77348188","","0","Answer","Neo4j query not making use of indexes","false","77348188","",,,,,
"1249",":Answer","","","Neo4j does not require nodes to have consistent labeling, so every node can have any number of labels (including 0).

Now, let&#39;s suppose the Cypher execution planner was &quot;super-smart&quot; and *could* automatically use indexes if you did not specify any labels. In that case, the planner would have to test *every matching node* for its labels, and then try to determine a single coherent plan that used a combination of indexes involving those labels to minimize execution time.

Since this requires scanning all matching nodes just to come up with the execution plan, we have swamped any speedup we would get by executing the resulting plan with indexes.

So, a &quot;super-smart&quot; Cypher planner would be too slow to be of any use.","","","","true","https://stackoverflow.com/a/77349202","","2","Answer","Neo4j query not making use of indexes","false","77349202","",,,,,
"1250",":Comment","","","","","","","","https://stackoverflow.com/questions/77341501/neo4j-failed-to-invoke-procedure-apoc-refactor-mergenodes#comment136353723_77341501","","0","Comment","","false","136353723","",,,,,
"1251",":Comment","","","","","","","","https://stackoverflow.com/questions/77341501/neo4j-failed-to-invoke-procedure-apoc-refactor-mergenodes#comment136358995_77341501","","0","Comment","","false","136358995","",,,,,
"1252",":Comment","","","","","","","","https://stackoverflow.com/questions/77341501/neo4j-failed-to-invoke-procedure-apoc-refactor-mergenodes#comment136369633_77341501","","0","Comment","","false","136369633","",,,,,
"1253",":Comment","","","","","","","","https://stackoverflow.com/questions/77341501/neo4j-failed-to-invoke-procedure-apoc-refactor-mergenodes#comment136369755_77341501","","0","Comment","","false","136369755","",,,,,
"1254",":Answer","","","You can return pairs of endpoints in the results, in descending order of the number of paths between them, like so:
```
MATCH path = (start:Fen)-[*]-&gt;(end:Fen)
WHERE start.Name = &#39;A&#39;
RETURN start, end, count(*) AS count
ORDER BY count DESC
```
As an aside, you depict your desired result in the form of `A -r-&gt; B`. Assuming by `-r-&gt;` you mean all the intermediate nodes and relationships in the path, then these would all be distinct and appear in separate rows.","","","","true","https://stackoverflow.com/a/77341642","","3","Answer","How do I get the unique paths in a graph in memgraph/cypher?","false","77341642","",,,,,
"1255",":Answer","","","If you have a this type of dataset:

    CREATE (:Node {name: &#39;A&#39;});
    CREATE (:Node {name: &#39;B&#39;});
    CREATE (:Node {name: &#39;C&#39;});
    CREATE (:Node {name: &#39;D&#39;});
    CREATE (:Node {name: &#39;E&#39;});
    MATCH (a:Node {name: &#39;A&#39;}), (b:Node {name: &#39;B&#39;})
    CREATE (a)-[:r1]-&gt;(b)
    CREATE (a)-[:r2]-&gt;(b);
    MATCH (a:Node {name: &#39;A&#39;}), (c:Node {name: &#39;C&#39;})
    CREATE (a)-[:r3]-&gt;(c);
    MATCH (d:Node {name: &#39;D&#39;}), (e:Node {name: &#39;E&#39;})
    CREATE (d)-[:r4]-&gt;(e);
    MATCH (b:Node {name: &#39;B&#39;}), (d:Node {name: &#39;D&#39;})
    CREATE (b)-[:r5]-&gt;(d);
    MATCH (c:Node {name: &#39;C&#39;}), (e:Node {name: &#39;E&#39;})
    CREATE (c)-[:r6]-&gt;(e);

This should work in Memgraph:

    MATCH (start:Node {name: &#39;A&#39;})-[r]-&gt;(end:Node)
    WITH start, end, collect(r) AS rels
    ORDER BY size(rels) DESC
    RETURN start.name AS StartNode, end.name AS EndNode, size(rels) AS RelationshipCount

As result I get `A-&gt;B count:2`, `A-&gt;C count:1`

","","","","false","https://stackoverflow.com/a/77343237","","1","Answer","How do I get the unique paths in a graph in memgraph/cypher?","false","77343237","",,,,,
"1256",":User","","","","","GrandMel","","","","","","User","","false","21138720","",,,,,
"1257",":Answer","","","Paths are linear, so it isn&#39;t possible to have a result with `D` as part of the same path as `A`, `B` and `F` (without re-traversing the relationship that joins `B` and `D`—but that would yield a path with `B` appearing twice i.e. `A-&gt;B-&gt;D-&gt;B-&gt;F`). 

You can assign the second pattern to another path variable e.g. `q` and return that along with `p`:
```
MATCH p = (:Service {name: &quot;A&quot;})-[r1:CAN_READ]-&gt;(n:Service)-[r2:CAN_WRITE]-&gt;
            (:Service {name: &quot;F&quot;}),
      q = (n)-[r3:CAN_WRITE]-&gt;(:Service {name: &quot;D&quot;}) 
RETURN p, q

Results:
╒══════════════════════════════════════════════════════════════════════╤═══════════════════════════════════════════════════════════╕
│p                                                                     │q                                                          │
╞══════════════════════════════════════════════════════════════════════╪═══════════════════════════════════════════════════════════╡
│(:Service {name: &quot;A&quot;})-[:CAN_READ]-&gt;(:Service {name: &quot;B&quot;})-[:CAN_WRITE│(:Service {name: &quot;B&quot;})-[:CAN_WRITE]-&gt;(:Service {name: &quot;D&quot;})│
│]-&gt;(:Service {name: &quot;F&quot;})                                             │                                                           │
├──────────────────────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────┤
│(:Service {name: &quot;A&quot;})-[:CAN_READ]-&gt;(:Service {name: &quot;C&quot;})-[:CAN_WRITE│(:Service {name: &quot;C&quot;})-[:CAN_WRITE]-&gt;(:Service {name: &quot;D&quot;})│
│]-&gt;(:Service {name: &quot;F&quot;})                                             │                                                           │
└──────────────────────────────────────────────────────────────────────┴───────────────────────────────────────────────────────────┘
```
","","","","true","https://stackoverflow.com/a/77340950","","1","Answer","How to find paths between different services in Neo4j","false","77340950","",,,,,
"1258",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/testing","testing","","Tag","","false","","",,,,,
"1259",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/grails","grails","","Tag","","false","","",,,,,
"1260",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/import","import","","Tag","","false","","",,,,,
"1261",":Answer","","","On Windows, a backslash (`\`) in the path is taken to be a path-component separator. To treat is as a regular backslash, you need to escape it with another backslash.

This should work:

    neo4j-admin database import full --nodes /import/data_header.csv,/import/data_\\d+.csv --overwrite-destination=true
","","","","false","https://stackoverflow.com/a/77337939","","0","Answer","bulk Neo4j admin import from csv using regex","false","77337939","",,,,,
"1262",":Comment","","","","","","","","https://stackoverflow.com/questions/77333185/flask-container-cant-access-localhost8080-but-can-access-localhost7474#comment136333342_77333185","","0","Comment","","false","136333342","",,,,,
"1263",":Comment","","","","","","","","https://stackoverflow.com/questions/77333185/flask-container-cant-access-localhost8080-but-can-access-localhost7474#comment136337145_77333185","","0","Comment","","false","136337145","",,,,,
"1264",":User","","","","","Hans Kilian","","","","","","User","","false","3924803","",,,,,
"1265",":Comment","","","","","","","","https://stackoverflow.com/questions/77333185/flask-container-cant-access-localhost8080-but-can-access-localhost7474#comment136356510_77333185","","0","Comment","","false","136356510","",,,,,
"1266",":Answer","","","You can sort the items on the list in below examples:

1) Using UNWIND and COLLECT

```
    WITH  [ &quot;Coyote&quot;,&quot; Eastern Coyote&quot;]  as lst
    UNWIND lst as l
    WITH l ORDER by l
    RETURN  collect(l) as sorted_lst
```
2) Using apoc function sort


```
    WITH  [ &quot;Coyote&quot;,&quot; Eastern Coyote&quot;]  as lst
    RETURN apoc.coll.sort(lst) as sorted_lst
```

Result:

    ╒════════════════════════════╕
    │&quot;sorted_lst&quot;                │
    ╞════════════════════════════╡
    │[&quot; Eastern Coyote&quot;,&quot;Coyote&quot;]│
    └────────────────────────────┘

","","","","false","https://stackoverflow.com/a/77331835","","0","Answer","How string item order in neo4j","false","77331835","",,,,,
"1267",":Answer","","","In your question, you made some major mistakes:

1. `[&quot;Coyote&quot;,&quot; Eastern Coyote&quot;]` is a **list** of strings, not a string.
2. `ORDER BY xxx DESC` sorts in **descending** order, not ascending.
3. You said:

    &gt; ... still not make sense, cause &quot;E&quot; is Larger than &quot;C&quot;

   But the string &quot; Eastern Coyote&quot; actually starts with a **space** character, so you should have been comparing &quot; &quot; to &quot;C&quot;. The &quot; &quot; character has a lower lexical value than &quot;C&quot;. Therefore, `[&quot;Coyote&quot;,&quot; Eastern Coyote&quot;]` is the correct answer after sorting the list items in **descending** order.


You need to double-check your string values to remove extraneous spaces.

Also, to return a list of the strings from `xxx` in **ascending** order (which is the default order), you can use this snippet:

    ...
    UNWIND xxx AS y
    WITH y ORDER BY y
    RETURN COLLECT(y) AS result

Or, if you really want to return the list in **descending** order:

    ...
    UNWIND xxx AS y
    WITH y ORDER BY y DESC
    RETURN COLLECT(y) AS result","","","","false","https://stackoverflow.com/a/77333248","","0","Answer","How string item order in neo4j","false","77333248","",,,,,
"1268",":Comment","","","","","","","","https://stackoverflow.com/questions/77331216/how-string-item-order-in-neo4j#comment136330121_77331216","","1","Comment","","false","136330121","",,,,,
"1269",":User","","","","","fbiville","","","","","","User","","false","277128","",,,,,
"1270",":Comment","","","","","","","","https://stackoverflow.com/questions/77331216/how-string-item-order-in-neo4j#comment136330232_77331216","","1","Comment","","false","136330232","",,,,,
"1271",":Answer","","","Your query seems to be spending most of its time scanning through all the possible `SubjectUserNode` candidates.

So, try adding an index on `User.NodeID`. The execution planner should be able to use that index to reduce the execution time.

#### Addendum

Also, unless logically required, you should simplify your query to remove unnecessary filtering, which wastes time. For example, if all `User` nodes are also `Transaction` nodes, use `(SubjectUserNode:User ...)` instead of `(SubjectUserNode:User:Transaction ...)`.","","","","true","https://stackoverflow.com/a/77333022","","0","Answer","How to Optimize this Neo4j Query","false","77333022","",,,,,
"1272",":Answer","","","As per meeting with Garv (and also from @cybersam previous answer), removing :Transaction label on the query fixed the slow performance. The query is doing a table scan because all data in the database is labeled as Transaction.  After the fix, the run time is now 6ms vs 3.4s before. 
 

    MATCH (subjectUserNode:User{NodeID: &quot;2547:12109:000:381864&quot;})-[dimensionRelation:LegalEntity
        WHERE dimensionRelation.Status = &quot;1&quot;
    ]-&gt;(dimension:LegalEntity)&lt;-[udimensionRelation:LegalEntity
        WHERE udimensionRelation.Status = &quot;1&quot;
    ]-(user:User)-[roleRelationship:Role
        WHERE roleRelationship.Status = &quot;1&quot;
    ]-&gt;(role:Role{NodeID: &quot;2547:12122:000:70163&quot;})
    RETURN user.TransactionID as UserID","","","","false","https://stackoverflow.com/a/77368647","","0","Answer","How to Optimize this Neo4j Query","false","77368647","",,,,,
"1273",":Comment","","","","","","","","https://stackoverflow.com/questions/77328455/how-to-optimize-this-neo4j-query#comment136328801_77328455","","0","Comment","","false","136328801","",,,,,
"1274",":Comment","","","","","","","","https://stackoverflow.com/questions/77328455/how-to-optimize-this-neo4j-query#comment136332862_77328455","","0","Comment","","false","136332862","",,,,,
"1275",":Comment","","","","","","","","https://stackoverflow.com/questions/77328455/how-to-optimize-this-neo4j-query#comment136336293_77328455","","0","Comment","","false","136336293","",,,,,
"1276",":Comment","","","","","","","","https://stackoverflow.com/questions/77328455/how-to-optimize-this-neo4j-query#comment136336310_77328455","","0","Comment","","false","136336310","",,,,,
"1277",":Comment","","","","","","","","https://stackoverflow.com/questions/77328455/how-to-optimize-this-neo4j-query#comment136353774_77328455","","0","Comment","","false","136353774","",,,,,
"1278",":Comment","","","","","","","","https://stackoverflow.com/questions/77328455/how-to-optimize-this-neo4j-query#comment136395563_77328455","","0","Comment","","false","136395563","",,,,,
"1279",":Answer","","","Aggregation functions like `COUNT` can only be used in `WITH` and `RETURN` clauses.

But starting with neo4j 5.0 you can use the new [COUNT subquery](https://neo4j.com/docs/cypher-manual/current/subqueries/count/#:~:text=COUNT%20subquery%20with%20a%20UNION,not%20require%20the%20RETURN%20clause.). For example:

    MATCH (childD:ChildD {id:123})
    RETURN COUNT { (:Vacancy)&lt;-[:POTENTIAL_PROFILE]-(childD) } AS potentialJobablesCount","","","","true","https://stackoverflow.com/a/77311131","","1","Answer","Return count() from Cypher pattern comprehension","false","77311131","",,,,,
"1280",":Answer","","","You need to carefully read the [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) clause documentation, as it is easy to use incorrectly and get unexpected results. For example, individual nodes and relationships should always be `MERGE`d separately.

Also, since your query `MATCH`es `Id` nodes at the outset, all `Id` nodes mentioned in the CSV file must already exist, or else some `line`s will do nothing. It is not clear if that is intentional.

Here is a query that should work as expected (and create `Id` nodes as necessary). Note that I changed the node labels to mixed case to match the standard neo4j naming convention. Also, there is no need for a temporary node.

    LOAD CSV WITH HEADERS FROM &#39;path&#39; AS line
    MERGE (id:Id {id: line.ID})
    WITH line, id
    UNWIND SPLIT(line.Class, &quot; &quot;) AS cId
    MERGE (class:Class {id: cId})
    MERGE (id)-[r:HAS]-&gt;(class)
    RETURN r","","","","true","https://stackoverflow.com/a/77310912","","1","Answer","How to make nodes and form n to m relationship in neo4j when given &#39;m&#39; data is constructed in one csv column?","false","77310912","",,,,,
"1281",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/compatibility","compatibility","","Tag","","false","","",,,,,
"1282",":Answer","","","[`exists` has changed since Neo4j 5.0][1] to only check for graph pattern existence, not property.

neovis.js must use this variant instead:

```cypher
MATCH (n) WHERE n.pagerank IS NOT NULL
```

Note: you can read the [documentation of `exists` for Neo4j 4.4][2], which indeed worked with properties as well.


  [1]: https://neo4j.com/docs/cypher-manual/5/functions/predicate/#functions-exists
  [2]: https://neo4j.com/docs/cypher-manual/4.4/functions/predicate/#functions-exists","","","","false","https://stackoverflow.com/a/77302699","","0","Answer","Is neovis.js version 2.1.0 incompatible with neo4j version 5.12.0?","false","77302699","",,,,,
"1283",":Answer","","","Neovis.js source code [contains this snippet](https://github.com/neo4j-contrib/neovis.js/blob/7815563f5c118040e0d21c0f7bfd7dfbcfa5938f/src/defaults.ts#L3) in `defaults.ts`:

	neo4j: {
		initialQuery: `MATCH (n) WHERE exists(n.pagerank)
                        WITH (n), RAND() AS random
                        ORDER BY random LIMIT 3000
                        OPTIONAL MATCH (n)-[r]-(m)
                        //WITH n,r,m WHERE exists(n.pagerank) AND exists(m.pagerank) AND exists(m.community)
                        RETURN n, r, m;`,
        ...

That seems to be the cause of your error. You should probably create [an issue](https://github.com/neo4j-contrib/neovis.js/issues) for this.
","","","","false","https://stackoverflow.com/a/77303790","","0","Answer","Is neovis.js version 2.1.0 incompatible with neo4j version 5.12.0?","false","77303790","",,,,,
"1284",":Answer","","","Thank you for your assistance.

Neovis.js is compatible with Neo4j 5.12.0, with the exception of some deprecated syntax, such as `exists` mentioned above.

My error stemmed from the incorrect code `const vis = new NeoVis(config)`. It should have been `const vis = new NeoVis(config.value)`. I am using Vue3.js. Without the `.value`, Neovis.js cannot initialize the configuration and defaults to a Cypher clause containing `exists`. The error was resolved when I added `.value`, and my initial Cypher clause without `exists` will be executed.","","","","false","https://stackoverflow.com/a/77305617","","0","Answer","Is neovis.js version 2.1.0 incompatible with neo4j version 5.12.0?","false","77305617","",,,,,
"1285",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/security","security","","Tag","","false","","",,,,,
"1286",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/quarkus","quarkus","","Tag","","false","","",,,,,
"1287",":Comment","","","","","","","","https://stackoverflow.com/questions/77300926/what-is-the-best-way-to-create-user-config-at-first-user-login#comment136281918_77300926","","0","Comment","","false","136281918","",,,,,
"1288",":User","","","","","Sergey Beryozkin","","","","","","User","","false","1133928","",,,,,
"1289",":Comment","","","","","","","","https://stackoverflow.com/questions/77300926/what-is-the-best-way-to-create-user-config-at-first-user-login#comment136281975_77300926","","0","Comment","","false","136281975","",,,,,
"1290",":Comment","","","","","","","","https://stackoverflow.com/questions/77300926/what-is-the-best-way-to-create-user-config-at-first-user-login#comment136300506_77300926","","0","Comment","","false","136300506","",,,,,
"1291",":Comment","","","","","","","","https://stackoverflow.com/questions/77300926/what-is-the-best-way-to-create-user-config-at-first-user-login#comment136316070_77300926","","0","Comment","","false","136316070","",,,,,
"1292",":Answer","","","You can try making the last `MATCH` optional, and then use `WITH` to filter the rows.
Like this:

    MATCH (n {id: &quot;exists&quot;})
    CALL {
        WITH n
        OPTIONAL MATCH (n)--(m {id: &quot;mightExist&quot;})
        CALL {
            WITH m
            OPTIONAL MATCH (m)--(o {id: &quot;does-not-exist&quot;})
            WITH 
            CASE WHEN m IS NULL THEN NULL
            WHEN m IS NOT NULL AND o IS NULL THEN m
            ELSE o END AS inner
            RETURN inner
        }
        RETURN inner
    }
    RETURN inner","","","","false","https://stackoverflow.com/a/77303078","","0","Answer","How do I prevent a subquery from executing when an `OPTIONAL MATCH` does not return any rows","false","77303078","",,,,,
"1293",":User","","","","","Charchit Kapoor","","","","","","User","","false","12368154","",,,,,
"1294",":Comment","","","","","","","","https://stackoverflow.com/questions/77300899/how-do-i-prevent-a-subquery-from-executing-when-an-optional-match-does-not-ret#comment136276928_77300899","","0","Comment","","false","136276928","",,,,,
"1295",":Answer","","","GDS currently does not support `elementId()` values, so you will have to use `id()`.","","","","false","https://stackoverflow.com/a/77290102","","2","Answer","How to use Neo4j&#39;s gds.shortestPath.dijkstra.stream for nodes with elementId(node) intead of id(node)?","false","77290102","",,,,,
"1296",":Answer","","","elementID is a string, but you can get the id as illustrated here:

    match (n) return  toInteger(split(elementId(n),&#39;:&#39;)[2]) 

","","","","false","https://stackoverflow.com/a/77291412","","2","Answer","How to use Neo4j&#39;s gds.shortestPath.dijkstra.stream for nodes with elementId(node) intead of id(node)?","false","77291412","",,,,,
"1297",":Answer","","","You can also pass the whole node to the procedure. lets GDS handle the rest on how to identify the node.","","","","true","https://stackoverflow.com/a/77298404","","1","Answer","How to use Neo4j&#39;s gds.shortestPath.dijkstra.stream for nodes with elementId(node) intead of id(node)?","false","77298404","",,,,,
"1298",":Answer","","","The issue was that I was running the `neo4j-admin database load` command as `root`
**Solution:** 

    su neo4j             // this is the default user the ec2 neo4j template created for me
    cd $HOME
    wget &quot;url to backup&quot; // download of put .dump file here
    pwd                  // To then add it the path of the neo4j load command
    neo4j-admin database load --from-path=/var/lib/neo4j neo4j --overwrite-destination=true","","","","false","https://stackoverflow.com/a/77291596","","0","Answer","Neo4j export from Aura to AWS EC2 community instance corrupts database","false","77291596","",,,,,
"1299",":Comment","","","","","","","","https://stackoverflow.com/questions/77284758/neo4j-export-from-aura-to-aws-ec2-community-instance-corrupts-database#comment136248483_77284758","","1","Comment","","false","136248483","",,,,,
"1300",":Answer","","","Do you have the GDS plugin installed? 
Without the jar in the plugins folder Neo4j would throw this exception","","","","false","https://stackoverflow.com/a/77273909","","0","Answer","NEO4J issues with gds.enterprise.license.file","false","77273909","",,,,,
"1301",":Comment","","","","","","","","https://stackoverflow.com/questions/77273741/neo4j-issues-with-gds-enterprise-license-file#comment136245113_77273741","","0","Comment","","false","136245113","",,,,,
"1302",":Answer","","","If you already have the data in your DB, you can use a query like the following. It also removes the redundant `infId` property after creating the relationships.

    MATCH (s1:Style)
    WITH s1, SPLIT(s1.infId, &#39;;&#39;) AS infs
    MATCH (s2:Style)
    WHERE s2.styId IN infs
    CREATE (s1)-[:INFLUENCED_BY]-&gt;(s2)
    REMOVE s1.infId // Remove redundant infId property

Beforehand, you should create an [index](https://neo4j.com/docs/cypher-manual/current/indexes-for-search-performance/) on the `styId` property of `Style`, to speed up the query:

    CREATE INDEX Style_styId FOR (s:Style) ON (s.styId)

#### Alternate suggestion

But, even better, you should have created the data model you wanted when ingesting the data into your DB, instead of fixing up the DB afterwards.

There are multiple [ways to import CSV](https://neo4j.com/docs/getting-started/data-import/csv-import/) into neo4j. The simplest is via [LOAD CSV](https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/), so here is an example. Assuming your CSV file has a header row:

    CALL {
      LOAD CSV WITH HEADERS FROM &#39;file:///styles.csv&#39; AS r
      CREATE (s:Style {id: r.styId, name: r.Style, dates: r.Dates, influences: SPLIT(r.Influences, &#39;;&#39;)})
      MERGE (loc:Location {name: r.Location})
      CREATE (s)-[:LOCATION]-&gt;(l)
    }
    LOAD CSV WITH HEADERS FROM &#39;file:///styles.csv&#39; AS row
    MATCH (s1:Style)
    WHERE s1.id = row.styId
    WITH s1, SPLIT(s1.infId, &#39;;&#39;) AS infs
    MATCH (s2:Style)
    WHERE s2.id IN infs
    CREATE (s1)-[:INFLUENCED_BY]-&gt;(s2)

You may also want to create an index on `Location.name` if you have more than a few locations.

Note that this creates a slightly different data model than yours, in that:
 - each `Style` node points to a unique `Location` node
 - the `influences` property (which you may want to omit) is a list of strings
 - the `styId` is stored as the `id` property (since it is obvious that the id is for a style). This requires that your id index is created like this:

       CREATE INDEX Style_id FOR (s:Style) ON (s.id)

The ingestion is done with 2 imports from the CSV file; the first is for creating all the `Style` nodes, and the second is for creating all the `INFLUENCED_BY` relationships. The [CALL subquery](https://neo4j.com/docs/cypher-manual/current/subqueries/call-subquery/) is used to cleanly separate the 2 `LOAD CSV` invocations (otherwise, you would need to perform an aggregation between them just to reduce the number of rows back down to 1).

The above solution assumes you do not have a lot of styles, and so it does everything in a single transaction. If you have a lot of styles, you will have to change (and perhaps split up) the query to avoid running out of memory and/or taking too long.","","","","true","https://stackoverflow.com/a/77275116","","1","Answer","Creating relationships between nodes of the same label?","false","77275116","",,,,,
"1303",":Answer","","","Remember, your relationships can have properties and they too can be indexed. A major advantage of graphs is the relationships, unlike a RBDS database, are not mere connections. They have knowledge. This can be used for provenance, filtered traversals, storing unique data that should not be in the connected nodes, etc. 

If you want examples, look at how this was done with DNA segments that are used in matching persons in genealogy. With a well developed knowledge graph you create amazing vale ... such as re-creating your ancestor&#39;s DNA

[https://www.wai.md/post/the-field-of-dreams-ancestor-avatars][1]


  [1]: https://www.wai.md/post/the-field-of-dreams-ancestor-avatars","","","","false","https://stackoverflow.com/a/77284656","","1","Answer","Creating relationships between nodes of the same label?","false","77284656","",,,,,
"1304",":Comment","","","","","","","","https://stackoverflow.com/questions/77272847/creating-relationships-between-nodes-of-the-same-label#comment136231569_77272847","","0","Comment","","false","136231569","",,,,,
"1305",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/liquibase","liquibase","","Tag","","false","","",,,,,
"1306",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/liquibase-maven-plugin","liquibase-maven-plugin","","Tag","","false","","",,,,,
"1307",":Answer","","","You are using the wrong driver.
It should be `liquibase.ext.neo4j.database.jdbc.Neo4jDriver`.
I should probably rework [the documentation section on this][1].


  [1]: https://www.neo4j.com/labs/liquibase/docs/reference-configuration/","","","","true","https://stackoverflow.com/a/77272821","","0","Answer","Why am I getting ClassCastException when running Liquibase?","false","77272821","",,,,,
"1308",":Comment","","","","","","","","https://stackoverflow.com/questions/77272286/why-am-i-getting-classcastexception-when-running-liquibase#comment136227010_77272286","","0","Comment","","false","136227010","",,,,,
"1309",":Comment","","","","","","","","https://stackoverflow.com/questions/77272286/why-am-i-getting-classcastexception-when-running-liquibase#comment136275431_77272286","","0","Comment","","false","136275431","",,,,,
"1310",":Answer","","","You can see updates here https://community.neo4j.com/t/farewell-py2neo-what-happens-now/64419

Copied from Above link, 

 - https://github.com/overhangio/py2neo,
 - https://github.com/SarLecobee/py2neo,    
 - https://github.com/neo4j-field/py2neo,

And One can see here as well, https://www.reddit.com/r/Neo4j/comments/174jl66/py2neo_no_longer_available/","","","","true","https://stackoverflow.com/a/77270610","","5","Answer","Looking for a Py2neo fork","false","77270610","",,,,,
"1311",":User","","","","","chintan-p-bhatt","","","","","","User","","false","1802600","",,,,,
"1312",":Answer","","","https://github.com/memgraph/gqlalchemy is also an Object Graph Mapper (equivalent to the `py2neo`) maintained by memgraph.com. It&#39;s compatible with py2neo, but maybe an option is to migrate because the project will be maintained.

DISCLAIMER: I&#39;m the co-founder and CTO of Memgraph","","","","false","https://stackoverflow.com/a/77275372","","3","Answer","Looking for a Py2neo fork","false","77275372","",,,,,
"1313",":User","","","","","buda","","","","","","User","","false","4888809","",,,,,
"1314",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/gatsby","gatsby","","Tag","","false","","",,,,,
"1315",":Comment","","","","","","","","https://stackoverflow.com/questions/77267313/how-to-connect-to-auradb-from-a-gatsby-based-pages#comment136240660_77267313","","1","Comment","","false","136240660","",,,,,
"1316",":User","","","","","Tony Chiboucas","","","","","","User","","false","1589379","",,,,,
"1317",":Answer","","","[Your graph](https://i.stack.imgur.com/J5RN1.png) is inconsistent with the Cypher code you have shown. It has have a `Style` node that has a `name` property and is missing `Style`, `Dates`, and `Location` properties. You need to fix what is creating these inconsistent `Style` nodes, since `MERGE (s:Style {Style: stylesheet.Style, Dates: stylesheet.`Dates`, Location: stylesheet.Location})` will never match such a `Style` node.

### Some MERGE best practices

 1.   Multiple [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) clauses for the same label should all specify the same set of properties, since a `MERGE` clause with more properties will not match a node created by a `MERGE` clause with fewer properties.

 2. Ideally, a `MERGE` clause should only specify the minimum properties needed (if any) to uniquely identify a node (or relationship).

    For example, instead of:

        MERGE (a:Architect {Architect: architectsheet.Name, Born: architectsheet.Born, Died: architectsheet.Died, Description: architectsheet.Description})

    it would be safer to use this (assuming architect names are unique -- which is a bad assumption, by the way):

        MERGE (a:Architect {Architect: architectsheet.Name})
        ON CREATE SET s += {Born: architectsheet.Born, Died: architectsheet.Died, Description: architectsheet.Description}

    or, even better, since architects can have the same name (but this option requires your non-Architects csv files to reference an architect using an id instead of a name):

        MERGE (s:Style {id: architectsheet.archId})
        ON CREATE SET s += {Architect: architectsheet.Name, Style: Dates: stylesheet.`Dates`, Location: stylesheet.Location}
3. Do not use `MERGE` when you do not have data for all the properties needed to populate the node.","","","","true","https://stackoverflow.com/a/77260862","","0","Answer","How do I merge duplicate nodes as I load them in from multiple csv files?","false","77260862","",,,,,
"1318",":Answer","","","If you have TLS enabled, then you need to use a different bolt [URI scheme](https://neo4j.com/docs/bolt/current/driver-api/#uri-schemes). For example, `bolt+s`.

From the docs:

&gt; ## URI schemes
&gt; #### No TLS enabled:
&gt; 
&gt; - `bolt`: connect to a single Neo4j instance.
&gt; - `neo4j`: connect to a Neo4j instance and use the routing table
&gt; information for further connections.
&gt; 
&gt; #### Enable TLS and allow self-signed certificate authority:
&gt; 
&gt; - `bolt+ssc`
&gt; - `neo4j+ssc`
&gt; 
&gt; #### Enable TLS and only allow system enabled certificate authority and verify hostname:
&gt; 
&gt; - `bolt+s`
&gt; - `neo4j+s`

","","","","false","https://stackoverflow.com/a/77261382","","-1","Answer","neo4j.exceptions.ServiceUnavailable Connection to 127.0.0.1:7687 closed without handshake response","false","77261382","",,,,,
"1319",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4jclient","neo4jclient","","Tag","","false","","",,,,,
"1320",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/gds","gds","","Tag","","false","","",,,,,
"1321",":Comment","","","","","","","","https://stackoverflow.com/questions/77256767/gds-run-cypher-on-a-projected-graph#comment136219176_77256767","","0","Comment","","false","136219176","",,,,,
"1322",":Answer","","","This query uses the APOC procedure [apoc.convert.toTree](https://neo4j.com/docs/apoc/current/overview/apoc.convert/apoc.convert.toTree/) to generate a tree:

    MATCH p = (post:POST)&lt;-[:COMMENTED_ON]-(:COMMENT)-[:REPLIED_TO|COMMENTED_ON *0..]-(:COMMENT)
    WHERE ID(post) = 5
    WITH COLLECT(p) AS paths
    CALL apoc.convert.toTree(paths) YIELD value
    RETURN value

Read [the docs](https://neo4j.com/docs/apoc/current/overview/apoc.convert/apoc.convert.toTree/) to see how to configure the properties that are included or excluded from the generated tree.","","","","true","https://stackoverflow.com/a/77261015","","1","Answer","Cypher Query to get a nested array of nodes at each level of a tree of nodes","false","77261015","",,,,,
"1323",":Comment","","","","","","","","https://stackoverflow.com/questions/77255284/neo-clienterror-procedure-procedurenotfound-apoc-nodes-cycles#comment136196317_77255284","","0","Comment","","false","136196317","",,,,,
"1324",":Comment","","","","","","","","https://stackoverflow.com/questions/77255284/neo-clienterror-procedure-procedurenotfound-apoc-nodes-cycles#comment136198332_77255284","","0","Comment","","false","136198332","",,,,,
"1325",":Comment","","","","","","","","https://stackoverflow.com/questions/77255284/neo-clienterror-procedure-procedurenotfound-apoc-nodes-cycles#comment136205577_77255284","","0","Comment","","false","136205577","",,,,,
"1326",":Comment","","","","","","","","https://stackoverflow.com/questions/77255284/neo-clienterror-procedure-procedurenotfound-apoc-nodes-cycles#comment136213733_77255284","","0","Comment","","false","136213733","",,,,,
"1327",":Comment","","","","","","","","https://stackoverflow.com/questions/77255284/neo-clienterror-procedure-procedurenotfound-apoc-nodes-cycles#comment136216378_77255284","","0","Comment","","false","136216378","",,,,,
"1328",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/ecmascript-next","ecmascript-next","","Tag","","false","","",,,,,
"1329",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/ecmascript-2021","ecmascript-2021","","Tag","","false","","",,,,,
"1330",":Answer","","","I figured out the issue after retracing all the steps I made. 
Unfortunately, it is not related to any of the details I had posted. Partly the reason it took me so long to debug. 

However, it is not really the solution for it. 
I had added a field on schema (which is used to instantiate the driver - variable ```typeDefs```). So, ```ObjectGraphMap.init()``` fails.
Alas, Neo4j does not (yet) have the flexible schema integration with graphql. It may be not that bad as it can get pretty dynamic and error-prone without hard-fixing the schema. 

**PS:** Stacktrace needs to improve though. Not actually accepting this as an answer because there seems to be something to address on ES. Check this [out][1] and this [too][2]. 


  [1]: https://stackoverflow.com/questions/71500702/the-promise-rejected-with-the-reason-object-array-code-err-unhandled-r
  [2]: https://github.com/nodejs/node/issues/43326","","","","false","https://stackoverflow.com/a/77263019","","0","Answer","UnhandledPromiseRejection while OGM initialize on Neo4j GraphQL Express Server","false","77263019","",,,,,
"1331",":Answer","","","This query will return a list of the highest level (&quot;visible&quot;) spaces of which a `User` is a member:

    MATCH (user:User {auth_token: $auth_token})-[:MEMBER_OF]-&gt;(space)
    WITH user, COLLECT(space) AS spaces
    RETURN user, REDUCE(vs = [], s IN spaces |
      CASE WHEN NONE(a IN [(s)&lt;-[:PARENT_OF*]-(ancestor)|ancestor] WHERE a IN spaces)
      THEN vs + s
      ELSE vs END
    ) AS visibleSpaces

It ignores the `pod_state` property, as you did not specify how that should be used.","","","","true","https://stackoverflow.com/a/77246728","","1","Answer","NEO4J query clause in a tree like membership graph","false","77246728","",,,,,
"1332",":Answer","","","This is the final query:

I added some extra logic to fit my needs, but also `UNWIND` the original result to be able to `ORDER BY` and paginate with `SKIP` and `LIMIT`.

        MATCH (user:User {auth_token: $auth_token})-[:MEMBER_OF]-&gt;(space)
         WHERE space.pod_state IN [&#39;active&#39;, &#39;pending&#39;] AND space.pod_type IN [&#39;standard&#39;, &#39;readonly&#39;]
         WITH user, COLLECT(space) AS spaces
         WITH REDUCE(vs = [], s IN spaces |
          CASE WHEN NONE(a IN [(s)&lt;-[:PARENT_OF*]-(ancestor)|ancestor] WHERE a IN spaces)
          THEN vs + s
          ELSE vs END
        ) AS visibleSpaces
        UNWIND visibleSpaces AS space
        WITH space
        RETURN space
        ORDER BY datetime(space.last_active) DESC
        SKIP toInteger($page) 
        LIMIT 50","","","","false","https://stackoverflow.com/a/77247558","","0","Answer","NEO4J query clause in a tree like membership graph","false","77247558","",,,,,
"1333",":Answer","","","`MERGE` is not suitable for your use case. Here is one way to ensure a `Position` node with the exact set of properties you want exists. The query assumes that the desired properties are passed to the query in a `props` [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) (e.g., `{symbol: &quot;xxx&quot;, name: &quot;yyy&quot;, location:&quot;zzz&quot;, effective: false}`)

    OPTIONAL MATCH (p:Position)
    WHERE PROPERTIES(p) = $props
    CALL {
      WITH p
      WITH p WHERE p IS NULL
      CREATE (q:Position)
      SET q = $props
      RETURN result
      UNION
      WITH p
      WITH p WHERE p IS NOT NULL
      RETURN p AS result
    }
    RETURN ID(result)","","","","false","https://stackoverflow.com/a/77245988","","0","Answer","Inserting General Entities in Neo4j Using MERGE: Matching Issue with Similar Nodes","false","77245988","",,,,,
"1334",":Answer","","","I think this will work for you:

```
MATCH (mt:MoneyTransfer)&lt;-[s:SEND]-(:BankAccount)&lt;-[hba:HAS_BANKACCOUNT]-(ah:AccountHolder) 
WHERE (mt.TransactionDate &lt;= date(&quot;2023-09-30&quot;) 
AND mt.TransactionDate &gt;= date(&quot;2023-09-01&quot;)) 
with ah.Name as AccountHolder, AVG(mt.MoneyTransferAmount) as avgTransfer 
where avgTransfer &gt; 1000
RETURN AccountHolder, avgTransfer;
```
","","","","true","https://stackoverflow.com/a/77244356","","0","Answer","How to apply conditions on return values in Neo4j cypher","false","77244356","",,,,,
"1335",":Answer","","","This query will return a list of the names of the account holders that met a threshold transfer amount, and another list of the ones who did not.

    MATCH (mt:MoneyTransfer)&lt;-[:SEND]-(:BankAccount)&lt;-[:HAS_BANKACCOUNT]-(ah:AccountHolder)
    WHERE date($start) &lt;= mt.TransactionDate &lt;= date($end)
    WITH ah.Name as accountHolder, AVG(mt.MoneyTransferAmount) AS avgTransfer
    RETURN avgTransfer &gt;= $amount AS metThresholdAmount, COLLECT(accountHolder) AS accountHolders

The query assumes that the string `start` and `end` dates, and the threshold `amount` are passed as [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/).

For example, if there are 2 account holders, the result would look something like this:

    ╒══════════════════╤══════════════╕
    │metThresholdAmount│accountHolders│
    ╞══════════════════╪══════════════╡
    │true              │[&quot;Fred&quot;]      │
    ├──────────────────┼──────────────┤
    │false             │[&quot;Wilma&quot;]     │
    └──────────────────┴──────────────┘","","","","false","https://stackoverflow.com/a/77246900","","0","Answer","How to apply conditions on return values in Neo4j cypher","false","77246900","",,,,,
"1336",":Answer","","","First of all, you should ensure that your neo4j dependencies have compatible versions. You are currently using wildly different versions:
  - Version 5.12.0 of `neo4j`
  - Version 5.3.0 of `neo4j-java-driver`
  - Version 4.4.0.1 of `apoc`.

To keep all 3 dependencies consistent, the correct dependencies for the latter 2 artifacts are as follows (notice that the `artifactId` for core apoc is `apoc-core` in 5.x):

    &lt;dependency&gt;
        &lt;groupId&gt;org.neo4j.driver&lt;/groupId&gt;
        &lt;artifactId&gt;neo4j-java-driver&lt;/artifactId&gt;
        &lt;version&gt;${neo4j.version}&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.neo4j.procedure&lt;/groupId&gt;
        &lt;artifactId&gt;apoc-core&lt;/artifactId&gt;
        &lt;version&gt;${neo4j.version}&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

In general, to use an APOC core function (or procedure) in your embedded server, you need to find the APOC core class that implements the function (or procedure). To do that, you can:

 1. Select the [Tag](https://github.com/neo4j/apoc/tags) of the version
    you are using in the APOC core github repo.
 2. Search for the name of the function (or procedure). For example, for `apoc.text.code`, look for a match that looks like
    `@UserFunction(&quot;apoc.text.code&quot;)`.
 3. Get the name of the APOC class (including the package) that implements what you are looking for. For example,
    `apoc.text.Strings`.
 4. In your class that calls `newInProcessBuilder`, add an `import` of that APOC class.
 5. Call the builder&#39;s `withFunction` (or `withProcedure`) method and pass it the APOC class. For example, `withFunction(Strings.class)`.","","","","true","https://stackoverflow.com/a/77247307","","0","Answer","neo4j procedure testing with apoc does not compile","false","77247307","",,,,,
"1337",":Answer","","","If you [install](https://neo4j.com/docs/graph-data-science/current/installation/) the Neo4j Graph Data Science (GDS) plugin, you can use community detection algorithms. In particular, the [Weakly Connected Components](https://neo4j.com/docs/graph-data-science/current/algorithms/wcc/) (WCC) algorithm will be useful for you use case. Here is a snippet from its documentation:

&gt; The Weakly Connected Components (WCC) algorithm finds sets of
&gt; connected nodes in directed and undirected graphs. Two nodes are
&gt; connected, if there exists a path between them. The set of all nodes
&gt; that are connected with each other form a component. In contrast to
&gt; Strongly Connected Components (SCC), the direction of relationships on
&gt; the path between two nodes is not considered.

For example, if you only care about `Img` nodes (with `name` properties) and `DISTANCE` relationships, you can do something like this:

    // Create an in-memory GDS projection for the Img nodes and DISTANCE relationships
    CALL gds.graph.project(&#39;imgs&#39;, &#39;Img&#39;, &#39;DISTANCE&#39;) YIELD graphName
    // Run WCC algorithm to find each &quot;component&quot;, in which every pair of nodes is connected by some path (ignoring directionality)
    CALL gds.wcc.stream(&#39;imgs&#39;, {}) YIELD nodeId, componentId
    // For each component, collect a list of the names of all nodes in that component
    WITH componentId, COLLECT(gds.util.asNode(nodeId).name) AS names
    // Collect all those lists into an outer list (this is the result you asked for)
    RETURN COLLECT(names) AS result

The GDS projection will keep taking up memory on the server until your drop the projection or restart neo4j. To drop the projection named &quot;imgs&quot;, do this:

    CALL gds.graph.drop(&#39;imgs&#39;)

The above is barely scratching the surface of GDS, but should give you a leg up on implementing your use case.","","","","false","https://stackoverflow.com/a/77247988","","0","Answer","How do you return clusters in Neo4j?","false","77247988","",,,,,
"1338",":Comment","","","","","","","","https://stackoverflow.com/questions/77242556/how-do-you-return-clusters-in-neo4j#comment136178198_77242556","","0","Comment","","false","136178198","",,,,,
"1339",":User","","","","","Apidcloud","","","","","","User","","false","1643749","",,,,,
"1340",":Comment","","","","","","","","https://stackoverflow.com/questions/77242556/how-do-you-return-clusters-in-neo4j#comment136178370_77242556","","0","Comment","","false","136178370","",,,,,
"1341",":Comment","","","","","","","","https://stackoverflow.com/questions/77239190/neo4j-docker-admin-import-cannot-start-container#comment136168068_77239190","","0","Comment","","false","136168068","",,,,,
"1342",":Comment","","","","","","","","https://stackoverflow.com/questions/77239190/neo4j-docker-admin-import-cannot-start-container#comment136168155_77239190","","0","Comment","","false","136168155","",,,,,
"1343",":Answer","","","In the container, your command line needs to use the absolute address for the `import` directory. In your case, just insert &#39;/&#39; before the 3 `import`s:

    bin/neo4j-admin database import full --id-type=INTEGER --nodes=NodeA=/import/nodes.csv --nodes=NodeB=/import/nodesB.csv --relationships=RELA=/import/rels.csv --multiline-fields=true","","","","true","https://stackoverflow.com/a/77233591","","2","Answer","neo4j-admin import command not working in docker (java.lang.IllegalArgumentException: File &#39;import/nodes.csv&#39; doesn&#39;t exist)","false","77233591","",,,,,
"1344",":Answer","","","problem resolved 
Thanks 

Problem was PowerShell. It was not correctly installing 
","","","","false","https://stackoverflow.com/a/77237327","","0","Answer","installation issue with Neo4j Desktop Setup 1.5.9 in windows 11","false","77237327","",,,,,
"1345",":Comment","","","","","","","","https://stackoverflow.com/questions/77233161/installation-issue-with-neo4j-desktop-setup-1-5-9-in-windows-11#comment136157541_77233161","","0","Comment","","false","136157541","",,,,,
"1346",":Comment","","","","","","","","https://stackoverflow.com/questions/77233161/installation-issue-with-neo4j-desktop-setup-1-5-9-in-windows-11#comment136157747_77233161","","0","Comment","","false","136157747","",,,,,
"1347",":Comment","","","","","","","","https://stackoverflow.com/questions/77233161/installation-issue-with-neo4j-desktop-setup-1-5-9-in-windows-11#comment136164311_77233161","","0","Comment","","false","136164311","",,,,,
"1348",":Answer","","","1. The first 3 `MATCH` clauses did not use a colon in front of the relationship type. For example, `[provid_by]` should be `[:provid_by]`. This may or may not have caused a difference in the results, but it would have slowed down the query.

2. Another issue, and it is a big one, is that `UNION` can only add rows to the ultimate result. It cannot filter out any rows provided by other `UNION` terms.

3. Also, it is not clear why you have the last 3 `UNION`s. They would only add a lot of nodes that do not pass your stated criteria.

This simpler query may be sufficient:

    MATCH (node:service)
    WHERE
     (
       NONE(n IN [(node)-[:provid_by]-&gt;(dst:provider)|dst.name] WHERE n =~ &quot;(?i)Adani Transmission Limited&quot;) OR
       NONE(n IN [(node)-[:address_in]-&gt;(dst:Address)|dst.name] WHERE n =~ &quot;(?i)Formosa&quot;)
     ) AND
     NONE(n IN [(node)-[:depen_on]-&gt;(dst:res)|dst.name] WHERE n =~ &quot;(?i)Video interview data&quot;)
    RETURN node
    ORDER BY node.createdAt DESC","","","","true","https://stackoverflow.com/a/77224777","","0","Answer","How to write or with not query in neo4j","false","77224777","",,,,,
"1349",":Comment","","","","","","","","https://stackoverflow.com/questions/77221688/how-to-write-or-with-not-query-in-neo4j#comment136136560_77221688","","0","Comment","","false","136136560","",,,,,
"1350",":Comment","","","","","","","","https://stackoverflow.com/questions/77221688/how-to-write-or-with-not-query-in-neo4j#comment136137272_77221688","","0","Comment","","false","136137272","",,,,,
"1351",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/constraints","constraints","","Tag","","false","","",,,,,
"1352",":Answer","","","You can&#39;t create a `CONSTRAINT` on node-relationship-node combinations. 

It could be enforced in a DML statement for creating the relationship. For example:
```
MATCH (p:Person { name: &quot;Claudia&quot; })
WHERE NOT EXISTS { (p)-[:LIKES]-&gt;(:Hobby {name: &quot;football&quot;}) }
CREATE (p)-[:LIKES]-&gt;(:Hobby {name: &quot;football&quot;, experience: &quot;2 years&quot;})
```
This assumes the hobby might not already exist. ","","","","false","https://stackoverflow.com/a/77215248","","0","Answer","How can I create a constraint on pairs of nodes based on their labels and attributes?","false","77215248","",,,,,
"1353",":Answer","","","One option would be to change the data model slightly (don&#39;t know if that is a feasible option for you) so that you make Hobby unique by name for all. So there would only be one Hobby node with name &quot;football&quot; and all who likes football would point to the same node. That way you could have a uniqueness constraint on the name of Hobby.

With this model you would move the experience property to the relationship instead (so that the LIKES relationship would have the experience property).

However, this would not prevent the same person node to have multiple LIKES relationships to the same Hobby, but at least the same Hobby would only exist once.","","","","false","https://stackoverflow.com/a/77215322","","0","Answer","How can I create a constraint on pairs of nodes based on their labels and attributes?","false","77215322","",,,,,
"1354",":Comment","","","","","","","","https://stackoverflow.com/questions/77214504/rendering-neo4j-graph-output-in-my-web-browser#comment136130925_77214504","","0","Comment","","false","136130925","",,,,,
"1355",":User","","","","","v2belleville","","","","","","User","","false","8511812","",,,,,
"1356",":Answer","","","Your query creates a cartesian product between all :Profile nodes and the :Vacency:Decision node, then expands from each one of them checking that they&#39;re not connected.

It would likely be more efficient to match to the possible profiles from v, then match to all :Profile nodes that are NOT those. Something like this:

    PROFILE
    MATCH (v:Vacancy:Decision {id: 17210})&lt;-[:POSSIBLE_PROFILE]-(possible)
    WITH v, collect(possible) as toExclude
    MATCH (p:Profile)
    WHERE NOT p IN toExclude
    RETURN p, v;","","","","false","https://stackoverflow.com/a/77212510","","2","Answer","Neo4j Cypher query DB hits optimization","false","77212510","",,,,,
"1357",":Answer","","","The code return_name(n) should be n.return_name","","","","false","https://stackoverflow.com/a/77209175","","0","Answer","How to update the existing nodes in neo4j using python","false","77209175","",,,,,
"1358",":Answer","","","There are a few errors (and areas for improvement) in your `query`:

    query = (
        &quot;MATCH (n) WHERE return_name(n) = $return_name&quot;
        &quot;SET n.profile_id = $new_profile_id, &quot;
        &quot;    n.message = $new_message, &quot;
        &quot;    n.processing_flag = $new_processing_flag &quot;
    )

1. As $jose_bacoy stated, `return_name(n)` should be `n.return_name`, since `return_name` is a property of `Message` nodes, and Cypher has no `return_name` function.

2. `query` must have whitespace before the `SET` clause. Your query string contains the snippet `... $return_nameSET ...`, which has no whitespace before `SET`, so the query will fail to parse properly. You can actually see this issue in the query shown by the error message.

3. For efficiency and to avoid unintentional matches, you should use the node label `Message` to qualify `n`. That is, `MATCH (n:Message)` instead of `MATCH (n)`.

Here is a corrected version of your query:

    query = (
        &quot;MATCH (n:Message) WHERE n.return_name = $return_name &quot;
        &quot;SET n.profile_id = $new_profile_id, &quot;
        &quot;    n.message = $new_message, &quot;
        &quot;    n.processing_flag = $new_processing_flag &quot;
    )","","","","false","https://stackoverflow.com/a/77211803","","0","Answer","How to update the existing nodes in neo4j using python","false","77211803","",,,,,
"1359",":Answer","","","As well as the other guidance already given, you might want to try using .execute_query with the Python driver. See https://neo4j.com/docs/python-manual/current/query-simple/ for more details","","","","false","https://stackoverflow.com/a/77212219","","0","Answer","How to update the existing nodes in neo4j using python","false","77212219","",,,,,
"1360",":Answer","","","in the split, the single quotes around the coma are messing up with opening and closing the 3 strings for periodic iterate

use double quotes and you should be good...","","","","true","https://stackoverflow.com/a/77197477","","1","Answer","Splitting string with apoc.periodic.iterate","false","77197477","",,,,,
"1361",":Answer","","","This needs a double quote for the split function. Namely,
split(csv.patients,&quot;,&quot;) as pts

","","","","false","https://stackoverflow.com/a/77197478","","0","Answer","Splitting string with apoc.periodic.iterate","false","77197478","",,,,,
"1362",":Answer","","","You can get extended information about a specific native named graph by yielding and returning additional fields like `schemaWithOrientation` from the output of `CALL gds.graph.list()`. For example, `schemaWithOrientation` returns the Node labels, relationship types, relationship orientation and properties contained in the projected graph. You can refer to the full list here: https://neo4j.com/docs/graph-data-science/current/graph-list/

Example:

    CALL gds.graph.list(&#39;personsNative&#39;)
    YIELD graphName, schemaWithOrientation, configuration
    RETURN graphName, schemaWithOrientation, configuration.nodeProjection AS nodeProjection","","","","false","https://stackoverflow.com/a/77109531","","1","Answer","Is there a method to access specific node and relationship data within a graph catalog in neo4j GDS?","false","77109531","",,,,,
"1363",":User","","","","","amanb","","","","","","User","","false","8212173","",,,,,
"1364",":Answer","","","You can also use inspect the content of nodes by streaming them back (see https://neo4j.com/docs/graph-data-science/current/graph-catalog-node-ops/).
Same works for relationships (see https://neo4j.com/docs/graph-data-science/current/graph-catalog-relationship-ops/).

Further if you are good with Cypher, you can also try out Cypher on GDS (https://neo4j.com/docs/graph-data-science/current/management-ops/create-cypher-db/).","","","","false","https://stackoverflow.com/a/77110640","","1","Answer","Is there a method to access specific node and relationship data within a graph catalog in neo4j GDS?","false","77110640","",,,,,
"1365",":Answer","","","Unfortunately, GDS does not provide a way currently (in GDS 2.4.4) to get relationship IDs out of a projection.

But there is a somewhat ugly workaround. You can add to every relationship of interest a special property (say, `_relId`) containing that relationship&#39;s native ID. Then you can include that property when creating the projection, and get back that property after you generate your GDS results.

For example, in your use case:

 - Add `_relId` to all relationships (since they are all of interest in your use case).

       MATCH ()-[r]-&gt;()
       SET r._relId = ID(r)

 - Project, and include `_relId` property.

       MATCH (source)
       OPTIONAL MATCH (source)-[r]-&gt;(target)
       WITH gds.graph.project(
         &#39;graph_0&#39;,
         source,
         target,
         {
           sourceNodeLabels: labels(source),
           targetNodeLabels: labels(target),
           relationshipType: type(r),
           relationshipProperties: r { ._relId }
         }
       ) AS g
       RETURN g.graphName AS graph, g.nodeCount AS nodes, g.relationshipCount AS rels

 - Run random walk.

       MATCH (start:Buyer {name: &#39;Alice&#39;})
       CALL gds.graph.sample.rwr(&#39;mySample&#39;, &#39;graph_0&#39;, { samplingRatio: 0.66, startNodes: [id(start)] })
       YIELD nodeCount, relationshipCount
       RETURN nodeCount, relationshipCount

 - Get relationships from output projection `mySample`, including the native relationship IDs (`relNativeId` in the result).

       CALL gds.graph.relationshipProperties.stream(&#39;mySample&#39;, [&#39;_relId&#39;])
       YIELD sourceNodeId, targetNodeId, relationshipType, propertyValue
       RETURN sourceNodeId, targetNodeId, relationshipType, TOINTEGER(propertyValue) AS relNativeId

Here is a sample result:

    ╒════════════╤════════════╤════════════════╤═══════════╕
    │sourceNodeId│targetNodeId│relationshipType│relNativeId│
    ╞════════════╪════════════╪════════════════╪═══════════╡
    │171         │172         │&quot;PAYS&quot;          │256        │
    ├────────────┼────────────┼────────────────┼───────────┤
    │171         │172         │&quot;PAYS&quot;          │253        │
    ├────────────┼────────────┼────────────────┼───────────┤
    │171         │172         │&quot;PAYS&quot;          │257        │
    ├────────────┼────────────┼────────────────┼───────────┤
    │171         │172         │&quot;PAYS&quot;          │255        │
    ├────────────┼────────────┼────────────────┼───────────┤
    │171         │172         │&quot;PAYS&quot;          │258        │
    ├────────────┼────────────┼────────────────┼───────────┤
    │171         │172         │&quot;PAYS&quot;          │254        │
    └────────────┴────────────┴────────────────┴───────────┘

Caveat: If you delete a projected relationship from the DB, then its projection (including its `_relId` value) will be invalid. In fact, the stale `_relId` value would either refer to nothing, or refer to some random new relationship.","","","","true","https://stackoverflow.com/a/77130068","","0","Answer","Is there a method to access specific node and relationship data within a graph catalog in neo4j GDS?","false","77130068","",,,,,
"1366",":Comment","","","","","","","","https://stackoverflow.com/questions/77109331/is-there-a-method-to-access-specific-node-and-relationship-data-within-a-graph-c#comment135943125_77109331","","0","Comment","","false","135943125","",,,,,
"1367",":Comment","","","","","","","","https://stackoverflow.com/questions/77109331/is-there-a-method-to-access-specific-node-and-relationship-data-within-a-graph-c#comment135967587_77109331","","0","Comment","","false","135967587","",,,,,
"1368",":Comment","","","","","","","","https://stackoverflow.com/questions/77109331/is-there-a-method-to-access-specific-node-and-relationship-data-within-a-graph-c#comment135971987_77109331","","0","Comment","","false","135971987","",,,,,
"1369",":Answer","","","A uniqueness constraint creates a RANGE index. RANGE indexes internally use the B+ tree algorithm, which have O(log n) complexity.

`log2` of 1K is about 10, and `log2` of 1G is about 30. It is up to you to decide whether a factor of 3 is significant enough to warrant creating another index. Creating an extra index for only 1K nodes should not take up much storage, so that should not be a concern. You may want to try it to see if it is worth it.","","","","true","https://stackoverflow.com/a/77077498","","1","Answer","Neo4j multilabel modes and query performance","false","77077498","",,,,,
"1370",":Answer","","","You can&#39;t connect a real node with a virtual node using a real relationship (see [3rd paragraph in the docs][1]). 

But you can connect it with a virtual relationship:

```
CALL apoc.create.vRelationship(virtual_start, &#39;VIRTUAL_START&#39;, {}, virtual_analysis)
CALL apoc.create.vRelationship(virtual_analysis, &#39;VIRTUAL_END&#39;, {}, virtual_end)
```

For more, check out the [docs on apoc.create.vRelationship][2].


  [1]: https://neo4j.com/labs/apoc/4.4/virtual/
  [2]: https://neo4j.com/labs/apoc/4.4/overview/apoc.create/apoc.create.vRelationship/","","","","true","https://stackoverflow.com/a/77080535","","0","Answer","Unable to load NODE 4:db8c4fa***.. error when i using CALL apoc.create.vNode","false","77080535","",,,,,
"1371",":Comment","","","","","","","","https://stackoverflow.com/questions/77059791/how-to-show-relationship-for-specific-node-in-cypher-neo4j-with-neovis-js#comment135847605_77059791","","0","Comment","","false","135847605","",,,,,
"1372",":Answer","","","I would lean towards using something like `CALL apoc.cypher.run(rule.condition,{}) YIELD value as condition` for running and evaluating your condition. The issue with your current condition syntax is that it isn&#39;t valid Cypher.

Then you could use something like `CALL apoc.do.when()` to run the action Cypher based on value of condition. However, this means you would need to re-select the condition data again because running a generic `create (a)-[:subClassOf]-&gt;(c)` will do this across the whole data set, rather than only where (a)--&gt;(b)--&gt;(c). So I&#39;d recommend updating the action Cypher to select the subset of data and create the new relationship.

It would look something like this:
```
create (a:Class {name:&#39;A&#39;})-[:subClassOf]-&gt;(b:Class {name:&#39;B&#39;}) 
create (b)-[:subClassOf]-&gt;(c:Class {name:&#39;C&#39;}) 
create (rule:Rule {name:&#39;Rule1&#39;,
       condition:&#39;RETURN exists((:Class)-[:subClassOf]-&gt;(:Class)-[:subClassOf]-&gt;(:Class)) AS test&#39;, 
       action:&#39;MATCH (a:Class)-[:subClassOf]-&gt;(b:Class)-[:subClassOf]-&gt;(c:Class) MERGE (a)-[r:subClassOf]-&gt;(c)&#39;})

MATCH (rule:Rule {name: &#39;Rule1&#39;})
CALL apoc.cypher.run(rule.condition,{}) YIELD value
WITH rule, value.test as condition
CALL apoc.do.when(condition, &quot;CALL apoc.cypher.runSchema(rule.action,{}) YIELD value RETURN value&quot;, &quot;RETURN &#39;no action taken&#39;&quot;, {rule:rule}) YIELD value
RETURN value;
```","","","","false","https://stackoverflow.com/a/77622570","","0","Answer","How to store and use rules as string in neo4j node property","false","77622570","",,,,,
"1373",":User","","","","","Jennifer Reif","","","","","","User","","false","9397755","",,,,,
"1374",":Answer","","","One option is using `APOC`. One of the advantages is that it easily gives you only the &quot;end&quot; nodes that you want:
```
MATCH(n:Account{name:&#39;account.b&#39;})
CALL apoc.path.subgraphAll(n, {
    relationshipFilter:&quot;RESULTS_FROM&gt;|DEPENDS_ON&gt;&quot;,
    labelFilter: &quot;&gt;Account&quot;
})
YIELD nodes
RETURN nodes
```
returns: 
```
╒════════════════════════════════════════════════════════════════╕
│nodes                                                           │
╞════════════════════════════════════════════════════════════════╡
│[(:Account {name: &quot;account.y&quot;}), (:Account {name: &quot;account.c&quot;})]│
└────────────────────────────────────────────────────────────────┘
```
**EDIT:**
`relationshipFilter` was changed from `&gt;` to `RESULTS_FROM&gt;|DEPENDS_ON&gt;` according to @cybersam&#39;s remark
","","","","true","https://stackoverflow.com/a/77053626","","1","Answer","How to write a cypher query which recursively traverses a graph in Neo4j to find all the nodes visited","false","77053626","",,,,,
"1375",":Answer","","","You can just use a [variable-length relationship](https://neo4j.com/docs/cypher-manual/current/patterns/reference/#variable-length-relationships) to find all nodes that match the specified pattern (both `Calculation` and `Account` nodes):

    MATCH (:Account {name: &#39;account.b&#39;})-[:RESULTS_FROM|DEPENDS_ON*]-&gt;(n)
    RETURN n

If you only want `Account` nodes, use this instead:

    MATCH (:Account {name: &#39;account.b&#39;})-[:RESULTS_FROM|DEPENDS_ON*]-&gt;(n:Account)
    RETURN n","","","","false","https://stackoverflow.com/a/77054255","","1","Answer","How to write a cypher query which recursively traverses a graph in Neo4j to find all the nodes visited","false","77054255","",,,,,
"1376",":Answer","","","You can be more specific about the pattern you&#39;re looking for by using a [quantified path pattern][1]:
```
MATCH (:Account {name:&#39;account.b&#39;}) 
      (()-[:RESULTS_FROM]-&gt;(:Calculation)-[:DEPENDS_ON]-&gt;(:Account))+ (n)
RETURN collect(n)
```
Being more specific with patterns generally means faster.


  [1]: https://neo4j.com/docs/cypher-manual/current/patterns/reference/#quantified-path-patterns","","","","false","https://stackoverflow.com/a/77060539","","2","Answer","How to write a cypher query which recursively traverses a graph in Neo4j to find all the nodes visited","false","77060539","",,,,,
"1377",":Answer","","","The following query may work for you. It assumes that you first change your data model to replace the very complex relationship pattern `[:hasOrgan {condition:&#39;Exists (({x})-[:isInstanceOf]-&gt;(bird))&#39;}]` with the much simpler `[:hasOrgan {ifClass: &#39;bird&#39;}]`.

    MATCH (cls:Class)-[hasOrgan:hasOrgan]-&gt;(organ:organ)
    WHERE hasOrgan.ifClass IS NOT NULL
    MATCH p=(inst:instance)-[:isInstanceOf]-&gt;()-[:isSubClassOf*0..]-&gt;(cls)-[:isSubClassOf*0..]-&gt;(clsN)
    WHERE
      NOT (clsN)-[:isSubClassOf]-&gt;() AND
      ANY(c IN TAIL(NODES(p)) WHERE hasOrgan.ifClass = c.name)
    MERGE (inst)-[:hasOrgan]-&gt;(organ)

The query does this, in order:
1. Find each `hasOrgan` relationship having the `ifClass` property and the associated class `cls` and organ `organ`.
2. Find all the classes of each `instance` that is (directly or indirectly) in the class `cls`, and filter out an instance if it does not belong to the class specified by `hasOrgan.ifClass`.
3. Use `MERGE` to create the `hasOrgan` relationship, if it does not already exist.","","","","true","https://stackoverflow.com/a/77053916","","0","Answer","How to store a condition as a string in node property or relationship property and use it in a query?","false","77053916","",,,,,
"1378",":Comment","","","","","","","","https://stackoverflow.com/questions/77050646/how-to-store-a-condition-as-a-string-in-node-property-or-relationship-property-a#comment135835309_77050646","","0","Comment","","false","135835309","",,,,,
"1379",":Answer","","","You can use the `COUNT` subquery (available since Neo4j 5.3) to inline the count of neighbours to the `SET` clause.

This example is equivalent to the initial query, minus returning the original graph:
```
MATCH (n)-[r]-&gt;(c:!_event)
WITH collect(DISTINCT n) + collect(DISTINCT c) AS ncs, collect(r) AS rs
UNWIND ncs AS nc
SET nc.counter = COUNT { (nc)-[r WHERE r IN rs]-() }
```
The `COUNT` subquery does mean DB hits. As an alternative, you can avoid subsequent DB hits by just counting the relationships in the first `MATCH`:
```
MATCH (n:A)--&gt;(c:!_event)
WITH collect(n) + collect(c) AS ncs
UNWIND ncs AS nc
WITH nc, count(*) AS counter
SET nc.counter = counter
``` ","","","","false","https://stackoverflow.com/a/77045395","","2","Answer","Concise way to Add virtual property with neighbour count to each result node in Cypher","false","77045395","",,,,,
"1380",":Answer","","","The query below only needs one `MATCH`, and does not need APOC. The [CALL subqueries](https://neo4j.com/docs/cypher-manual/current/clauses/call-subquery/) do not return anything, and therefore leave the single outer row as-is. 

    .
    .
    .
    MATCH (n)-[rel]-&gt;(:!_event) //n was defined earlier, and here we exclude _events
    WITH COLLECT(rel) as rels
    CALL {
      WITH rels
      UNWIND rels AS r
      WITH STARTNODE(r) AS n, COUNT(*) AS countC
      SET n.counter = countC
    }
    CALL {
      WITH rels
      UNWIND rels AS r
      WITH ENDNODE(r) AS c, COUNT(*) AS countN
      SET c.counter = countN
    }
    UNWIND rels AS r
    RETURN STARTNODE(r) AS n, r, ENDNODE(r) AS c","","","","true","https://stackoverflow.com/a/77046822","","1","Answer","Concise way to Add virtual property with neighbour count to each result node in Cypher","false","77046822","",,,,,
"1381",":Answer","","","Not sure exactly what you want to query and what you want the result to be. But if you want to do something similar to `apoc.refactor.collapseNode()` but as a virtual path instead of modifying the graph then maybe something like this could work (this query is based on the nodes and relationships you created in your example above with John Doe and Philippe Fanaro and creates a path from the &quot;Designing&quot;-book to the &quot;System&quot;-book with a virtual relationship called &quot;:CONNECTION&quot;)?

```cypher
MATCH (n1)-[:CONNECTION_ORIGIN]-&gt;(r)-[:CONNECTION_DESTINATION]-&gt;(n2)

WITH n1, apoc.create.vRelationship(n1, &quot;CONNECTION&quot;, {}, n2) AS rel

RETURN apoc.path.create(n1, [rel])
```

Or, while adding the connection properties into the collapsed relationship and also returning the users:

```cypher
MATCH (n1:Item)
       -[:CONNECTION_ORIGIN]
      -&gt;(r:Connection)
       -[:CONNECTION_DESTINATION]
      -&gt;(n2:Item),
      (r)-[:CONNECTED_BY]-(u:User)

WITH u, 
     n1, 
     apoc.create.vRelationship(
       n1, 
       &quot;CONNECTION&quot;, 
       apoc.map.merge(
         properties(r), 
         { connected_by: u.id }
       ), 
       n2
     ) AS rel

RETURN u, apoc.path.create(n1, [rel])
```

Which yields the following:

[![results][1]][1]


  [1]: https://i.stack.imgur.com/W986q.png","","","","true","https://stackoverflow.com/a/77042079","","1","Answer","Query for Collapsing Node in Path with Multiple Relationships","false","77042079","",,,,,
"1382",":Comment","","","","","","","","https://stackoverflow.com/questions/77040693/query-for-collapsing-node-in-path-with-multiple-relationships#comment135815352_77040693","","0","Comment","","false","135815352","",,,,,
"1383",":Comment","","","","","","","","https://stackoverflow.com/questions/77040693/query-for-collapsing-node-in-path-with-multiple-relationships#comment135819008_77040693","","0","Comment","","false","135819008","",,,,,
"1384",":Comment","","","","","","","","https://stackoverflow.com/questions/77040693/query-for-collapsing-node-in-path-with-multiple-relationships#comment135824008_77040693","","0","Comment","","false","135824008","",,,,,
"1385",":Answer","","","You cannot expect Neo4j to magically protect you somehow if some random string is not legit (whatever that happens to mean, to you).

If you want to limit potential damage, you have to parse the string and verify that it is indeed a JSON object (instead of, say, executable code) with the expected properties and that their values have the right format.

*Aside: If you need to do DB queries on the data in the contacts list, you should not store the contact info in serialized strings.*

#### Sample query

Here is a sample query (where `$cId` and `$contacts` are parameters):

    MATCH (company:Companies)
    WHERE company.CompanyID = $cId
    UNWIND $contacts AS contact
    WITH apoc.convert.fromJsonMap(contact) AS c
    WITH c, TOINTEGER(c.Main) AS intMain
    WHERE
      c.Name IS NOT NULL AND c.Email IS NOT NULL AND
      c.Email =~ &quot;^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$&quot;
    WITH c, COLLECT(
      apoc.convert.toJson(CASE WHEN intMain IS NULL
        THEN c{.Name, .Email}
        ELSE c{.Name, .Email, .Main} END)) AS cleanContacts
    SET c.Contacts = cleanContacts

This query only stores contacts:
 - That have both the `Name` and `Email` properties.
 - Where the `Email` value has the expected format (you can tweak the regular expression).

And, if there is a `Main` property, it is used only if its value can be converted to an integer.

All other properties are dropped.

It stores a new contacts array that contains only validated (stringified JSON) data. The query will fail with an error if `apoc.convert.fromJsonMap` cannot parse any strings in the `$contacts` list. ","","","","false","https://stackoverflow.com/a/77024890","","0","Answer","Security of JSON in Neo4j array property","false","77024890","",,,,,
"1386",":Comment","","","","","","","","https://stackoverflow.com/questions/77022572/security-of-json-in-neo4j-array-property#comment135784543_77022572","","0","Comment","","false","135784543","",,,,,
"1387",":Comment","","","","","","","","https://stackoverflow.com/questions/77022572/security-of-json-in-neo4j-array-property#comment135784775_77022572","","0","Comment","","false","135784775","",,,,,
"1388",":Comment","","","","","","","","https://stackoverflow.com/questions/77022572/security-of-json-in-neo4j-array-property#comment135785640_77022572","","0","Comment","","false","135785640","",,,,,
"1389",":Answer","","","There are several issues with your code. Here are some major ones:

 1. Your first `WITH` does not specify `parentNode`, so the second `OPTIONAL MATCH` has to find all possible matching nodes instead of re-using the `parentNode` found earlier. This is obviously bad for your results and slows down the query.
 2. Each `MATCH` clause (whether `OPTIONAL` or not) will cause a multiplication in the number of working rows unless you do something to prevent that (like doing an aggregation in between `MATCH` clauses). For example, if you already have 5 rows and a `MATCH` generates 10 results, then you end up with 50 rows. This will obviously greatly skew the eventual sum.

Here is a query that should work better (and it also addresses some other inefficiencies):

    MATCH (:Type1 {id: &#39;1234&#39;})-[:REL_W]-&gt;(:Type2)&lt;-[:REL_P]-(t2:Type2)
    CALL {
      WITH t2
      MATCH (t2:Type3)-[:REL_W]-&gt;(qnode:Type1:Static)
      RETURN SUM(TOFLOAT(qnode.value)) AS qSum
    }
    CALL {
      WITH t2
      MATCH (t2:Type4)-[:REL_I]-(:Type2)&lt;-[:REL_W]-(lnode:Type1:Static)
      RETURN SUM(TOFLOAT(lnode.value)) AS lSum
    }
    RETURN qSum + lSum AS weight

Also, you should should consider changing the stored `value` properties to floating point (instead of what I assume are strings). That will allow you to remove the `TOFLOAT`s and speed up your query.","","","","false","https://stackoverflow.com/a/77010562","","0","Answer","Neo4j Cypher query Optional match with multiple CASE WHEN THEN","false","77010562","",,,,,
"1390",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/database-migration","database-migration","","Tag","","false","","",,,,,
"1391",":Comment","","","","","","","","https://stackoverflow.com/questions/76983191/neo4j-migration-from-5-5-0-to-5-11-0-failed-to-invoke-procedure-apoc-cypher-m#comment136530281_76983191","","1","Comment","","false","136530281","",,,,,
"1392",":User","","","","","DeeperUnderstanding","","","","","","User","","false","865766","",,,,,
"1393",":Comment","","","","","","","","https://stackoverflow.com/questions/76983191/neo4j-migration-from-5-5-0-to-5-11-0-failed-to-invoke-procedure-apoc-cypher-m#comment136533111_76983191","","0","Comment","","false","136533111","",,,,,
"1394",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/go","go","","Tag","","false","","",,,,,
"1395",":Answer","","","You&#39;re basically looking at the following query : 

&gt; MATCH Categorie nodes where their id is in the given list of ids and those nodes shouldn&#39;t be the parent of any other Categorie

Based on your model, you&#39;re looking at adding a predicate that Categorie nodes do not have an `INCOMING` relationship of type `CHILD_OF`

```
WITH [1,5,9,12] AS categoryIds
MATCH (n:Categorie)
WHERE n.id IN categoryIds
AND NOT ()-[:CHILD_OF]-&gt;(n)
RETURN n.id
```","","","","true","https://stackoverflow.com/a/76980193","","2","Answer","Cypher to find (multiple) &quot;lowest&quot; nodes","false","76980193","",,,,,
"1396",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/pattern-matching","pattern-matching","","Tag","","false","","",,,,,
"1397",":Answer","","","There was [a somewhat related issue with the EXISTS subquery](https://github.com/neo4j/neo4j/issues/13098) in version 5.6 that was supposed to be fixed in Neo4j 5.11. And indeed, I tested the sample query provided by that issue in 5.11 and it did not generate any error. But that query did not involve the `shortestPath` function.

However, your 2 queries, which seem reasonable to me, continue to cause the same errors in 5.11. The issue seem related to processing of the `shortestPath` function. If you replaced the first clause of each query with `MATCH (startNode:Node {id : 1})-[:Relationship*]-(endNode:Node {id : 2})`, the errors go away.

You should create a [new issue](https://github.com/neo4j/neo4j/issues/new/choose) for the `shortestPath` function, and use your 2 queries (or something simpler) as examples.","","","","false","https://stackoverflow.com/a/76971083","","0","Answer","How to find the shortest path not containing a pattern?","false","76971083","",,,,,
"1398",":Answer","","","After explaining [the problem on the Neo4j GitHub](https://github.com/neo4j/neo4j/issues/13286), the Neo4j team addressed this bug and declared that it has been **fixed in the 5.15 release.** I have not personally verified nor tested this.","","","","true","https://stackoverflow.com/a/77494339","","0","Answer","How to find the shortest path not containing a pattern?","false","77494339","",,,,,
"1399",":Answer","","","Can you check the installed GDS version? (RETURN gds.version())
The current docs point to 2.4 but I suspect you have an older version installed. ","","","","false","https://stackoverflow.com/a/76962783","","0","Answer","Neo4j GDS: Cannot use Cypher to make a complex projection","false","76962783","",,,,,
"1400",":Comment","","","","","","","","https://stackoverflow.com/questions/76957864/neo4j-gds-cannot-use-cypher-to-make-a-complex-projection#comment135666775_76957864","","0","Comment","","false","135666775","",,,,,
"1401",":Comment","","","","","","","","https://stackoverflow.com/questions/76957864/neo4j-gds-cannot-use-cypher-to-make-a-complex-projection#comment135667061_76957864","","0","Comment","","false","135667061","",,,,,
"1402",":Comment","","","","","","","","https://stackoverflow.com/questions/76957864/neo4j-gds-cannot-use-cypher-to-make-a-complex-projection#comment135669554_76957864","","0","Comment","","false","135669554","",,,,,
"1403",":Comment","","","","","","","","https://stackoverflow.com/questions/76957864/neo4j-gds-cannot-use-cypher-to-make-a-complex-projection#comment135695867_76957864","","0","Comment","","false","135695867","",,,,,
"1404",":Comment","","","","","","","","https://stackoverflow.com/questions/76957864/neo4j-gds-cannot-use-cypher-to-make-a-complex-projection#comment135704958_76957864","","0","Comment","","false","135704958","",,,,,
"1405",":Answer","","","You&#39;ve got 7 nested loops here, that account for 13^7 iterations, i.e. more than 62 million iterations. Either the query never completes because it runs out of memory or it just needs (a lot of) time.

If you only need to create 13 `CT11000000` nodes, you could instead define a single `UNWIND` with a single list of 13 maps:

```
UNWIND [
    {A: 6432013617038820698, B: 1, C: &#39;1000000&#39;, D: &#39;Attribute101&#39;, E: 4, F: &#39;1000161&#39;, G: 1}
    // [...] + 12 other maps
] AS attributes
CREATE (:CT11000000 {VA: attributes.A, VB: attributes.B, VC: attributes.C, VD: attributes.D, VE: attributes.E, VF: attributes.F, VG: attributes.G})
```

Side note: please have a look at the [Cypher style guide][1], the label and properties&#39; case are quite unusual here


  [1]: https://neo4j.com/docs/cypher-manual/current/styleguide/#cypher-styleguide-casing","","","","true","https://stackoverflow.com/a/76952360","","2","Answer","NEO4J UNWIND CREATE runs endless","false","76952360","",,,,,
"1406",":Answer","","","A simpler alternative to @fbiville&#39;s query:

    UNWIND [
        {va: 6432013617038820698, vb: 1, vc: &#39;1000000&#39;, vc: &#39;Attribute101&#39;, vc: 4, vc: &#39;1000161&#39;, vc: 1}
        // [...] + 12 other maps
    ] AS attributes
    CREATE (n:CT11000000)
    SET n = attributes","","","","false","https://stackoverflow.com/a/76956788","","1","Answer","NEO4J UNWIND CREATE runs endless","false","76956788","",,,,,
"1407",":Answer","","","If you are using Neo4j 5.6+, you can use the [COLLECT subquery](https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#collect-subqueries). Here is a sample snippet:

    ...
    RETURN COLLECT {
        MATCH (rc:Criterion)
        WHERE rc.id IN childD.replaceableCriterionIds
        RETURN {entity: rc}
    } AS decisionReplaceableCriteria

In prior versions of Neo4j, you can try a hack:

    ...
    RETURN [ (rc:Criterion)-[*0]-&gt;() WHERE rc.id IN childD.replaceableCriterionIds | {entity: rc} ] AS decisionReplaceableCriteria

This uses a [variable-length path](https://neo4j.com/docs/cypher-manual/current/patterns/primer/#variable-length-paths) pattern specifying a length of 0. If you want to see if this variable-length path pattern causes any DB hits, [PROFILE](https://neo4j.com/docs/cypher-manual/current/query-tuning/query-profile/) your query and look at the `VarLengthExpand` operation&#39;s &quot;db hits&quot;.","","","","true","https://stackoverflow.com/a/76948661","","1","Answer","Neo4j Cypher Pattern comprehension in return statement","false","76948661","",,,,,
"1408",":Answer","","","Your second snippet does not have an equivalent to the `size(cGroups) &gt;= size(childD.detailedCriterionIds)` test, so it will not always produce the same result.

In order to do that test, you need to calculate the number of `cGroups`. Therefore, there may not be a better approach than what you are already doing in the first snippet.

*Minor nit: the `WITH childD, childDStat, cGroup` clause is redundant.*","","","","true","https://stackoverflow.com/a/76947841","","1","Answer","Neo4j Cypher reduce UNWINDs calls","false","76947841","",,,,,
"1409",":Comment","","","","","","","","https://stackoverflow.com/questions/76941753/neo4j-cypher-reduce-unwinds-calls#comment135648521_76941753","","0","Comment","","false","135648521","",,,,,
"1410",":Comment","","","","","","","","https://stackoverflow.com/questions/76941753/neo4j-cypher-reduce-unwinds-calls#comment135650109_76941753","","0","Comment","","false","135650109","",,,,,
"1411",":Answer","","","Yes, you never get to the case when rel is null because it does not go past the optional match, if there is no match for the pattern.

You can try with this data:

    create (:Store {id:22,name:&quot;STORE DEMO NAME&quot;})-[:HAS_ARTICLE ]-&gt;(:Article {price :30,name:&quot;Candy&quot;,date:&quot;2023-12-13&quot;});
    :param {&quot;data&quot;:[{&quot;store_id&quot;: 22, &quot;article_name&quot;: &quot;Candy&quot;, &quot;date&quot;: &quot;2023-12-14&quot;, &quot;price&quot;: 32},{&quot;store_id&quot;: 22, &quot;article_name&quot;: &quot;Chocolate&quot;, &quot;date&quot;: &quot;2023-12-14&quot;, &quot;price&quot;: 32},{&quot;store_id&quot;: 22, &quot;article_name&quot;: &quot;Chocolate&quot;, &quot;date&quot;: &quot;2023-12-12&quot;, &quot;price&quot;: 25}]}

then run this 

    unwind $data as art
    match (store:Store {id: art.store_id})
    merge (store)-[rel:HAS_ARTICLE]-&gt;(article:Article {name:art.article_name})
    on create set article.date=art.date,article.price=art.price
    with art,article where article.date&lt;art.date
    set article.date=art.date,article.price=art.price

its all in `merge` that creates the part of the pattern that does not exists. it&#39;s a bit tricky to figure out, I found this video helpful to understand how it works https://www.youtube.com/watch?v=w42uqxGd7qM&amp;t=12s

I did not put the date on the relationship because I could not understand why you need it beside the one on the article

the first line of data updates &quot;candy&quot;, the second creates &quot;chocolate&quot; the third is ignored because the date is earlier than the one chocolate was created with","","","","false","https://stackoverflow.com/a/76941307","","1","Answer","Issue Creating TempArticle in Neo4j Cypher Query","false","76941307","",,,,,
"1412",":Answer","","","When `rel` is `NULL`, then `shouldCreateTempArticle` will be true and `shouldUpdateRel` false. But when `shouldUpdateRel` is false, the `WHERE shouldUpdateRel` clause in your query aborts the query (for the relevant rows). Therefore, when `shouldUpdateRel` is false the `shouldCreateTempArticle `logic that occurs later in your query will never get processed.

Here is a solution that uses two [CALL subquery](https://neo4j.com/docs/cypher-manual/current/clauses/call-subquery/) clauses to avoid the two subqueries interfering with each other or the final return value:

    MATCH (store:Store {store_id: $store_id})
    OPTIONAL MATCH (store)-[rel:HAS_ARTICLE {article_name: $article_name}]-&gt;(article)
    WITH *,
      rel IS NOT NULL AND rel.date &lt; date($new_date) AS shouldUpdateRel,
      rel IS NULL AS shouldCreateTempArticle
    CALL {
        WITH *
        WITH * WHERE shouldUpdateRel
        SET rel.date = date($new_date)
        SET rel.prev_price = rel.price
        SET rel.price = $new_price 
        SET rel.article_name =  $article_name
    }
    CALL {
        WITH *
        WITH * WHERE shouldCreateTempArticle
        CREATE (tempArticle:TempArticle {article_name: $article_name, article_description: $article_description})
        MERGE (store)-[newRel:HAS_ARTICLE]-&gt;(tempArticle)
        SET newRel.date = date($new_date)
        SET newRel.price = $new_price
        SET newRel.article_name =  $article_name
    }
    RETURN store, article, shouldUpdateRel, shouldCreateTempArticle

 The query also returns both flags (`shouldUpdateRel` and `shouldCreateTempArticle`) as a hint as to what was done.","","","","true","https://stackoverflow.com/a/76947709","","1","Answer","Issue Creating TempArticle in Neo4j Cypher Query","false","76947709","",,,,,
"1413",":Answer","","","Your fist query:
`MATCH (u:USER {name:&quot;abcd&quot;}) RETURN u` is only good for simple specific cases, while the second query: `MATCH (u:USER} WHERE u.name = &quot;abcd&quot; RETURN u` is for the general case.
If you have a case where you only want to match a node with a very simple condition, like `name = &quot;abcd&quot;`, both will work. 

For more complicated conditions use `WHERE`. For example:
```
MATCH (u:USER)
WHERE (u.name = &quot;abcd&quot; AND u.age &gt; 27) OR (u.name = &quot;abcde&quot; AND u.age &gt; 28)
RETURN u
```

Inside a `WHERE` clause you can use boolean operators like `AND`, `OR`, `XOR`, and `NOT`.
you can also use `IN` and `CONTAINS`

For more information, check out the [documentation](https://neo4j.com/docs/cypher-manual/current/clauses/where/)","","","","true","https://stackoverflow.com/a/76930320","","1","Answer","When to use WHERE in Cypher Neo4j?","false","76930320","",,,,,
"1414",":Answer","","","There are several ways to go. Since you want to have all the types of the data even if it is `0`, one option is:
```
MATCH (n:NODE)
OPTIONAL MATCH (n)-[r]-(m:NODE)
WHERE 
    type(r) IN [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
WITH 
    CASE type(r) WHEN &#39;A&#39; THEN 1 ELSE 0 END AS cA, 
    CASE type(r) WHEN &#39;B&#39; THEN 1 ELSE 0 END AS cB,
    CASE type(r) WHEN &#39;C&#39; THEN 1 ELSE 0 END AS cC,
    n.key AS Node
RETURN Node, SUM(cA) AS countA, SUM(cB) AS countB, SUM(cC) AS countC
```
Which for sample data:
```
MERGE (n0:NODE {key:&#39;n0&#39;})
MERGE (n1:NODE {key:&#39;n1&#39;}) 
MERGE (n2:NODE {key:&#39;n2&#39;}) 
MERGE (n3:NODE {key:&#39;n3&#39;}) 
MERGE (n4:NODE {key:&#39;n4&#39;})    

MERGE(n0)-[:A]-(n1)
MERGE(n0)-[:A]-(n2)
MERGE(n0)-[:B]-(n3)
MERGE(n1)-[:B]-(n2)
```
Returns:
```
╒══════╤════════╤════════╤════════╕
│&quot;Node&quot;│&quot;countA&quot;│&quot;countB&quot;│&quot;countC&quot;│
╞══════╪════════╪════════╪════════╡
│&quot;n0&quot;  │2       │1       │0       │
├──────┼────────┼────────┼────────┤
│&quot;n1&quot;  │1       │1       │0       │
├──────┼────────┼────────┼────────┤
│&quot;n2&quot;  │1       │1       │0       │
├──────┼────────┼────────┼────────┤
│&quot;n3&quot;  │0       │1       │0       │
├──────┼────────┼────────┼────────┤
│&quot;n4&quot;  │0       │0       │0       │
└──────┴────────┴────────┴────────┘
```
*Note that your approach in the question, will not return &quot;n4&quot; as it has no relationships and your query only match nodes with a relationship.","","","","true","https://stackoverflow.com/a/76930122","","1","Answer","Return a count of every edge type leaving a node in neo4j","false","76930122","",,,,,
"1415",":Answer","","","I don&#39;t have Windows, so I can&#39;t test your query as it is.

I do have two different theories, though.

There is a security restriction that prevents LOAD CSV from reading from any directory on the local system, but only things under the import folder. It might be that you used to use an older version that didn&#39;t have this security restriction before.

This is controlled by this config in neo4j.conf: &lt;br&gt;
&lt;code&gt;server.directories.import=import&lt;/code&gt;

Remove or comment it out to get access to the entire file system (but please consider the security implications of that).

If that is not the case, it could be because you have &lt;code&gt;:&lt;/code&gt; in the column names of the CSV.

This was fixed in Neo4j 5.5.0. Now this works if the header entry also specifies a property type, e.g. &lt;code&gt;my-key:with-colons:string&lt;/code&gt;","","","","false","https://stackoverflow.com/a/76928050","","0","Answer","What causes Neo4j error: Illegal char &lt;:&gt; at index 3","false","76928050","",,,,,
"1416",":Answer","","","As far as I understand, you may want something like this:
```
MATCH (b:BOC_beroep)-[r:MAPS_TO]-&gt;(s:Soft_Skill)
WITH SUM(1) AS total, r.type AS type, COLLECT(r.b) AS type_sum
WITH REDUCE(total=0, number in type_sum | total + number) AS type_sum, type, total
WITH COLLECT ({type: type, type_sum: toFloat(type_sum)}) AS data, SUM(total) AS total
UNWIND data AS d
WITH d.type_sum / total * 100 AS percent, d.type AS type
RETURN percent, type
ORDER BY percent DESC
```
Which for sample data:
```
MERGE (a1:BOC_beroep {occupation: &#39;dokter&#39;, code_occupation: &#39;sk_565&#39;})  
MERGE (a2:Soft_Skill {skill_code: &#39;sk_687&#39;, name: &#39;leren&#39;}) 
MERGE (a1)-[:MAPS_TO{type:&quot;optioneel&quot;, b:0.5, k:1}]-(a2)
MERGE (a1)-[:MAPS_TO{type:&quot;optioneel&quot;, b:0.5, k:2}]-(a2)
MERGE (a1)-[:MAPS_TO{type:&quot;essentieel&quot;, b:1, k:3}]-(a2)
MERGE (a1)-[:MAPS_TO{type:&quot;essentieel&quot;, b:1, k:4}]-(a2)
```
Returns:
```
╒═════════╤════════════╕
│&quot;percent&quot;│&quot;type&quot;      │
╞═════════╪════════════╡
│50.0     │&quot;essentieel&quot;│
├─────────┼────────────┤
│25.0     │&quot;optioneel&quot; │
└─────────┴────────────┘
```","","","","false","https://stackoverflow.com/a/76922614","","1","Answer","calculation of percentage from a column is table neo4j/Cypher","false","76922614","",,,,,
"1417",":Answer","","","Your `MAPS_TO` relationships apparently store the `b` property as a string, so any query must always convert it to a float to do math with it. Also, the math in your query is wrong - `r.b` should be in the numerator and `total` should be in the denominator.

This query may work for you:

    MATCH (b:BOC_beroep)-[r:MAPS_TO]-&gt;(s:Soft_Skill)
    WITH b.beroepstitel AS beorep, r.type AS type, s.name AS skill, SUM(TOFLOAT(r.b)) AS weight
    WITH SUM(weight) As total, COLLECT([beorep, type, skill, weight]) AS data
    UNWIND data AS datum
    RETURN
      datum[0] AS beroep,
      datum[1] AS type,
      datum[2] AS skill,
      datum[3]/total*100 AS percent
    ORDER BY percent desc

The first `WITH` clause sums all the weights for a given `beorep`, `type`, and `skill`. The second `WITH` clause calculates a total of all the weights and collects all the other data needed. The rest of the query is straightforward.

Here is a sample result:

    ╒════════╤════════════╤═══════╤═════════════════╕
    │beroep  │type        │skill  │percent          │
    ╞════════╪════════════╪═══════╪═════════════════╡
    │&quot;dokter&quot;│&quot;essentieel&quot;│&quot;leren&quot;│66.66666666666666│
    ├────────┼────────────┼───────┼─────────────────┤
    │&quot;dokter&quot;│&quot;optioneel&quot; │&quot;leren&quot;│33.33333333333333│
    └────────┴────────────┴───────┴─────────────────┘

#### Recommendations

 1. If you stored the `b` property as a float instead of a string, you can avoid the cost of doing `TOFLOAT` conversions all the time. You can easily convert all the stored weights this way:

        MATCH ()-[r:MAPS_TO]-&gt;()
        SET r.b = TOFLOAT(r.b)

 2. If `type` only has 2 possible values, it would require less storage space to store that property as a boolean (named, say, `isRequired`) instead. This can also simplify queries using that property. You can easily convert that property this way:

        MATCH ()-[r:MAPS_TO]-&gt;()
        SET r.isRequired = CASE r.type WHEN &#39;essentieel&#39; THEN true ELSE false END
        REMOVE r.type

","","","","true","https://stackoverflow.com/a/76923616","","0","Answer","calculation of percentage from a column is table neo4j/Cypher","false","76923616","",,,,,
"1418",":Comment","","","","","","","","https://stackoverflow.com/questions/76921714/calculation-of-percentage-from-a-column-is-table-neo4j-cypher#comment135603774_76921714","","0","Comment","","false","135603774","",,,,,
"1419",":User","","","","","ScottyJ","","","","","","User","","false","3601357","",,,,,
"1420",":Comment","","","","","","","","https://stackoverflow.com/questions/76921714/calculation-of-percentage-from-a-column-is-table-neo4j-cypher#comment135603782_76921714","","0","Comment","","false","135603782","",,,,,
"1421",":Comment","","","","","","","","https://stackoverflow.com/questions/76921714/calculation-of-percentage-from-a-column-is-table-neo4j-cypher#comment135604320_76921714","","0","Comment","","false","135604320","",,,,,
"1422",":Answer","","","The deprecated syntax on line 4 can be also done when you aggregate the data.values after you define the dictionary {column: , value:}

Thus, no need to do the collect in line 4 since it is a duplication of the collect in line 5 later on. Instead, define the columns in line 5 so that will be in line with what you want on line 6. See updated query below.



    1 MATCH (n:test) with n limit 100
    2 WITH DISTINCT n, keys(n) AS allKeys
    3 UNWIND allKeys AS key
    4 with n, 
        CASE
            WHEN key STARTS WITH &#39;prop.title&#39; THEN {column: &#39;title&#39;, value: n[key]}
            WHEN key STARTS WITH &#39;prop.keywords&#39; THEN {column: &#39;keywords&#39;, value: n[key]}
        END AS data
    5 WITH n, data.column as columns, collect(data.value) as values  
    6 RETURN n.id as id, apoc.map.fromPairs(collect([columns, values]))","","","","false","https://stackoverflow.com/a/76913741","","0","Answer","Cypher query warning give inconsistent result when fix","false","76913741","",,,,,
"1423",":Answer","","","I believe you could rewrite your query to something like this:

    MATCH (n:test) with n limit 100 
    WITH DISTINCT n, keys(n) AS allKeys
    UNWIND allKeys AS key
    WITH n, 
        // Note: in the original query you used the aggregation expression `collect` which made `key` an implicit grouping key.
        CASE
          WHEN key STARTS WITH &#39;prop.title&#39; THEN {column: &#39;title&#39;, value:n[key]}
          WHEN key STARTS WITH &#39;prop.keywords&#39; THEN {column: &#39;keywords&#39;, value:n[key]}
        END AS data
    WITH n, data.column AS column, collect(data.value) as values
    RETURN n.id, apoc.map.fromPairs(COLLECT([column, values]))

The problem with your original query was that you used non-grouping keys outside of an aggregation expression, so called &quot;implicit grouping keys&quot;. Prior to neo4j 5.0 we allowed implicit grouping keys, but as that can get very confusing it was removed in 5.0. You can read more about the confusion with implicit grouping keys here: https://opencypher.org/articles/2017/07/27/ocig1-aggregations-article/

So, let&#39;s take this step-by-step:

Assume that you have a single node:

    CREATE (:test{`prop.title1`:&quot;title1&quot;, `prop.title2`:&quot;title2&quot;, `prop.keywords`:&quot;hey!&quot;})

After this part of the query:

    MATCH (n:test) with n limit 100
    WITH DISTINCT n, keys(n) AS allKeys
    UNWIND allKeys AS key

You have:

| n   | key             | allKeys                                         |
| ---- | --------------- | ----------------------------------------------- |
| n | &quot;prop.title1&quot;   | \[&quot;prop.title1&quot;, &quot;prop.title2&quot;, &quot;prop.keywords&quot;] |
| n | &quot;prop.title2&quot;   | \[&quot;prop.title1&quot;, &quot;prop.title2&quot;, &quot;prop.keywords&quot;] |
| n | &quot;prop.keywords&quot; | \[&quot;prop.title1&quot;, &quot;prop.title2&quot;, &quot;prop.keywords&quot;]` |

Let&#39;s have a look at the next part of the original query: 

    with n, 
    CASE
        WHEN key STARTS WITH &#39;prop.title&#39; THEN {column: &#39;title&#39;, value: collect(n[key])}
        WHEN key STARTS WITH &#39;prop.keywords&#39; THEN {column: &#39;keywords&#39;, value: collect(n[key])}
    END AS data

the explicit grouping keys are the projected variables/properties that does not contain any aggregations - which in this case is `n`. That means that all other variables which are used outside of an aggregation expression are &quot;implicit&quot; grouping keys - in your case the implicit grouping key is `key`. Implicit grouping keys are no longer supported from 5.0. But, instead of adding it as an explicit grouping key, you can remove the aggregation expression &quot;collect&quot;:


    WITH n, 
         CASE
           WHEN key STARTS WITH &#39;prop.title&#39; THEN {column: &#39;title&#39;, value:n[key]}
           WHEN key STARTS WITH &#39;prop.keywords&#39; THEN {column: &#39;keywords&#39;, value:n[key]}
         END AS data

This would mean that we know have:

| n | data                                |
| ---- | ----------------------------------- |
| n | {column: &quot;title&quot;, value: &quot;title1&quot;}  |
| n | {column: &quot;title&quot;, value: &quot;title2&quot; } |
| n | {column: &quot;keywords&quot;, value: &quot;hey!&quot;}` |

If you now look at the next part of the original query:

    with n, data, collect(data.value) as values

You again have the aggregation expression `collect` with grouping keys `n` and `data`. But you don&#39;t want to group on the full `data` object, instead you want to collect all `data.values` grouped by `n` and `data.column`:

    WITH n, data.column AS column, collect(data.value) as values

Which gives us:

| n | column            |  values |
| ---- | --------------- | -------- |
| n | &quot;title&quot; | [&quot;title1&quot;, &quot;title2&quot;]   |
| n | &quot;keywords&quot; | [&quot;hey!&quot;] |


I hope this made it a bit more clear","","","","true","https://stackoverflow.com/a/76913801","","5","Answer","Cypher query warning give inconsistent result when fix","false","76913801","",,,,,
"1424",":User","","","","","Linn&#233;a Andersson","","","","","","User","","false","22399046","",,,,,
"1425",":Answer","","","This simpler query may work for your use case:

    MATCH (n:test) WITH n LIMIT 100
    UNWIND KEYS(n) AS key
    WITH n, key, CASE
      WHEN key STARTS WITH &#39;prop.title&#39; THEN &#39;title&#39;
      WHEN key STARTS WITH &#39;prop.keywords&#39; THEN &#39;keywords&#39;
      END AS type
    WHERE type IS NOT NULL
    WITH n, type, COLLECT(n[key]) AS values
    RETURN n.id, apoc.map.fromPairs(COLLECT([type, values]))

The `WITH DISTINCT n, ...` clause did not do anything (and was deleted), since we already know from the preceding `MATCH` clause that all `n` values would be distinct.","","","","false","https://stackoverflow.com/a/76916010","","0","Answer","Cypher query warning give inconsistent result when fix","false","76916010","",,,,,
"1426",":Comment","","","","","","","","https://stackoverflow.com/questions/76910603/cypher-query-warning-give-inconsistent-result-when-fix#comment135589289_76910603","","0","Comment","","false","135589289","",,,,,
"1427",":Comment","","","","","","","","https://stackoverflow.com/questions/76910603/cypher-query-warning-give-inconsistent-result-when-fix#comment135654888_76910603","","0","Comment","","false","135654888","",,,,,
"1428",":Answer","","","Despite that the query is not optimal 
the error is  simply the semicolon i put in in line 5

after removing it, i get the expected result.

I hope the snippet helps someone anyways, for optimization ideas please reply
","","","","false","https://stackoverflow.com/a/76891240","","0","Answer","Cypher, Reusing information, with EXISTS{} as varname and then use varname, fails","false","76891240","",,,,,
"1429",":Answer","","","Even after you remove the erroneous semicolon in line 5, your query would not completely work the way you want. That is because when `A` is false the `WHERE A` clause would immediately end your query (and it would never return &#39;error&#39;).

This query will work as you intended:

    MATCH (a:User), (b:User)
    WHERE ID(a) = 0 AND ID(b) = 1
    WITH a, b, NOT (b)-[*]-&gt;(a) as A
    CALL {
      WITH *
      WITH * WHERE A
      MERGE (a)-[:has_connection]-&gt;(:Connection)-[:supports]-&gt;(b)
    }
    RETURN CASE A
      WHEN TRUE THEN &#39;success&#39;
      ELSE &#39;error&#39; END AS result

This query uses a [CALL subquery](https://neo4j.com/docs/cypher-manual/current/clauses/call-subquery/) to avoid ending the query prematurely when `A` is false.","","","","false","https://stackoverflow.com/a/76892345","","0","Answer","Cypher, Reusing information, with EXISTS{} as varname and then use varname, fails","false","76892345","",,,,,
"1430",":Answer","","","There are several things wrong with this query.

 - Your WHERE clause doesn&#39;t reference a node property, you need to use dot notation to indicate the node for which the predicate applies: `WHERE n.CompanyID = $CompanyID`
 - The RETURN is in an invalid position. You cannot use it here in the middle of the query. It should only go at the end of a subquery, or at the end of the query itself. In this case, you can remove the RETURN entirely, unless you want something returned from the query when it finishes, in which case the RETURN should be at the very end.

Best practice here, especially when you are still learning Cypher, is to use the Neo4j Browser to ensure the syntax is correct. You can prefix the query with EXPLAIN to just make sure it compiles properly, and if not follow the error messages to correct syntax issues.","","","","false","https://stackoverflow.com/a/76886698","","1","Answer","Neo4j match and 2 merges","false","76886698","",,,,,
"1431",":Comment","","","","","","","","https://stackoverflow.com/questions/76886401/neo4j-match-and-2-merges#comment135543783_76886401","","1","Comment","","false","135543783","",,,,,
"1432",":Comment","","","","","","","","https://stackoverflow.com/questions/76886401/neo4j-match-and-2-merges#comment135544051_76886401","","0","Comment","","false","135544051","",,,,,
"1433",":Answer","","","It does not work on all levels because you are anchoring the first node OF EACH iteration to be ‘Atma ram’. That works for the first iteration, but the second (and following) iterations will not start with the ‘Atma ram’ node, so you only get results from the first one.

I guess you want to anchor the starting point of the whole repetitions, not the starting point of every iteration.
To do that, you need to extract the starting point out of the repetition parenthesis:
```
 MATCH (s:Person where s.name = &#39;Atma ram&#39;) ((p)&lt;-[:IS_MAN_OF]-(m:Marriage)-[:IS_SON_OF]-&gt;(p1:Person)){1,} return p, p1
```

(s:Person where s.name = &#39;Atma ram&#39;) is the anchor, it matches the start node, and on the first iteration, is joined with (p) (see [equijoins](https://neo4j.com/docs/cypher-manual/current/patterns/concepts/#equijoins) in the docs).
On the second iteration, the end node of the first iteration (p1) will join with the first node of the second iteration (p), allowing the path to repeat, and so on.

If you look at the documentation, Concepts, [Quantified Path Pattern section](https://neo4j.com/docs/cypher-manual/current/patterns/concepts/#quantified-path-patterns), you’ll get a more detailed example that anchors both the start end the end station of a rail trip. You can anchor the end of repetitions similarly as you can anchor the start.

Hope it helps
","","","","true","https://stackoverflow.com/a/76858359","","4","Answer","Quantifying path patterns","false","76858359","",,,,,
"1434",":User","","","","","valdrake","","","","","","User","","false","16625291","",,,,,
"1435",":Answer","","","There are some issues with your query.

The main problem may be that your logic is trying to process 10000 communities (and all of their officers) in each transaction, which may be way too much data to handle per transaction.

The other issue is that you are `COLLECT`ing the nodes *twice* per community. The second time, you are just counting the size of the collection -- but you are doing that in a very inefficient way -- instead of `SIZE(COLLECT(n))` you should have just used `COUNT(n)`. But even worse, you immediately throw away the count because you don&#39;t return it. So, you need to completely eliminate the counting.

This query, which addresses the above issues, may work better for you. You will have to determine for yourself the best `batchSize` for your data.

    CALL apoc.periodic.iterate(&#39;
        MATCH (n:Officer)
        WITH n.community AS com, collect(n) AS nodicom
        RETURN nodicom
      &#39;,&#39;
        CALL apoc.refactor.mergeNodes(nodicom,{
            properties:&quot;discard&quot;, mergeRels:true, preserveExistingSelfRels:false}) YIELD node
      &#39;,{batchSize: 200, parallel: true})
    YIELD batches, total
    RETURN batches, total

","","","","true","https://stackoverflow.com/a/76854610","","0","Answer","apoc.periodic.iterate never return a result","false","76854610","",,,,,
"1436",":Answer","","","[It seems](https://github.com/neo4j-contrib/neo4j-apoc-procedures/issues/1048) the ability to avoid creating duplicates of existing nodes was discussed but not implemented for `apoc.import.csv`, because it would slow down the procedure. That procedure is really intended for loading a new database.

As an alternative, you could just do the import using [LOAD CSV](https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/) and [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/). `MERGE` is used in this query to only create the node if it does not yet exist:

    LOAD CSV FROM &#39;file:///add.csv&#39; AS row
    MERGE (a1:Account {id: row[1]})
    MERGE (a2:Account {id: row[2]})
    CREATE (a1)-[:transaction {id: row[0], timestamp: row[3]}]-&gt;(a2)

NOTE: You can speed this query up by create an [index](https://neo4j.com/docs/cypher-manual/current/indexes-for-search-performance/) or [uniqueness constraint](https://neo4j.com/docs/cypher-manual/current/constraints/) on `:Account(id)`. Also, you should probably remove the first row (the header) from your data file, as the above query assumes it is not there.","","","","true","https://stackoverflow.com/a/76843130","","2","Answer","Adding Elements to an Already Existing Graph in Neo4j","false","76843130","",,,,,
"1437",":Answer","","","The start and end keys are refering to the Neo4j internal node identifiers, which should not be used outside from Neo4j, as they can change over time.

Your query itself shouldn&#39;t require using those; the following query should work:

    MATCH (c:Contact {contact_id: &#39;111&#39;})-[t:TRANSACTION*1..3]-()
    RETURN c, t

Using distinct(t) is not required, as Neo4j does not the same relation twice inside a single path.","","","","false","https://stackoverflow.com/a/76831994","","1","Answer","Get all the relations between models including node data","false","76831994","",,,,,
"1438",":User","","","","","user4417327","","","","","","User","","false","deleted","",,,,,
"1439",":Answer","","","This may work for you:

    MATCH (:Contact {contact_id: &#39;111&#39;})-[rs:TRANSACTION*..3]-()
    UNWIND rs AS r
    WITH DISTINCT
      STARTNODE(r).contact_id AS from,
      ENDNODE(r).contact_id AS to,
      r
    WITH from, to, COLLECT(r.amount) AS amounts
    RETURN COLLECT({from: from, to: to, amounts: amounts}) AS result

This query gets all distinct relationships for each `from/to` pair, collects the `amount` values for each pair, and then returns all the results in a single list.

Note: If N relationships for the same pair have the same `amount`, then that `amount` will appear N times in the `transactions` list for that pair. I presume this is what you wanted.

The results should look something like this:

    [
    { 
        from: &#39;111&#39;,
        to: &#39;222&#39;,
        amounts: [10000]
    },
    { 
        from: &#39;222&#39;,
        to: &#39;333&#39;,
        amounts: [2000]
    },
    { 
        from: &#39;222&#39;,
        to: &#39;444&#39;,
        amounts: [4000]
    }
    ]","","","","false","https://stackoverflow.com/a/76837637","","1","Answer","Get all the relations between models including node data","false","76837637","",,,,,
"1440",":Answer","","","NOTE: Since your maximum path length is 20, any query could take a very long time or run out of memory, depending on your data characteristics.

#### Approach 1

This query finds every path of up to length 20 using those 3 relationship types in any direction, and then filters for those in which every type points in the required direction (`Aggregation` must point right, and the others must point left).

    MATCH p=(:NodeType1)-[:Use|Realisation|Aggregation*..20]-(:NodeType2)
    WHERE ALL(i IN RANGE(0, LENGTH(p)-1) WHERE NODES(p)[i] = CASE TYPE(RELATIONSHIPS(p)[i])
      WHEN &#39;Aggregation&#39; THEN
        STARTNODE(RELATIONSHIPS(p)[i])
      ELSE
        ENDNODE(RELATIONSHIPS(p)[i]) END
    )
    RETURN p

#### Approach 2

This may be faster than approach 1.

This query uses the APOC procedure [apoc.path.expandConfig](https://neo4j.com/labs/apoc/4.1/overview/apoc.path/apoc.path.expandConfig/), which has special support for use cases like yours.

    MATCH (n:NodeType1)
    CALL apoc.path.expandConfig(n, {
        relationshipFilter: &quot;&lt;Use|&lt;Realisation|Aggregation&gt;&quot;,
        labelFilter: &quot;&gt;NodeType2&quot;,
        minLevel: 1,
        maxLevel: 20
    }) YIELD path
    RETURN path","","","","true","https://stackoverflow.com/a/76830433","","0","Answer","Neo4j search for nodes while combining relationship types in different directions?","false","76830433","",,,,,
"1441",":Answer","","","This is a fundamentally exponentially hard problem; more input data will result in way more possibilities to check with brute force like approaches.

Therefore I would suggest splitting your approach in two steps:

1. Generate a vector representation from your input data. My own search showed that you can pass your string input data to n-gram frunctions to get small chunks of the original string, which you can then pass to a tf-idf function to get an actual vector. Do that for all your input params, make sure that the vectors are always the same length, merge them and put them in a vector database.
2. Execute a vector similarity search inside your vector database to get similar records, which might fulfill your levenshtein-distance requirements. Then check your requirement for every returned element in a brute force like fashion.

This approach should drastically reduce the amount of checks you would have to do, but requires a vector database. I think Neo4j has basic vector capabilities, but I am not sure how good they are. The key aspect is the vector similarity search itself.

Note: The n-gram-data to vector step might not be consistent if some n-gram-fragment is not part of another n-gram-result. This might require some testing or more standardization, not sure.","","","","false","https://stackoverflow.com/a/76825869","","0","Answer","Optimized way to create relationship between millions of nodes","false","76825869","",,,,,
"1442",":Answer","","","Sub or nested queries usually run faster.Something like ...

    MATCH (p1:sample500K) WITH collect(p1) as pp1
    unwind pp1 as x
    call
    {
      with x
      MATCH (p2:sample500K)
      WHERE id(x) &lt;id(p2)
    AND (
      apoc.text.levenshteinDistance(x.email, p2.email) + 
      apoc.text.levenshteinDistance(x.phone, p2.phone) + 
      apoc.text.levenshteinDistance(x.mobilephone, p2.mobilephone) +
      apoc.text.levenshteinDistance(x.street, p2.street)) &lt;= $threshold
    MERGE (x)-[:SAME_USER500K]-&gt;(p2)
    }

It might run faster with a double nesting?
","","","","false","https://stackoverflow.com/a/76835883","","0","Answer","Optimized way to create relationship between millions of nodes","false","76835883","",,,,,
"1443",":Comment","","","","","","","","https://stackoverflow.com/questions/76825661/optimized-way-to-create-relationship-between-millions-of-nodes#comment135442677_76825661","","0","Comment","","false","135442677","",,,,,
"1444",":Answer","","","You should:

1. Move the `WHERE` clause right under your `MATCH` clause. Currently, your `WHERE` clause is under the `OPTIONAL MATCH` clause, and so the ID filtering is only done after finding the relationships of **all** `MY_LABEL` nodes.
2. Remove the `:MY_LABEL` qualification from the `MATCH` clause. If you already get the node by native ID, checking the label is unnecessary; and you are not using indexing.
3. Pass the list of IDs as a [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/). This will cause the Cypher query planner to run much faster (since the Cypher code will be simple), and once the plan is created it will be cached and reused every time you rerun the query with a new ID list. This also makes your client code simpler and faster as well.

This should be much faster:

    query = f&#39;&#39;&#39;
        MATCH 
            (n)
        WHERE 
            ID(n) in $id_list
        OPTIONAL MATCH 
            (n) -- (u:OTHER_LABEL) // Won&#39;t always have a neighbor
        RETURN 
            ID(n) as nid, 
            n.feature1,
            u.feature2
    &#39;&#39;&#39;
    resp = graph.run(query, id_list=very_long_list_of_nids)

Also, if the relationships between `MY_LABEL` and `OTHER_LABEL` always flow in one direction, you should consider using a directional relationship pattern (either `--&gt;` or `&lt;--`) in your `OPTIONAL MATCH` clause, especially if your `MY_LABEL` nodes have other kinds of relationships that flow in the opposite direction.","","","","true","https://stackoverflow.com/a/76823335","","2","Answer","Best way to query a large list of nodes in neo4j","false","76823335","",,,,,
"1445",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/jqassistant","jqassistant","","Tag","","false","","",,,,,
"1446",":Answer","","","There&#39;s no generic way of matching the client invocations to the providing service endpoints - it&#39;s highly dependent on the programming model of the client. Feign has a declarative model which makes it quite easy to provide the mapping, but there would be nearly no chance to do this if someone used Apache HTTP client constructing resource URLs by doing string concatenation.
Enabling this kind of client-server interaction analysis would add requirements to the programming model used on client side, e.g. to use Feign or OpenAPI contracts. For the latter we&#39;re currently building a scanner which will be available in autumn this year.","","","","true","https://stackoverflow.com/a/76826858","","1","Answer","jQAssistant analysis to find microservices and their clients","false","76826858","",,,,,
"1447",":User","","","","","Dirk Mahler","","","","","","User","","false","2912200","",,,,,
"1448",":Answer","","","Try this one:



    UNWIND custom.test() as id
    MATCH (m: Movie) where m.id = id
    RETURN m.title AS title

UNWIND is like a for loop so it will fix your code and will not hang.
Please test it out. ","","","","false","https://stackoverflow.com/a/76787781","","0","Answer","Neo4j APOC custom function hangs when nothing is found","false","76787781","",,,,,
"1449",":Answer","","","Change your custom function&#39;s query to this:

    OPTIONAL MATCH (m:Movie)
    RETURN m.id AS id

If there are no `Movie` nodes, the `OPTIONAL MATCH` will cause `[NULL]` to be returned from your custom function, and your test query will work as expected (i.e., return no results) in that case.

You can test that the custom function works when there are no results by replacing `:Movie` with `:FooBar` in its query (instead of using `LIMIT 0`).","","","","false","https://stackoverflow.com/a/76789902","","1","Answer","Neo4j APOC custom function hangs when nothing is found","false","76789902","",,,,,
"1450",":Answer","","","Although adding `OPTIONAL` to the `MATCH` statement indeed helped to avoid hanging, this approach is only applicable to `MATCH`, not to `CALL`.

I propose a general solution:
At the end of the query, we should collect all the results into an array using `COLLECT()` and create the function with the parameter `forceSingle = true`:

    CALL apoc.custom.declareFunction(&#39;test(limit :: INTEGER)::LIST OF INTEGER?&#39;, &#39;
    MATCH (m:Movie)
    WITH m.id AS id
    LIMIT $limit
    RETURN COLLECT(id)
    &#39;, true)

Now, calling the function `RETURN custom.test(0) as ids` returns `[{&#39;ids&#39;: []}]`.","","","","true","https://stackoverflow.com/a/76807045","","0","Answer","Neo4j APOC custom function hangs when nothing is found","false","76807045","",,,,,
"1451",":Comment","","","","","","","","https://stackoverflow.com/questions/76786571/neo4j-apoc-custom-function-hangs-when-nothing-is-found#comment135372113_76786571","","0","Comment","","false","135372113","",,,,,
"1452",":Comment","","","","","","","","https://stackoverflow.com/questions/76786571/neo4j-apoc-custom-function-hangs-when-nothing-is-found#comment135376364_76786571","","0","Comment","","false","135376364","",,,,,
"1453",":Comment","","","","","","","","https://stackoverflow.com/questions/76786571/neo4j-apoc-custom-function-hangs-when-nothing-is-found#comment135376820_76786571","","0","Comment","","false","135376820","",,,,,
"1454",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/python-3.x","python-3.x","","Tag","","false","","",,,,,
"1455",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/fastapi","fastapi","","Tag","","false","","",,,,,
"1456",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/strawberry-graphql","strawberry-graphql","","Tag","","false","","",,,,,
"1457",":Answer","","","You can do this:

    MATCH p=(m)-[*]-&gt;(m)
    WHERE ALL(n IN NODES(p) WHERE n.rel_type = &#39;type&#39;)
    RETURN m

#### Neo4j 5.9+

Starting with Neo4j 5.9, you can instead use a [quantified path pattern](https://neo4j.com/docs/cypher-manual/current/patterns/reference/#quantified-path-patterns), which may be more efficient:

    MATCH (m WHERE m.rel_type = &#39;type&#39;) (()--&gt;(n WHERE n.rel_type = &#39;type&#39;)){1,} (m)
    RETURN m

The above query specifies the node criteria (`rel_type = &#39;type&#39;`) twice: once for the starting node, and once for the endpoint of every `NEXT` relationship (within the quantified path pattern). This way, all the nodes in matching paths are tested once, and only once (except for `m`, which is tested twice).

Finally, to avoid testing `m` twice you can do this:

    MATCH (m WHERE m.rel_type = &#39;type&#39;)
    MATCH (m) (()--&gt;(n WHERE m = n OR n.rel_type = &#39;type&#39;)){1,} (m)
    RETURN m

The `MATCH` clause has to be split into 2 clauses here to avoid the error:

&gt; From within a quantified path pattern, one may only reference
&gt; variables, that are already bound in a previous `MATCH` clause.

#### Caveat

Using variable-length paths with unlimited upper bounds on the path length can cause you to run out of memory or take a very long time. If possible, you should put an upper bound on your queries.  For example, to place an upper bound of 8, you can use `[*..8]` (in the first query above) or `{1,8}` (in the second).","","","","false","https://stackoverflow.com/a/76784140","","0","Answer","How to write a neo4j cypher query to find closed loop of similar nodes","false","76784140","",,,,,
"1458",":Answer","","","You can capture paths as follows:

```
MATCH p=(:Type1 {id: &quot;some_id&quot;})-[*1..2]-()
RETURN p
```","","","","false","https://stackoverflow.com/a/76763864","","0","Answer","Get neighbors of a node that can be reached with n jumps (edges)","false","76763864","",,,,,
"1459",":Answer","","","[UPDATED]

To get info on all nodes and relationships up to a specified depth (say, 5), you can use a query like this:

    MATCH (:Type1 {id: &quot;some_id&quot;})-[rs*..5]-&gt;()
    UNWIND rs AS r
    WITH DISTINCT r
    RETURN STARTNODE(r) AS s, r, ENDNODE(r) AS n","","","","true","https://stackoverflow.com/a/76764673","","0","Answer","Get neighbors of a node that can be reached with n jumps (edges)","false","76764673","",,,,,
"1460",":Answer","","","In the beginning of your question, you seem to describe the following, where you only want to return paths that follow the green arrow:

![follow the green arrow 1][1]

Doing this requires comparing a relationship with a node from a previous iteration. You can do this with a [predicate function](https://neo4j.com/docs/cypher-manual/current/functions/predicate/):

```cypher
MATCH p = (:Station {name: &#39;A&#39;}) ((n)-[r:LINK]-(:Station))+
WHERE all(i IN range(0, size(r) - 2) WHERE n[i].name = r[i+1].name)
RETURN p
```

But reading your second query, maybe you meant something more like this:

![follow the green arrow 2][2]

In which case this query will work:

```cypher
MATCH (a {name: &#39;A&#39;})
MATCH p = (a)-[{name: a.name}]-&gt;+()
RETURN p
```

As the error message you got suggested, the first node variable `a` needs to be bound in a previous `MATCH` clause.

  [1]: https://i.stack.imgur.com/RQ3cV.png
  [2]: https://i.stack.imgur.com/yRypc.png","","","","false","https://stackoverflow.com/a/76869049","","0","Answer","Neo4j Traverse Graph of Indefinite Length With Selection Criteria","false","76869049","",,,,,
"1461",":Comment","","","","","","","","https://stackoverflow.com/questions/76724911/neo4j-traverse-graph-of-indefinite-length-with-selection-criteria#comment135278443_76724911","","1","Comment","","false","135278443","",,,,,
"1462",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/projection","projection","","Tag","","false","","",,,,,
"1463",":Answer","","","First of all, here are some docs on [native projection](https://neo4j.com/docs/graph-data-science/current/management-ops/projections/graph-project/) and [cypher projection](https://neo4j.com/docs/graph-data-science/current/management-ops/projections/graph-project-cypher-projection/). Those terms are only relevant when using the Neo4j [Graph Data Science Library](https://neo4j.com/docs/graph-data-science/current/).

&quot;Native projection&quot; directly uses low-level (&quot;native&quot;) server code to perform fast but inflexible DB operations. You specify desired node labels and relationship types, and &quot;native projection&quot; will put in the projection all nodes with any of the specified labels and all relationships of the specified types connected to those nodes. The code is tuned for this simple use case, and is therefore fast. But you have very little flexibility (for example, you cannot filter nodes by specific property values).

&quot;Cypher projection&quot;, on the other hand, allows you to use Cypher to fully customize how to get the projection, but at the cost of being potentially slower.

","","","","true","https://stackoverflow.com/a/76724396","","0","Answer","Projections in Neo4j","false","76724396","",,,,,
"1464",":Answer","","","Thanks to @dirk-mahler. I was able to scan multiple projects with the latest version command line jqassistant 1.12.2. I was using an older version of the jqassistant maven plugin 1.10.1 and it was failing with some weird errors.","","","","true","https://stackoverflow.com/a/76809108","","0","Answer","jQassistant assessment failing with multiple projects","false","76809108","",,,,,
"1465",":Comment","","","","","","","","https://stackoverflow.com/questions/76709965/jqassistant-assessment-failing-with-multiple-projects#comment135245975_76709965","","0","Comment","","false","135245975","",,,,,
"1466",":Comment","","","","","","","","https://stackoverflow.com/questions/76709965/jqassistant-assessment-failing-with-multiple-projects#comment135254822_76709965","","0","Comment","","false","135254822","",,,,,
"1467",":Comment","","","","","","","","https://stackoverflow.com/questions/76709965/jqassistant-assessment-failing-with-multiple-projects#comment135277468_76709965","","0","Comment","","false","135277468","",,,,,
"1468",":Comment","","","","","","","","https://stackoverflow.com/questions/76709965/jqassistant-assessment-failing-with-multiple-projects#comment135311385_76709965","","0","Comment","","false","135311385","",,,,,
"1469",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/transactions","transactions","","Tag","","false","","",,,,,
"1470",":Answer","","","This is the documentation from py2neo about error handling:

    https://py2neo.org/2021.1/errors.html 

 and from neo4j about the status code

     https://neo4j.com/docs/status-codes/current/ 

On you sample code, I would add a try;catch exceptions like below:

    from py2neo import Graph,Neo4jError,ClientError,TransientError,DatabaseError 
    
    def process_query(cursor):
        # Some logic would go here to create query 2 from the response of query 1.
        dummy_query = &quot;CREATE (:Person {name: &#39;John&#39;})&quot;
        return dummy_query
    
    
    # Create link.
    graph = Graph(uri=&quot;bolt://localhost:7687/&quot;, auth=(&quot;neo4j&quot;, &quot;admin&quot;))
    try:
        # Start transaction.
        tx = graph.begin()
    
        # Run first query.
        cursor1 = tx.run(&quot;MATCH (n) RETURN n&quot;)
    
        # Process data from first query.
        query2 = process_query(cursor1)
    
        # Run second query.
        cursor2 = tx.run(query2)
    
        # Commit the transaction.
        graph.commit(tx)
    
    # based on https://py2neo.org/2021.1/errors.html and https://neo4j.com/docs/status-codes/current/
    except Neo4jError as e:
        print(&quot;Neo4j error: &quot;, e)
    except ClientError as e:
        print(&quot;Client error: &quot;, e)
    except TransientError as e:
        print(&quot;Transient error: &quot;, e) 
    except DatabaseError as e:
        print(&quot;Database error: &quot;, e) 
    except Excepton as e:
        print(&quot;Generic error: &quot;, e)
    finally:
        print(&#39;Done&#39;)
    # Need logic here on success of final operation.


  [1]: https://neo4j.com/docs/status-codes/current/","","","","false","https://stackoverflow.com/a/76706219","","0","Answer","How to check if graph.commit(tx) has updated records in py2neo","false","76706219","",,,,,
"1471",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/odbc","odbc","","Tag","","false","","",,,,,
"1472",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/qliksense","qliksense","","Tag","","false","","",,,,,
"1473",":Answer","","","If you want to get back only nodes with no `r{prop:True}`, one option is:
```
OPTIONAL MATCH (ft:Foo)&lt;-[r{prop:True}]-(b:Bar)
WITH COLLECT(ID(ft)) as ft_ids
MATCH (f:Foo)
WHERE NOT ID(f) IN ft_ids
RETURN DISTINCT (f)
```
Which for sample data:
```
MERGE (a1:Foo {name: &#39;a1&#39;})  
MERGE (a2:Foo {name: &#39;a2&#39;}) 
MERGE (b1:Bar {name: &#39;b1&#39;})
MERGE (b2:Bar {name: &#39;b2&#39;}) 
MERGE (b3:Bar {name: &#39;b3&#39;}) 
MERGE (a3:Foo {name: &#39;a3&#39;})  
MERGE (a4:Foo {name: &#39;a3&#39;})  

MERGE (b1)-[:POINTS{prop:true}]-(a1)
MERGE (b2)-[:POINTS{prop:true}]-(a1)
MERGE (b3)-[:POINTS{prop:false}]-(a2)
MERGE (b1)-[:POINTS{prop:false}]-(a2)
MERGE (b2)-[:POINTS{prop:false}]-(a3)
MERGE (b1)-[:POINTS{prop:true}]-(a3)
```
returns: 
```
╒═════════════╕
│&quot;f&quot;          │
╞═════════════╡
│{&quot;name&quot;:&quot;a2&quot;}│
├─────────────┤
│{&quot;name&quot;:&quot;a4&quot;}│
└─────────────┘
```
It is not clear which relationships and `bars` you want to get back...","","","","false","https://stackoverflow.com/a/76681930","","1","Answer","Retrieve nodes where all relationships match a criteria in neo4j","false","76681930","",,,,,
"1474",":Answer","","","This query uses the `EXISTS()` function to avoid having to scan all relationships to every `Foo` node to find the ones of interest. It filters out a `Foo` node as soon as a `true` relationship is found.

    MATCH (foo:Foo)
    WHERE NOT EXISTS((foo)&lt;-[{prop: true}]-())
    MATCH (foo)&lt;-[r]-(bar)
    RETURN foo, bar, r

*This query also uses a directional r*elationship, to conform to the stated data model.","","","","true","https://stackoverflow.com/a/76682867","","2","Answer","Retrieve nodes where all relationships match a criteria in neo4j","false","76682867","",,,,,
"1475",":Answer","","","### Assumptions

 1. The date constraint is applied to all relationships in every path to the specified company (&quot;ABC&quot;).
 2. The end date property does not exist if shares are still currently held.
 3. If an entity sells only a portion of its shares from a given purchase, the end date property is added, the number of shares is reduced to the number sold, and the remaining shares are used to create a new relationship with the same start date. (This is not implemented in my answer, since the use case does not sell any shares).
 4. The date constraint is also enforced when calculating `totalShares` for a company.
 5. A company can hold some of its own shares.
 6. You pass the target date and company name in the [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) `$targetDate` and `$company`.

### Data model

I simplified the names in the data model for easier reading:

    (:Person|Company {name})-[:HOLDS {start, end, shares}]-&gt;(:Company {name})

### Cypher query
Here is one way to implement your use case:

    WITH DATE($targetDate) AS targetDate

    // Find all paths up to length 3 involving the specified company, on the target date.
    MATCH ()-[rs:HOLDS*..3]-&gt;(:Company {name: $company})
    WHERE ALL(r IN rs WHERE r.start &lt;= targetDate AND (r.end IS NULL OR targetDate &lt;= r.end))

    // Collect the distinct HOLD relationships in the paths for each company.
    WITH targetDate, ENDNODE(rs[0]) AS c, COLLECT(DISTINCT rs[0]) AS rels

    // Calculate total number of shares owned by each company in the paths, on the target date
    UNWIND rels AS rel
    WITH c, rels, SUM(rel.shares) AS totalShares

    // Return a company, a shareholder, and the percentage of that company owned by the shareholder on the target date.
    UNWIND rels AS rel
    WITH totalShares, c.name AS company, STARTNODE(rel).name AS holder, SUM(rel.shares) AS shares
    RETURN company, holder, 100.0*shares/totalShares AS pct

### Test data

    CREATE (p1:Person {name: &#39;John&#39;}),
           (p2:Person {name: &#39;Dave&#39;}),
           (p3:Person {name: &#39;Alice&#39;})
    
    CREATE (c1:Company {name: &#39;Comp1&#39;}),
           (c2:Company {name: &#39;Comp2&#39;}),
           (c3:Company {name: &#39;Comp3&#39;}),
           (c4:Company {name: &#39;ABC&#39;})
    
    CREATE (p1)-[:HOLDS {start: date(&#39;2018-01-01&#39;), end: date(&#39;2022-12-31&#39;), shares: 1000}]-&gt;(c1)
    CREATE (c2)-[:HOLDS {start: date(&#39;2020-01-01&#39;), end: date(&#39;2025-12-31&#39;), shares: 750}]-&gt;(c1)
    CREATE (p3)-[:HOLDS {start: date(&#39;2019-01-01&#39;), end: date(&#39;2022-12-31&#39;), shares: 800}]-&gt;(c3)
    CREATE (c1)-[:HOLDS {start: date(&#39;2016-07-01&#39;), end: date(&#39;2023-12-31&#39;), shares: 800}]-&gt;(c4)
    
    // Dave bought 500 shares of Comp1, and later bought 250 more.
    // Then he sold 125 shares from the second batch on &#39;2023-06-30&#39; and still has the remaining 125 shares.
    CREATE (p2)-[:HOLDS {start: date(&#39;2020-01-01&#39;), end: date(&#39;2023-12-31&#39;), shares: 500}]-&gt;(c1)
    CREATE (p2)-[:HOLDS {start: date(&#39;2023-01-01&#39;), end: date(&#39;2023-06-30&#39;), shares: 125}]-&gt;(c1)
    CREATE (p2)-[:HOLDS {start: date(&#39;2023-01-01&#39;), shares: 125}]-&gt;(c1)
    
    // ABC and Comp2 own shares of each other
    CREATE (c2)-[:HOLDS {start: date(&#39;2017-01-01&#39;), end: date(&#39;2023-12-31&#39;), shares: 700}]-&gt;(c4)
    CREATE (c4)-[:HOLDS {start: date(&#39;2016-07-01&#39;), shares: 500}]-&gt;(c2)
    
    // Comp1 holds (and continues to hold) some of its own shares
    CREATE (c1)-[:HOLDS {start: date(&#39;2021-01-01&#39;), shares: 500}]-&gt;(c1)

### Results

  Using `$targetDate` = &quot;2023-07-21&quot;, and `$company` = &quot;ABC&quot;:

    ╒═══════╤═══════╤══════════════════╕
    │company│holder │pct               │
    ╞═══════╪═══════╪══════════════════╡
    │&quot;ABC&quot;  │&quot;Comp2&quot;│46.666666666666664│
    ├───────┼───────┼──────────────────┤
    │&quot;ABC&quot;  │&quot;Comp1&quot;│53.333333333333336│
    ├───────┼───────┼──────────────────┤
    │&quot;Comp2&quot;│&quot;ABC&quot;  │100.0             │
    ├───────┼───────┼──────────────────┤
    │&quot;Comp1&quot;│&quot;Comp2&quot;│40.0              │
    ├───────┼───────┼──────────────────┤
    │&quot;Comp1&quot;│&quot;Dave&quot; │33.333333333333336│
    ├───────┼───────┼──────────────────┤
    │&quot;Comp1&quot;│&quot;Comp1&quot;│26.666666666666668│
    └───────┴───────┴──────────────────┘

### Matching graph

Here is a graph of the paths found by the above query&#39;s first `MATCH`/`WHERE` pair.

[![enter image description here][1]][1]

Here is the visualization query (a minor variant of the first 3 clauses of above query):

    WITH DATE($targetDate) AS targetDate
    MATCH (h)-[rs:HOLDS*..3]-&gt;(c:Company {name: $company})
    WHERE ALL(r IN rs WHERE r.start &lt;= targetDate AND (r.end IS NULL OR targetDate &lt;= r.end))
    RETURN *

  [1]: https://i.stack.imgur.com/MbmWe.png","","","","true","https://stackoverflow.com/a/76691823","","1","Answer","Extending layers of nodes in neo4j graph","false","76691823","",,,,,
"1476",":Comment","","","","","","","","https://stackoverflow.com/questions/76675398/extending-layers-of-nodes-in-neo4j-graph#comment135207901_76675398","","0","Comment","","false","135207901","",,,,,
"1477",":Comment","","","","","","","","https://stackoverflow.com/questions/76675398/extending-layers-of-nodes-in-neo4j-graph#comment135209725_76675398","","0","Comment","","false","135209725","",,,,,
"1478",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/opencypher","opencypher","","Tag","","false","","",,,,,
"1479",":Answer","","","Note: I have edited the question to better reflect the essence of it. This answer summarizes the learnings from https://github.com/neo4j/neo4j-ogm/issues/951, which is mainly contributed by https://stackoverflow.com/users/2650436/meistermeier

What&#39;s causing the issue is:

    @Relationship(type = &quot;HAS_B&quot;)
    val b: MutableSet&lt;B&gt; = mutableSetOf&lt;B&gt;()

In order for OGM to go from node entity `A` to relationship entity `HasB`, the `@Relationship` should annotate a variable that directly refers to the relationship entity itself, instead of node entity B (i.e. the node entity it connects A to).

Solution:

    @NodeEntity
    data class A(
        @Id val id: String? = null,
        @Relationship(type = &quot;HAS_B&quot;)
        var b: MutableSet&lt;HasB&gt; = mutableSetOf()
    )
    
    @RelationshipEntity(type = &quot;HAS_B&quot;)
    class HasB @JvmOverloads constructor(
        @Id @GeneratedValue val id: Long? = null,
        @StartNode val start: A = A(),
        @EndNode val end: B = B()
    ) {
        override fun toString(): String {
            return &quot;HasB(id=$id, end=$end)&quot;
        }
    }
    
    @NodeEntity
    data class B(
        @Id val id: String? = null,
        @Relationship(type = &quot;HAS_C&quot;)
        val c: MutableSet&lt;C&gt; = mutableSetOf()
    )
    
    @NodeEntity
    data class C(
        @Id val id: String? = null
    )","","","","true","https://stackoverflow.com/a/76682768","","0","Answer","Neo4j OGM: How to correctly use @RelationshipEntity to load connected nodes","false","76682768","",,,,,
"1480",":Comment","","","","","","","","https://stackoverflow.com/questions/76668155/neo4j-ogm-how-to-correctly-use-relationshipentity-to-load-connected-nodes#comment135181604_76668155","","0","Comment","","false","135181604","",,,,,
"1481",":Comment","","","","","","","","https://stackoverflow.com/questions/76668155/neo4j-ogm-how-to-correctly-use-relationshipentity-to-load-connected-nodes#comment135199711_76668155","","0","Comment","","false","135199711","",,,,,
"1482",":Answer","","","This is because Spring Data Neo4j needs the return type of a repository method to match whatever object we are extending for the repository itself. For instance, if the ObjectRepo is extending the Neo4jRepository&lt;Object, Long&gt;, then all methods in the repository must return a type of Object. Otherwise, SDN doesn&#39;t know how to map the result. To correct this, you can change the repository to the ExtendedObject and return that subentity.

I&#39;ve created a sample repository showing this with all the instructions to reproduce. https://github.com/JMHReif/extendedobject-not-known-entity-exception 

Also, as a side note, you can use the @ReadOnlyProperty annotation in the ExtendedObject class to ensure that you only read the property and don&#39;t write to it. An example of using that is also included in the Github project above. :)","","","","false","https://stackoverflow.com/a/76740709","","0","Answer","&quot;neo4j.com.example.entity.ExtendedObject is not a known entity&quot; when mapping data to ExtendedObject","false","76740709","",,,,,
"1483",":Comment","","","","","","","","https://stackoverflow.com/questions/76659774/neo4j-com-example-entity-extendedobject-is-not-a-known-entity-when-mapping-dat#comment135162873_76659774","","0","Comment","","false","135162873","",,,,,
"1484",":Comment","","","","","","","","https://stackoverflow.com/questions/76659774/neo4j-com-example-entity-extendedobject-is-not-a-known-entity-when-mapping-dat#comment135169786_76659774","","0","Comment","","false","135169786","",,,,,
"1485",":Answer","","","The [graph.names()](https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-names) function returns the aliases in **lowercase**, which is not documented (but should be).

So, change this line:

    UNWIND [g IN graph.names() WHERE g STARTS WITH &#39;socialDb.personP2&#39;] AS g

to this:

    UNWIND [g IN graph.names() WHERE g STARTS WITH &#39;socialdb.personp2&#39;] AS g
","","","","false","https://stackoverflow.com/a/76656720","","0","Answer","create two alias of same label for different DB - composite databases","false","76656720","",,,,,
"1486",":Answer","","","You just need to concoct a Cypher query that checks both the srcNodeId and the destNodeId for each edge in your list , and see if these fellas match up with any existing node in the database.

Here&#39;s a query that can get this job done:

    MATCH (n)
    WHERE NOT (ID(n) IN $srcNodeIds) OR NOT (ID(n) IN $destNodeIds)
    RETURN n

In this query, $srcNodeIds and $destNodeIds are parameters you&#39;ll pass into the query that represent your lists of source node IDs and destination node IDs, respectively. The query is checking if any nodes exist with IDs that are NOT in these lists. Any nodes that are returned from this query would be the unresolved ones , i.e., they exist in your Edge objects but not in the actual database.

Just remember to pass in the srcNodeIds and destNodeIds as parameters when you&#39;re running this query. For instance , in the Neo4j Java driver, it might look something like this:

    List&lt;Long&gt; srcNodeIds = edges.stream().map(edge -&gt; edge.srcNodeId).collect(Collectors.toList());
    List&lt;Long&gt; destNodeIds = edges.stream().map(edge -&gt; edge.destNodeId).collect(Collectors.toList());
    
    Session session = driver.session();
    
    Map&lt;String , Object&gt; params = new HashMap&lt;&gt;();
    params.put(&quot;srcNodeIds&quot; , srcNodeIds);
    params.put(&quot;destNodeIds&quot; , destNodeIds);

StatementResult result = session.run(query , params);
Now , keep in mind that this query might take a while if you&#39;ve got a massive graph, because it&#39;s essentially scanning through the whole kit and caboodle.
","","","","false","https://stackoverflow.com/a/76642262","","1","Answer","neo4j: cypher to identify unresolved edges","false","76642262","",,,,,
"1487",":User","","","","","nail steiger","","","","","","User","","false","22159264","",,,,,
"1488",":Answer","","","Assuming `$edges` is a [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) with a list of edges:

    UNWIND $edges AS e
    OPTIONAL MATCH (src) WHERE ID(src) = e.srcNodeId
    OPTIONAL MATCH (dest) WHERE ID(dest) = e.destNodeId
    RETURN
      e.srcNodeId AS srcNodeId, src IS NOT NULL AS srcExists,
      e.destNodeId AS destNodeId, dest IS NOT NULL AS destExists","","","","false","https://stackoverflow.com/a/76650077","","1","Answer","neo4j: cypher to identify unresolved edges","false","76650077","",,,,,
"1489",":Answer","","","You can do something like this:

    call apoc.load.json(&quot;file:/var/lib/neo4j/import/so.json&quot;) YIELD value
    with value.src as tsrc
    unwind(split(tsrc,&#39;,&#39;)) as tempsrc
    create (s:Source {src:tempsrc})","","","","false","https://stackoverflow.com/a/76637394","","0","Answer","How to split up elements in an array (JSON) and create nodes in neo4j","false","76637394","",,,,,
"1490",":Answer","","","This is using foreach command which is similar to unwind.

    call apoc.load.json(&quot;example.json&quot;) YIELD value
    with split(value.src,&#39;,&#39;) as srcs
    foreach (src in srcs | create (:src {src: src}))

Reference:
https://neo4j.com/docs/cypher-manual/current/clauses/foreach/","","","","false","https://stackoverflow.com/a/76637936","","0","Answer","How to split up elements in an array (JSON) and create nodes in neo4j","false","76637936","",,,,,
"1491",":Answer","","","You can create a `Src` node for every `src` value this way (note that the SPLIT delimiter `&#39;, &#39;` has a blank as the second character): 

    CALL apoc.load.json(&quot;file:/Users/user/.Neo4jDesktop/relate-data/dbmss/dbms-969/import/example.json&quot;) YIELD value
    UNWIND SPLIT(value.src, &#39;, &#39;) AS src
    CREATE (:Src {src: src})

It is not clear what you meant by `i want the other values to be the nodes parameters`.","","","","false","https://stackoverflow.com/a/76638823","","0","Answer","How to split up elements in an array (JSON) and create nodes in neo4j","false","76638823","",,,,,
"1492",":Answer","","","The following query returns each node and its list of filtered strings. Nodes without matching strings are ignored. `$filter` is a [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) with the desired filter (e.g., &quot;abc&quot;).

    MATCH (n:Node)
    UNWIND n.string AS s
    WITH n, s
    WHERE s CONTAINS $filter
    RETURN n, COLLECT(s) AS filtered_strings

NOTE: If `n.string` is actually a string that looks like a list, replace `n.string` with `SPLIT(n.string, &#39;,&#39;)`.","","","","true","https://stackoverflow.com/a/76631134","","0","Answer","Trying to filter an array of strings to return a single field which is a subset of the array with strings that contain a variable","false","76631134","",,,,,
"1493",":Comment","","","","","","","","https://stackoverflow.com/questions/76626552/trying-to-filter-an-array-of-strings-to-return-a-single-field-which-is-a-subset#comment135106443_76626552","","0","Comment","","false","135106443","",,,,,
"1494",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/amazon-neptune","amazon-neptune","","Tag","","false","","",,,,,
"1495",":Comment","","","","","","","","https://stackoverflow.com/questions/76624234/query-timeout-in-neptune-opencypher-different-results-for-similar-queries#comment135096346_76624234","","0","Comment","","false","135096346","",,,,,
"1496",":User","","","","","Kelvin Lawrence","","","","","","User","","false","5442034","",,,,,
"1497",":Comment","","","","","","","","https://stackoverflow.com/questions/76624234/query-timeout-in-neptune-opencypher-different-results-for-similar-queries#comment135096700_76624234","","0","Comment","","false","135096700","",,,,,
"1498",":Comment","","","","","","","","https://stackoverflow.com/questions/76624234/query-timeout-in-neptune-opencypher-different-results-for-similar-queries#comment135096739_76624234","","0","Comment","","false","135096739","",,,,,
"1499",":Comment","","","","","","","","https://stackoverflow.com/questions/76624234/query-timeout-in-neptune-opencypher-different-results-for-similar-queries#comment135108325_76624234","","0","Comment","","false","135108325","",,,,,
"1500",":Answer","","","One option is to use APOC free plugin, which is much faster. For example [`apoc.path.subgraphNodes`](https://neo4j.com/labs/apoc/4.1/graph-querying/expand-subgraph-nodes/):
```
MATCH (p:Pathway)
CALL apoc.path.subgraphNodes(p, {
	labelFilter: &quot;&gt;Disease&quot;,
    minLevel: 1,
    maxLevel: 6
})
YIELD node
RETURN DISTINCT node.name;
```
To find all `Disease` which are connected to a `Pathway` node in up to 6 moves. Note that this query will consider any `p:Pathway` and not a specific node `p`. You can change the `MATCH` to find a specific origin. You can also define specific labels, relationships and directions to make it more efficient. ","","","","false","https://stackoverflow.com/a/76620071","","0","Answer","Is there an efficient way of traversing a graph to find connections between two nodes through all combinations of relatiosnhips and nodes?","false","76620071","",,,,,
"1501",":Answer","","","To avoid performance issues, you could have specified the _directionality_ of the relationship:

    MATCH (p:Pathway)-[*]-&gt;(d:Disease)
    RETURN DISTINCT d.Name
    LIMIT 3

Your data model has only a single relationship type (`IS_INVOLVED`) between the `Pathway` and `Disease` nodes, and that relationship is directed from `Pathway` to `Disease`. If your `MATCH` clause does not specify the directionality, then your unlimited variable-length query would follow other relationship types from `Pathway` (in the reverse direction) and keep going (in any direction) -- so you could be searching a large portion of the entire graph over and over again in the worst case.

And, since your data model has no outgoing relationships from the `Disease` node, it really makes no sense for the directional query to also be a variable-length query as well -- since all matching paths would be of length 1.

So, you might as well just stay with your first query.","","","","false","https://stackoverflow.com/a/76622626","","0","Answer","Is there an efficient way of traversing a graph to find connections between two nodes through all combinations of relatiosnhips and nodes?","false","76622626","",,,,,
"1502",":Answer","","","in these cases I often do

    MATCH (s:Something)
    WITH s,
         [(s)-[:HAS_TAG]-&gt;(t:Tag) | t] AS ts,
         [(s)-[:HAS_ITEM]-&gt;(i:Item) | i] AS is,
         [(s)-[:HAS_TAG]-&gt;(w:Whatever) | w] AS ws

which returns arrays, instead of null in case the OPTIONAL MATCH does not return anything. and often it&#39;s faster too.","","","","true","https://stackoverflow.com/a/76620613","","1","Answer","How do I do multiple OPTIONAL MATCH in parallel in Cypher?","false","76620613","",,,,,
"1503",":Answer","","","You can use a single `OPTIONAL MATCH` and use aggregation to produce a node list for each relationship type:

    MATCH (s:Something)
    OPTIONAL MATCH (n)&lt;-[r:HAS_TAG|HAS_ITEM|HAS_WHATEVER]-(s)
    RETURN s, TYPE(r) AS t, COLLECT(n) AS nodes","","","","false","https://stackoverflow.com/a/76622736","","0","Answer","How do I do multiple OPTIONAL MATCH in parallel in Cypher?","false","76622736","",,,,,
"1504",":Answer","","","The outside query also needs the RETURN clause.


    MATCH (s:Something)
    CALL {
      WITH s
      MATCH (s)-[:SOMETHING]-&gt;(o:Other)
      RETURN o
    }
    RETURN o   // add this line
    SKIP 1000
    LIMIT 50","","","","false","https://stackoverflow.com/a/76622759","","0","Answer","How to limit then do subquery?","false","76622759","",,,,,
"1505",":Answer","","","This will only use the 50 `Something` nodes after the first 1000, and only execute the `CALL` subquery 50 times:

    MATCH (s:Something)
    WITH s
    SKIP 1000
    LIMIT 50
    CALL {
      WITH s
      MATCH (s)-[:SOMETHING]-&gt;(o:Other)
      RETURN o
    }
    RETURN s, o
","","","","false","https://stackoverflow.com/a/76622804","","0","Answer","How to limit then do subquery?","false","76622804","",,,,,
"1506",":Answer","","","If you are working with Neo4j 5, this should work.

    MATCH path = (p:P {name:&quot;P1&quot;})-[ch:child*]-&gt;(p2)
    OPTIONAL MATCH (p2)&lt;-[k:knows]-(d)
    WHERE k.effectiveDate &lt; date(&quot;2023-05-01&quot;) // put your  knows relationship filter here
    OPTIONAL MATCH (d)-[r:follows|has|likes]-(n) // include other relationship types as needed
    WHERE r.strength &gt; 0.5 // put your other relationship filter here
    RETURN path

Your queries would be simpler if the relationships starting at P1 were all oriented in the same direction.","","","","false","https://stackoverflow.com/a/76613353","","0","Answer","Extract a subgraph starting from one node","false","76613353","",,,,,
"1507",":User","","","","","Nathan Smith","","","","","","User","","false","12205676","",,,,,
"1508",":Answer","","","To take advantage of the power of a graph database, your graph should have relationships. Create them with this query.

    MATCH (n)
    UNWIND n.child AS child
    MATCH (ch {name:child})
    CREATE (n)-[:HAS_CHILD]-&gt;(ch)

Then you can return the full hierarchy with this query.

    MATCH path = (n {name:&quot;P1&quot;})-[:HAS_CHILD*]-&gt;(ch)
    RETURN [p in nodes(path) | p.name] AS pathToChild

","","","","true","https://stackoverflow.com/a/76604792","","0","Answer","Retrieve hierarchy based on node property with Cypher","false","76604792","",,,,,
"1509",":Answer","","","You might consider using ORDPATH for sorting in hierarchical order. There is a Neo4j user defined function for this described at 
[https://www.wai.md/post/ordpath-computing-genealogy-descendancy-trees][1]

During graph traversals you can collect numeric values and then call the function to get the concatenated bitstring which sorts hierarchically. 


  [1]: https://www.wai.md/post/ordpath-computing-genealogy-descendancy-trees","","","","false","https://stackoverflow.com/a/76609756","","0","Answer","Retrieve hierarchy based on node property with Cypher","false","76609756","",,,,,
"1510",":Comment","","","","","","","","https://stackoverflow.com/questions/76603290/retrieve-hierarchy-based-on-node-property-with-cypher#comment135069414_76603290","","0","Comment","","false","135069414","",,,,,
"1511",":Answer","","","    MATCH (c:Company {name:&quot;ABC&quot;})&lt;-[r:Shareholder]-(s)
    WHERE r.shareholding_start_date &lt;= Date(&quot;2022-03-15&quot;) 
       AND r.shareholding_end_date &gt;= DATE(&quot;2022-03-15&quot;)
    WITH c, 
    collect(s) as shareholders, 
    collect(r) as rels, 
    sum(r.number_of_shares) AS totalShares
    UNWIND range(0, size(rels) - 1) AS i
    RETURN shareholders[i].name AS shareholder, 
    100.0 * rels[i].numberOfShares/totalShares as percentTotalShares

For more examples of percent of total in Neo4j, see this blog post. https://medium.com/neo4j/kickstart-your-transition-from-sql-analytic-and-window-functions-to-neo4j-987d67f7fdb4

To show shareholders of shareholders to an arbitrary distance from your target company as requested in the comment, you might use this approach.

```
MATCH p=(c:Company {name:&quot;ABC&quot;})&lt;-[r:Shareholder*1..3]-(holder)
WHERE all(holding IN relationships(p) WHERE holding.shareholding_start_date &lt;= Date(&#39;2022-03-15&#39;) &lt;= holding.shareholding_end_date) 
WITH 
   length(p) - 1 AS distanceToTargetCompany, 
   nodes(p)[-2].name AS companyName,
   holder, 
   relationships(p)[-1].number_of_shares AS number_of_shares
WITH 
   distanceToTargetCompany,
   companyName,
   collect(DISTINCT {shareHolder: holder.name, numberOfShares: number_of_shares}) as shareHolders
WITH 
   distanceToTargetCompany, 
   companyName, 
   shareHolders,
   reduce(acc=0, company in shareHolders | acc + company[&#39;numberOfShares&#39;]) AS totalShares
RETURN 
   distanceToTargetCompany, 
   companyName, 
   reduce(acc=[], company in shareHolders | acc + company{.*, percentTotal:100.0 * company[&#39;numberOfShares&#39;]/totalShares}) AS shareHolders
ORDER BY distanceToTargetCompany, companyName
```","","","","true","https://stackoverflow.com/a/76601616","","2","Answer","Getting weights as percentages from edges","false","76601616","",,,,,
"1512",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/snomed-ct","snomed-ct","","Tag","","false","","",,,,,
"1513",":Comment","","","","","","","","https://stackoverflow.com/questions/76599592/snomed-ct-cypher-query#comment135064149_76599592","","0","Comment","","false","135064149","",,,,,
"1514",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/reactjs","reactjs","","Tag","","false","","",,,,,
"1515",":Answer","","","At least for OpenCypher the syntax is specified and published: https://opencypher.org/resources/
You could use these specifications and general syntax checker tools and verify it on the frontend yourself.
Though you should know that Neo4j&#39;s current Cypher is an extension of OpenCypher, and other implementations of OpenCypher like Memgraph&#39;s aren&#39;t 100% compatible. So while this check allows general compliance with OpenCypher, it can&#39;t handle non-standardized features and extensions.","","","","false","https://stackoverflow.com/a/76586653","","2","Answer","Validate cypher query in Frontend","false","76586653","",,,,,
"1516",":Comment","","","","","","","","https://stackoverflow.com/questions/76586497/validate-cypher-query-in-frontend#comment135032472_76586497","","3","Comment","","false","135032472","",,,,,
"1517",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/javascript","javascript","","Tag","","false","","",,,,,
"1518",":Answer","","","For the query to be &quot;correct&quot; you need to escape variables and labels that contain special characters:

    MATCH (`node::test`:`Node::test`) RETURN `node::test`

Documentation: https://neo4j.com/developer/cypher/style-guide/#_backticks

I suggest you create a new issue in the popoto repo since this is most likely an easy fix there.","","","","false","https://stackoverflow.com/a/76580457","","0","Answer","popoto.js - customize node label","false","76580457","",,,,,
"1519",":Answer","","","[Here is a link to the popoto function](https://github.com/Nhogs/popoto/blob/f20f0e1555ce9f9ac48acc5e9f64bb1b54a6601c/src/graph/node/node.js#L70) that generates a node identifier based on the node label, which I copy here:

    /**
     * Create a normalized identifier from a node label.
     * Multiple calls with the same node label will generate different unique identifier.
     *
     * @param nodeLabel
     * @returns {string}
     */
    node.generateInternalLabel = function (nodeLabel) {
        var label = nodeLabel ? nodeLabel.toLowerCase().replace(/ /g, &#39;&#39;) : &quot;n&quot;;
    
        if (label in node.internalLabels) {
            node.internalLabels[label] = node.internalLabels[label] + 1;
        } else {
            node.internalLabels[label] = 0;
            return label;
        }
    
        return label + node.internalLabels[label];
    };


You can change the function to not use the node label (in your own fork of the linked repo).

For example, to generate the identifiers `n`, `n1`, `n2`, etc., you can replace this line:

    var label = nodeLabel ? nodeLabel.toLowerCase().replace(/ /g, &#39;&#39;) : &quot;n&quot;;

with this:

    var label = &quot;n&quot;;
","","","","false","https://stackoverflow.com/a/76585307","","0","Answer","popoto.js - customize node label","false","76585307","",,,,,
"1520",":Answer","","","You would need to collect and count s at the same time, then UNWIND the collection back into individual rows if you want to continue with each individual s node.

```
MATCH (c:Criterion {id: 24}) 
OPTIONAL MATCH (c)&lt;-[:HAS_VOTE_ON]-(d:Decision)-[:HAS_VOTE_ON]-&gt;(s:Skill) 
WHERE s.id &lt;&gt; c.id 
WITH c, collect(DISTINCT s) as skills, count(DISTINCT s) as count
UNWIND skills as s
...
```","","","","false","https://stackoverflow.com/a/76577013","","1","Answer","Neo4j Cypher Group By","false","76577013","",,,,,
"1521",":Answer","","","If you just want to return each distinct `s` and its count:

    MATCH (c:Criterion {id: 24})&lt;-[:HAS_VOTE_ON]-(:Decision)-[:HAS_VOTE_ON]-&gt;(s:Skill) 
    WHERE s.id &lt;&gt; c.id
    RETURN s, COUNT(*) AS cnt","","","","false","https://stackoverflow.com/a/76577050","","1","Answer","Neo4j Cypher Group By","false","76577050","",,,,,
"1522",":Answer","","","Below query works for me:

    MATCH (node1:Student {id: &#39;id1&#39;}),(node2:Student {id: &#39;ID1&#39;}) 
    CREATE (temp:Student) 
    SET temp  = properties(node1),
        node1.name = node2.name, node1.city = node2.city,
        node2.name = temp.name, node2.city = temp.city
    DELETE temp
    RETURN node1, node2 

Ref: https://neo4j.com/docs/cypher-manual/current/clauses/set/#set-copying-properties-between-nodes-and-relationships

Without specifying the node label Student, it is not working for me.  So I need to put the label node1:Student instead of just node1.","","","","false","https://stackoverflow.com/a/76567035","","1","Answer","Swapping specific properties of two nodes including relationships in Neo4j","false","76567035","",,,,,
"1523",":Answer","","","This is the way I would write the query. You had the right structure, but there were a couple of syntax issues. The biggest one was that you need to use a SET clause when you create the Temp node. To answer your question whether we can avoid creating a temp node, I don&#39;t believe that&#39;s possible because you typically overwrite existing properties. And, if you don&#39;t overwrite them, you would have to retain/track the old properties to move over.

```
MATCH
  (node1 {id: &#39;id1&#39;}),
  (node2 {id: &#39;ID1&#39;})
CREATE (Temp:Student {id: node1.id})
 SET Temp = properties(node1) 
WITH node1, node2, Temp
 SET node1 += {name: node2.name, city: node2.city},
     node2 += {name: Temp.name, city: Temp.city}
DELETE Temp 
RETURN node1, node2
```
Links for syntax I used are here:
* Copy properties: https://neo4j.com/docs/cypher-manual/current/clauses/set/#set-copying-properties-between-nodes-and-relationships
* Mutate properties: https://neo4j.com/docs/cypher-manual/current/clauses/set/#set-setting-properties-using-map","","","","false","https://stackoverflow.com/a/76567044","","1","Answer","Swapping specific properties of two nodes including relationships in Neo4j","false","76567044","",,,,,
"1524",":Answer","","","You should use the [WITH](https://neo4j.com/docs/cypher-manual/current/clauses/with/) clause to store temporary values. Assuming both nodes have the `Student` label, this query should work:

    MATCH
      (n1:Student {id: &#39;id1&#39;}),
      (n2:Student {id: &#39;ID1&#39;})
    WITH n1, n2, n1.name AS name1, n1.city AS city1
    SET
      n1.name = n2.name, n1.city = n2.city,
      n2.name = name1, n2.city = city1
    RETURN n1, n2","","","","true","https://stackoverflow.com/a/76567283","","1","Answer","Swapping specific properties of two nodes including relationships in Neo4j","false","76567283","",,,,,
"1525",":Answer","","","Your query is correct and this is an artefact of the visualisation. Go to the settings and un-check the option to connect result nodes (see https://neo4j.com/docs/browser-manual/current/operations/browser-settings/#adjust-in-browser)","","","","true","https://stackoverflow.com/a/76564394","","1","Answer","Neo4j/Cypher: Filter edges between two nodes","false","76564394","",,,,,
"1526",":Comment","","","","","","","","https://stackoverflow.com/questions/76563944/neo4j-cypher-filter-edges-between-two-nodes#comment134995330_76563944","","0","Comment","","false","134995330","",,,,,
"1527",":Answer","","","You can use [apoc.create.vRelationship](https://neo4j.com/docs/apoc/current/overview/apoc.create/apoc.create.vRelationship/) to return virtual `ASSEMBLED_BY` relationships (with reversed directionality) for `IBM` users. This does not change any relationships in the DB.

    MATCH (u:USER {id: 101})
    RETURN CASE u.preference 
      WHEN &#39;HP&#39;     THEN [(n:computer)-[r: MANUFACTURED_BY]-&gt;(c:HP) | r]
      WHEN &#39;IBM&#39;    THEN [(n:computer)-[r:ASSEMBLED_BY]-&gt;(c:IBM) | apoc.create.vRelationship(c, &#39;ASSEMBLED_BY&#39;, PROPERTIES(r), n)] 
      WHEN &#39;DELL&#39;   THEN [(n:computer)-[r:ASSEMBLED_BY]-&gt;(c:DELL) | r] 
      WHEN &#39;HP_IBM&#39; THEN [(n:computer)-[r:ASSEMBLED_BY]-&gt;(c:HP_IBM) | r] END
    AS result;

Note that the above query uses the correctly-spelled `ASSEMBLED_BY` relationship type.","","","","true","https://stackoverflow.com/a/76560854","","2","Answer","neo4j cypher: return invert relationship","false","76560854","",,,,,
"1528",":Comment","","","","","","","","https://stackoverflow.com/questions/76560493/neo4j-cypher-return-invert-relationship#comment134987205_76560493","","0","Comment","","false","134987205","",,,,,
"1529",":Comment","","","","","","","","https://stackoverflow.com/questions/76560493/neo4j-cypher-return-invert-relationship#comment134987256_76560493","","0","Comment","","false","134987256","",,,,,
"1530",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/cluster-computing","cluster-computing","","Tag","","false","","",,,,,
"1531",":Answer","","","If I follow the steps correctly I think you are loading the database on a single VM of the cluster, is that correct?

If that is the case then the cause could be that when you run the CREATE command a different VM becomes leader for the database, doesn&#39;t find any data local to it and creates an empty database which is then synched to the other members (effectively overwriting the actual data you loaded).

In the 4.x series you would need to [seed the database][1] on all VMs and then run the create database command.

In version 5.x this has been made easier with the [Designated Seeder][2] option allowing you to import on a single member of the cluster and specify that VM in the CREATE database command. 


  [1]: https://neo4j.com/docs/operations-manual/4.4/clustering/seed/
  [2]: https://neo4j.com/docs/operations-manual/current/clustering/databases/#cluster-designated-seeder","","","","false","https://stackoverflow.com/a/76601839","","0","Answer","Data not available after neo4j-admin import (Causal Cluster / Neo4J Enterprise Edition)","false","76601839","",,,,,
"1532",":User","","","","","Stuart Laurie","","","","","","User","","false","21904355","",,,,,
"1533",":Answer","","","Sorry this is old but:

```
MATCH p=(P1)-[:HAS_ZIP]-&gt;(:ZIP)&lt;-[:HAS_ZIP]-(P2)
WHERE NOT P1=P2 AND (P1.is_verified=1 OR P2.is_verified=1)

MERGE (P1)-[rel:SHARES_ZIP]-(P2)
SET rel.verififed=1 

RETURN p
```","","","","false","https://stackoverflow.com/a/77873842","","0","Answer","Adding relationship property on projection based on node property during collapse path","false","77873842","",,,,,
"1534",":Comment","","","","","","","","https://stackoverflow.com/questions/76542023/adding-relationship-property-on-projection-based-on-node-property-during-collaps#comment134960727_76542023","","0","Comment","","false","134960727","",,,,,
"1535",":Comment","","","","","","","","https://stackoverflow.com/questions/76542023/adding-relationship-property-on-projection-based-on-node-property-during-collaps#comment134984446_76542023","","0","Comment","","false","134984446","",,,,,
"1536",":Comment","","","","","","","","https://stackoverflow.com/questions/76542023/adding-relationship-property-on-projection-based-on-node-property-during-collaps#comment134988960_76542023","","1","Comment","","false","134988960","",,,,,
"1537",":Comment","","","","","","","","https://stackoverflow.com/questions/76542023/adding-relationship-property-on-projection-based-on-node-property-during-collaps#comment135001045_76542023","","0","Comment","","false","135001045","",,,,,
"1538",":Comment","","","","","","","","https://stackoverflow.com/questions/76542023/adding-relationship-property-on-projection-based-on-node-property-during-collaps#comment135006463_76542023","","0","Comment","","false","135006463","",,,,,
"1539",":Answer","","","Unfortunately, you cannot combine set n.\&lt;prop\&gt; and set:\&lt;label\&gt; into one case-when statement.

    1 CALL apoc.periodic.iterate(
    2    &quot;MATCH  (res:Book) where res.isbn =~ &#39;(?)[A-Z].*&#39; RETURN res&quot;,  
    3    &quot;MATCH (res2:Book) WHERE toLower(res2.isbn) = toLower(res.isbn) 
    4     WITH res, count(res2) as rescount
    5     SET res.isbn = CASE WHEN rescount = 1 THEN toLower(res.isbn) END 
    6     WITH res WHERE rescount = 2
    7     SET res:DELETED&quot;, {})

    line 1 is iterate statement
    line 2 is passing all books that starts with upper CASE letter (e.g. Aaa)
    line 3 is find other books with same isbn with line 2 but lower case (I fixed your typo on the sample query). For ex:  Aaa and aaa
    line 4 count those books with same isbn in line 2 
    line 5 set the isbn to lower case found in line 2 when no other duplicate book is found (rescount = 1)
    line 6 get only those books in line 2 that has duplicated isbn (res2) in line 3
    line 7 update the label of this book filtered in line 6 to DELETED



sample result:

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/pEUOQ.png


The two isolated nodes on the right are updated to :DELETED

Sample result for iterate function:

    ╒═════════╤═══════╤═══════════╤═════════════════════╤══════════════════╤═══════════════╤
    │&quot;batches&quot;│&quot;total&quot;│&quot;timeTaken&quot;│&quot;committedOperations&quot;│&quot;failedOperations&quot;│&quot;failedBatches&quot;│
    ╞═════════╪═══════╪═══════════╪═════════════════════╪══════════════════╪═══════════════╪
    │1        │2      │0          │2                    │0                 │0              │
    │         │       │           │                     │                  │               │

","","","","false","https://stackoverflow.com/a/76541726","","1","Answer","Adding case in Match statement of iterate function in neo4j","false","76541726","",,,,,
"1540",":Answer","","","The Cypher [CASE](https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#query-syntax-case) expression cannot write to the DB.

The following query uses the [apoc.do.when](https://neo4j.com/docs/apoc/current/overview/apoc.do/apoc.do.when/) procedure instead, which allows you to conditionally execute arbitrary Cypher code if you have up to 2 possible choices (or you can use [apoc.do.case](https://neo4j.com/docs/apoc/current/overview/apoc.do/apoc.do.case/) for any number of choices). The query also uses [OPTIONAL MATCH](https://neo4j.com/docs/cypher-manual/current/clauses/optional-match/) instead of `MATCH` for `res2` so that the remainder of the query will be executed even when `res2` does not exist (i.e., its value is `NULL`). 

    MATCH (res:Book) WHERE res.isbn =~ &#39;.*[A-Z].*&#39;
    OPTIONAL MATCH (res2:Book) WHERE res2 &lt;&gt; res AND res2.isbn = TOLOWER(res.isbn)
    CALL apoc.do.when(res2 IS NULL,
      &quot;SET res.isbn=TOLOWER(res.isbn)&quot;,
      &quot;SET res:Deleted&quot;,
     {res: res}) YIELD value
    RETURN res
","","","","false","https://stackoverflow.com/a/76542374","","1","Answer","Adding case in Match statement of iterate function in neo4j","false","76542374","",,,,,
"1541",":Answer","","","The exported file from neo4j browser is using a different encoding. Please use &quot;utf-8-sig&quot; as encoding.  

    import json
    file_path = &#39;test_records.json&#39; 
    with open(file_path, &quot;r&quot;, encoding=&#39;utf-8-sig&#39;) as file:
        data = json.load(file)
    
    print(data) 

Sample output:

    [{&#39;n&#39;: {&#39;identity&#39;: 45, &#39;labels&#39;: [&#39;Person&#39;], &#39;properties&#39;: {&#39;name&#39;: &#39;Bob&#39;}}}, {&#39;n&#39;: {&#39;identity&#39;: 49, &#39;labels&#39;: [&#39;Person&#39;], &#39;properties&#39;: {&#39;name&#39;: &#39;Alice&#39;}}}, {&#39;n&#39;: {&#39;identity&#39;: 52, &#39;labels&#39;: [&#39;Person&#39;], &#39;properties&#39;: {&#39;name&#39;: &#39;Bob&#39;}}}, {&#39;n&#39;: {&#39;identity&#39;: 53, &#39;labels&#39;: [&#39;Person&#39;], &#39;properties&#39;: {&#39;name&#39;: &#39;Alice&#39;}}}]

Below are my notebook and python versions:

    The version of the notebook server is: 6.5.4
    The server is running on this version of Python:
    Python 3.9.6 (default, Oct 18 2022, 12:41:40) 
    [Clang 14.0.0 (clang-1400.0.29.202)]","","","","false","https://stackoverflow.com/a/76532285","","1","Answer","How to export and read json output from neo4j cypher queries?","false","76532285","",,,,,
"1542",":Comment","","","","","","","","https://stackoverflow.com/questions/76531524/how-to-export-and-read-json-output-from-neo4j-cypher-queries#comment134938025_76531524","","1","Comment","","false","134938025","",,,,,
"1543",":Comment","","","","","","","","https://stackoverflow.com/questions/76531524/how-to-export-and-read-json-output-from-neo4j-cypher-queries#comment134938125_76531524","","0","Comment","","false","134938125","",,,,,
"1544",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/spring-projections","spring-projections","","Tag","","false","","",,,,,
"1545",":Comment","","","","","","","","https://stackoverflow.com/questions/76526269/spring-data-neo4j-custom-query-that-maps-node-entity-inside-collect-aggregate#comment134943992_76526269","","0","Comment","","false","134943992","",,,,,
"1546",":Comment","","","","","","","","https://stackoverflow.com/questions/76526269/spring-data-neo4j-custom-query-that-maps-node-entity-inside-collect-aggregate#comment134945489_76526269","","0","Comment","","false","134945489","",,,,,
"1547",":Comment","","","","","","","","https://stackoverflow.com/questions/76526269/spring-data-neo4j-custom-query-that-maps-node-entity-inside-collect-aggregate#comment134946208_76526269","","0","Comment","","false","134946208","",,,,,
"1548",":Answer","","","No, there is no automated way, and even if there were the generated result could be suboptimal or even wrong for your use cases.

You need to design the graph data model (node labels, relationship types, etc.) yourself. There are many considerations (like your use cases, and the necessary indexes and constraints) that are not revealed by a simple JSON data dump. Also, you need to understand the schema of the JSON and determine how to map that to your data model.","","","","false","https://stackoverflow.com/a/76526575","","1","Answer","Can neo4j create the map automatically from the json file if the relationships are defined in the json file?","false","76526575","",,,,,
"1549",":Answer","","","It looks like neo4j can&#39;t automatically create a graph data model using a json file (as @cybersam pointed out earlier).

I ended up writing a Python script to do this for me. Posting this here just in case it helps someone. It does the job for me!

    from neo4j import GraphDatabase
    import json
    
    # Connect to Neo4j
    uri = &quot;bolt://localhost:7687&quot;
    username = &quot;_username_&quot;
    password = &quot;_password_&quot;
    
    driver = GraphDatabase.driver(uri, auth=(username, password))
    
    processed_painting_ids = set() #mainting a set to track unique painting node IDs
    processed_node_ids = set()

    # Load JSON data from file
    with open(&quot;data_json.json&quot;, &quot;r&quot;) as file:
        for line in file:
            json_data = json.loads(line)
    
            p_data = json_data[&quot;p&quot;]
            r_data = json_data[&quot;r&quot;]
            n_data = json_data[&quot;n&quot;]
    
            p_unique_id = p_data.get(&quot;id&quot;) #keeps track of the id of the &quot;p&quot; node. 
    
            # Handle missing values in the data
            p_id = str(p_data[&quot;id&quot;])
            p_date = str(p_data[&quot;properties&quot;].get(&quot;date&quot;, &quot;Unknown date&quot;))
            p_img = p_data[&quot;properties&quot;].get(&quot;img&quot;, &quot;Unknown img&quot;)
            p_name = p_data[&quot;properties&quot;].get(&quot;name&quot;, &quot;Unknown name&quot;)
            p_sitelink = str(p_data[&quot;properties&quot;].get(&quot;sitelink&quot;, &quot;Unknown sitelink&quot;))
            p_description = p_data[&quot;properties&quot;].get(&quot;description&quot;, &quot;Unknown description&quot;)
            p_exhibit = p_data[&quot;properties&quot;].get(&quot;exhibit&quot;, &quot;Unknown exhibit&quot;)
            p_uri = str(p_data[&quot;properties&quot;].get(&quot;uri&quot;, &quot;Unknown uri&quot;))
    
            r_id = str(r_data[&quot;id&quot;])
            r_label = r_data[&quot;label&quot;]
            start_id = str(r_data[&quot;start&quot;][&quot;id&quot;])
            end_id = str(r_data[&quot;end&quot;][&quot;id&quot;])
    
            n_id = str(n_data[&quot;id&quot;])
            n_name = n_data[&quot;properties&quot;].get(&quot;name&quot;, &quot;Unknown name&quot;)
            n_sitelink = str(n_data[&quot;properties&quot;].get(&quot;sitelink&quot;,&quot;Unknown sitelink&quot;))
            n_description = n_data[&quot;properties&quot;].get(&quot;description&quot;,&quot;Unknown description&quot;)
            n_uri = n_data[&quot;properties&quot;].get(&quot;uri&quot;,&quot;Unknown uri&quot;)
    
            with driver.session() as session:
        
                # Create the &quot;n&quot; material node
                if n_id not in processed_node_ids:
                    session.run(&quot;CREATE (n:&quot; + n_data[&quot;labels&quot;][0] + &quot; {id: &quot; + n_id + &quot;, name: \&quot;&quot; + n_name + &quot;\&quot;, sitelink: \&quot;&quot; + n_sitelink + &quot;\&quot;, description: \&quot;&quot; + n_description + &quot;\&quot;, uri: \&quot;&quot; + uri + &quot;\&quot;})&quot;)
                    processed_node_ids.add(n_id)
                # check if the &quot;p&quot; node is repititive
                if p_unique_id not in processed_painting_ids:
                    # Create the &quot;p&quot; node
                    session.run(&quot;CREATE (p:&quot; + p_data[&quot;labels&quot;][0] + &quot;{id: &quot;+p_id+&quot;,date: \&quot;&quot;+p_date+&quot;\&quot;, img: \&quot;&quot;+p_img+&quot;\&quot;, name: \&quot;&quot;+p_name+&quot;\&quot;, sitelink: &quot; + p_sitelink+&quot;, description: \&quot;&quot;+p_description+&quot;\&quot;, exhibit: \&quot;&quot;+p_exhibit+&quot;\&quot;, uri: \&quot;&quot;+p_uri + &quot;\&quot;})&quot;) 
                    # Add id of the node to the set
                    processed_painting_ids.add(p_unique_id)
                # Create the &quot;r&quot; relationship
                session.run(&quot;MATCH (start), (end) WHERE start.id = &quot;+start_id+&quot; AND end.id = &quot;+end_id+&quot; CREATE (start)-[r:&quot;+r_label+&quot; {id: &quot;+r_id+&quot;}]-&gt;(end)&quot;)","","","","false","https://stackoverflow.com/a/76533484","","1","Answer","Can neo4j create the map automatically from the json file if the relationships are defined in the json file?","false","76533484","",,,,,
"1550",":Comment","","","","","","","","https://stackoverflow.com/questions/76525941/can-neo4j-create-the-map-automatically-from-the-json-file-if-the-relationships-a#comment134935456_76525941","","0","Comment","","false","134935456","",,,,,
"1551",":Answer","","","Here is one way of finding other `Maintenance` nodes connected to the same set of `WorkStep` nodes as a given `Maintenance` node:

    MATCH (m:Maintenance)-[:HAS]-&gt;(w:WorkStep)
    WHERE m.name = &#39;13 Years (325000 km)&#39;
    WITH m, COLLECT(w) AS ws
    MATCH (other:Maintenance)-[:HAS]-&gt;(w1:WorkStep)
    WHERE w1 IN ws
    WITH ws, other, COLLECT(w1) AS w1s
    WHERE ALL(x IN ws WHERE x IN w1s)
    RETURN other

I assume above that the `name` property of `Maintenance` nodes is unique. It is not generally a reliable practice to find a node/relationship by its the native ID, as the native ID can be reused after entity deletion. Also, the [ID()](https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-id) function is now deprecated.","","","","true","https://stackoverflow.com/a/76525872","","1","Answer","Neo4j: Searching in graph for exact same sub-graph","false","76525872","",,,,,
"1552",":Answer","","","What about:

```cypher
MATCH (n)
WHERE n.name =~ &#39;.*[A-Z]+.*&#39;
RETURN n
```

Ideally, you will want to at least restrict the initial pattern (here: `(n)`) by a label (let&#39;s say: `Person`):

```cypher
MATCH (n:Person)
WHERE n.name =~ &#39;.*[A-Z]+.*&#39;
RETURN n
```

... and create an index for that label and property to speed up the lookup:

```cypher
CREATE INDEX person_name IF NOT EXISTS FOR (p:Person) ON (p.name)
```","","","","true","https://stackoverflow.com/a/76522550","","2","Answer","Find all nodes containing capital letter in specific property value","false","76522550","",,,,,
"1553",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/networkx","networkx","","Tag","","false","","",,,,,
"1554",":Answer","","","Would the following work for you (replace `n` with an actual max hop)?

```cypher
MATCH (p:Person)
OPTIONAL MATCH path=(p)-[*1..n]-&gt;()
RETURN p, collect(path) AS paths
```","","","","false","https://stackoverflow.com/a/76522530","","1","Answer","How do I query neo4j to get a node of any class, and surrounded nodes, inlcuding relationship?","false","76522530","",,,,,
"1555",":Answer","","","You can use the [apoc.agg.minItems](https://neo4j.com/docs/apoc/current/overview/apoc.agg/apoc.agg.minItems/) function to simplify the logic:

    MATCH (l:Landmark), (r:Road)
    WITH l, apoc.agg.minItems(r, point.distance(l.coordinate ,r.coordinate), 1).items[0] AS nearestRoad
    CREATE (l)-[:relatesTo]-&gt;(nearestRoad)

If you will still get the same results, then it is probably the case that there is actually one road that is the closes to all your landmarks.","","","","false","https://stackoverflow.com/a/76518100","","0","Answer","How to pick a parent node then iterate over other node (with different label) and find some information and do it repeatedly for each parent node","false","76518100","",,,,,
"1556",":Comment","","","","","","","","https://stackoverflow.com/questions/76501936/how-to-pick-a-parent-node-then-iterate-over-other-node-with-different-label-an#comment134915501_76501936","","0","Comment","","false","134915501","",,,,,
"1557",":Answer","","","You can store `organisationId` within the `Project` nodes and create a constraint like this:

    CREATE CONSTRAINT organisationId_project_name IF NOT EXISTS
    FOR (n:Project)
    REQUIRE (n.name, n.organisationId) IS UNIQUE","","","","false","https://stackoverflow.com/a/76511597","","0","Answer","Unique key for nodes and relationship property","false","76511597","",,,,,
"1558",":Comment","","","","","","","","https://stackoverflow.com/questions/76498481/unique-key-for-nodes-and-relationship-property#comment134891206_76498481","","1","Comment","","false","134891206","",,,,,
"1559",":Comment","","","","","","","","https://stackoverflow.com/questions/76498481/unique-key-for-nodes-and-relationship-property#comment134904386_76498481","","1","Comment","","false","134904386","",,,,,
"1560",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/knn","knn","","Tag","","false","","",,,,,
"1561",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/recommendation-engine","recommendation-engine","","Tag","","false","","",,,,,
"1562",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/collaborative-filtering","collaborative-filtering","","Tag","","false","","",,,,,
"1563",":Comment","","","","","","","","https://stackoverflow.com/questions/76497144/cypher-and-k-nearest-neighbor-collaborative-filtering#comment134914708_76497144","","0","Comment","","false","134914708","",,,,,
"1564",":Comment","","","","","","","","https://stackoverflow.com/questions/76497144/cypher-and-k-nearest-neighbor-collaborative-filtering#comment134914750_76497144","","0","Comment","","false","134914750","",,,,,
"1565",":Answer","","","This should work:

    MATCH (a:Person)-[r]-&gt;(b)
    WHERE a.id = &quot;PersonA&quot;
    WITH a, TYPE(r) AS t, COLLECT({id: b.id}) AS bIds
    WITH a, COLLECT({t: t, bIds: bIds}) AS data
    RETURN REDUCE(s = {id: a.id}, d IN data | apoc.map.setEntry(s, d.t, d.bIds))

The query assumes all person nodes have the `Person` label and a unique `id` property. The result looks likes this:

    {
      &quot;id&quot;: &quot;PersonA&quot;,
      &quot;IS_FRIENDS_WITH&quot;: [
        {
          &quot;id&quot;: &quot;PersonD&quot;
        }
      ],
      &quot;KNOWS&quot;: [
        {
          &quot;id&quot;: &quot;PersonB&quot;
        },
        {
          &quot;id&quot;: &quot;PersonC&quot;
        }
      ],
      &quot;LIKES&quot;: [
        {
          &quot;id&quot;: &quot;PersonE&quot;
        }
      ]
    }","","","","true","https://stackoverflow.com/a/76493211","","2","Answer","Cypher: group nodes by relation type","false","76493211","",,,,,
"1566",":Answer","","","if I get the questions right,

1. you create :CAN_SEE relations with this query

    match (u:User)--&gt;(:Territory)&lt;--(:Account)--&gt;(i:Invoice)
    merge (u)-[:CAN_SEE]-&gt;(i)

MERGE should prevent creation of multiple relations

2. &amp; 3. if I get you right, in both case, you want to check that the path from user to invoice still exists and delete the CAN_SEE relation if the path is broken. the following query should do that

    match (u:User)-[r:CAN_SEE]-(i:Invoice) where not exists((u)--&gt;(:Territory)&lt;--(:Account)--&gt;(i))
    delete r

do test before applying in production though, I did not test
","","","","false","https://stackoverflow.com/a/76516805","","1","Answer","Recalculating Neo4J relationships based on chain of relationships","false","76516805","",,,,,
"1567",":Answer","","","I assume that your questions are for updating a graph that already contains the appropriate `CAN_SEE` relationships.

1. Use the following query to update the graph when a specific account (say, `A1`) is deleted. The query uses [DETACH DELETE](https://neo4j.com/docs/cypher-manual/current/clauses/delete/#delete-a-node-with-all-its-relationships) to delete matching paths and all relationships (including `BELONGS_TO` and `CAN_SEE`) for all deleted nodes.

       MATCH p=(a:Account)-[:ISSUED]-&gt;(:Invoice)-[:HAS]-&gt;(:InvoiceEntry)
       WHERE a.id = &#39;A2&#39;
       DETACH DELETE p

2. Use this query to disconnect a user (`U1`) from a territory (`T3`), and to delete all the `CAN_SEE` relationships from that user to all invoices issued by all accounts in the territory:

       MATCH  (u:User)-[bt:BELONGS_TO]-&gt;(t:Territory)&lt;-[:EXISTS_IN]-(:Account)-[:ISSUED]-&gt;(:Invoice)&lt;-[cs:CAN_SEE]-(u)
       WHERE u.id = &#39;U1&#39; AND t.id = &#39;T3&#39;
       DELETE bt, cs","","","","false","https://stackoverflow.com/a/76519149","","0","Answer","Recalculating Neo4J relationships based on chain of relationships","false","76519149","",,,,,
"1568",":Comment","","","","","","","","https://stackoverflow.com/questions/76483469/recalculating-neo4j-relationships-based-on-chain-of-relationships#comment134861549_76483469","","0","Comment","","false","134861549","",,,,,
"1569",":Comment","","","","","","","","https://stackoverflow.com/questions/76483469/recalculating-neo4j-relationships-based-on-chain-of-relationships#comment134864230_76483469","","0","Comment","","false","134864230","",,,,,
"1570",":Comment","","","","","","","","https://stackoverflow.com/questions/76483469/recalculating-neo4j-relationships-based-on-chain-of-relationships#comment134957139_76483469","","0","Comment","","false","134957139","",,,,,
"1571",":Answer","","","You can use UNWIND which is similar to a WHILE looping in sql.

    MATCH (a)-[:connection]-(b:labelB)
    WHERE a.id IN $selection
    WITH COLLECT(a) + COLLECT(b) AS selections
    UNWIND selections as selection
    MATCH (selection)-[]-(c)
    RETURN c","","","","true","https://stackoverflow.com/a/76482862","","1","Answer","Combining two results in cypher","false","76482862","",,,,,
"1572",":Answer","","","You could also just replace this:

    MATCH (selection)-[]-(c)

with this:

    MATCH (s)--(c)
    WHERE s IN selection

*By the way, I should point out that your first query will cause `selection` to have duplicate nodes if it is possible for a `connection` to connect 2 `labelB` nodes.*","","","","false","https://stackoverflow.com/a/76485499","","1","Answer","Combining two results in cypher","false","76485499","",,,,,
"1573",":Answer","","","Whenever you execute a query (with `driver.execute_query` or with any session/transaction API), specifying the target database if you know it in advance, is a good idea.

Why? Because Neo4j introduced the &quot;home database&quot; concept, which allows different users to have default databases.

If you do not not specify what database you target, the driver will first have to communicate with the server to figure out what the home database is for the given user.

Since the home database can be changed at any time, the driver only caches that information once per session.

Therefore, you should specify the target database at the session configuration level every time you use a session API, to avoid that resolution process to kick in.

Since `driver.execute_query` is a facade on session&#39;s retryable transaction APIs (the driver manages the session for you in this case), you also need to specify the database there, if you want the managed session to be properly configured.

Note: there are ongoing internal discussions to improve the way drivers handle the &quot;home database resolution&quot; issue, so stay tuned for potential improvements in the next releases!","","","","false","https://stackoverflow.com/a/76482549","","1","Answer","clarification on Neo4j&#39;s performance good practice","false","76482549","",,,,,
"1574",":Answer","","","The documentation could be a bit clearer.

`driver.execute_query` and `driver.session` actually represent 2 *different ways* to execute queries. You would use one call or the other, but not together.

It would have been clearer for the documentation to say something like:

    # Good practice
    driver.execute_query(&quot;&lt;QUERY&gt;&quot;, database_=&quot;&lt;DB NAME&gt;&quot;)
      OR
    driver.session(database=&quot;&lt;DB NAME&gt;&quot;)
    
    # Bad practice
    driver.execute_query(&quot;&lt;QUERY&gt;&quot;)
      OR
    driver.session()","","","","true","https://stackoverflow.com/a/76485346","","2","Answer","clarification on Neo4j&#39;s performance good practice","false","76485346","",,,,,
"1575",":Comment","","","","","","","","https://stackoverflow.com/questions/76480799/clarification-on-neo4js-performance-good-practice#comment134852699_76480799","","0","Comment","","false","134852699","",,,,,
"1576",":Answer","","","You can use an APOC function for this purpose.

    Line 1 is an illustration when rv is null. Remove it on your actual query
    Line 2 is using the APOC function &#39;do when&#39;
    Line 3 is the condition. if true then run line 4 else line 5
    Line 4 is your true condition
    Line 5 is your false condition
    Line 6 returns the node that you created

    1    WITH null as rv
    2    CALL apoc.do.when(
    3      rv is not null,
    4      &quot;CREATE (n1:Test1 {name: &#39;Test1&#39;}) RETURN n1&quot;,
    5      &quot;CREATE (n2:Test2 {name: &#39;Test2&#39;}) RETURN n2&quot;) YIELD value 
    6    RETURN value","","","","false","https://stackoverflow.com/a/76482995","","0","Answer","Is there a way to use create and return with cypher cases?","false","76482995","",,,,,
"1577",":Answer","","","In addition to using [apoc.do.when](https://neo4j.com/labs/apoc/4.2/overview/apoc.do/apoc.do.when/), as suggested by @jose_bacoy, you can use [apoc.create.node](https://neo4j.com/labs/apoc/4.2/overview/apoc.create/apoc.create.node/):

    ... // prior Cypher that defines rv
    WITH CASE
      WHEN rv IS NULL THEN {l: &#39;Test2&#39;, n: &#39;Test2&#39;}
      ELSE {l: &#39;Test1&#39;, n: &#39;Test1&#39;}
    END AS x
    CALL apoc.create.node([x.l], {name: x.n}) YIELD node AS n
    RETURN n

Or, if you want to avoid using the APOC library for some reason, you can use a [CALL subquery](https://neo4j.com/docs/cypher-manual/5/clauses/call-subquery/) in neo4j 4.1+:

    ... // prior Cypher that defines rv
    CALL {
        WITH rv
        WITH rv WHERE rv IS NOT NULL
        CREATE (n:Test1 {name: &quot;Test1&quot;})
        RETURN n
    
        UNION
    
        WITH rv
        WITH rv WHERE rv IS NULL
        CREATE (n:Test2 {name: &#39;Test2&#39;})
        RETURN n
    }
    RETURN n

","","","","false","https://stackoverflow.com/a/76485267","","0","Answer","Is there a way to use create and return with cypher cases?","false","76485267","",,,,,
"1578",":Answer","","","Persisting nested properties [is not supported by Neo4j][1] so what you describe is not feasible.

Instead of nesting properties, you can define an extra node and link it to the original node with a relationship.
Alternatively, you can &quot;flatten&quot; the nested properties to a non-nested dictionary of properties.


  [1]: https://neo4j.com/docs/getting-started/appendix/graphdb-concepts/#graphdb-properties","","","","true","https://stackoverflow.com/a/76471849","","0","Answer","Is there a way to have neo4j / cypher place constraint on a nested property?","false","76471849","",,,,,
"1579",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/redisgraph","redisgraph","","Tag","","false","","",,,,,
"1580",":Answer","","","### Explanation

Redisgraph only covers a [subset of the Cypher language](https://redis.io/docs/stack/graph/cypher_support/), called [openCypher](https://opencypher.org/).

The [openCypher language spec](https://s3.amazonaws.com/artifacts.opencypher.org/openCypher9.pdf) states:

&gt;`exists()` returns true if the specified property exists in the node, relationship or map.

Therefore, in `openCypher` the `EXISTS()` function only supports testing for property existence, and does not support testing for the existence of paths.

### Workaround

The workaround at the bottom of your question does work, but it requires the server to find all matches before returning. For efficiency you want the query to return as soon the first match is found (if any). Here is a modified version of your workaround that does that:

    MATCH (:DataProduct {name: &#39;DataProduct1&#39;})-[:CONTAINS]-&gt;(:Table {name: &#39;output_table&#39;})-[:HAS_COLUMN]-&gt;(:Column {name: &#39;foo&#39;})-[:TRANSFORMATION]-&gt;(t)
    WITH t
    LIMIT 1
    RETURN COUNT(*) &gt; 0
","","","","true","https://stackoverflow.com/a/76467684","","2","Answer","Exists function in RedisGraph","false","76467684","",,,,,
"1581",":Answer","","","You can break down the query and use `OPTIONAL MATCH` like this:

    MATCH (asset_data:Asset)&lt;-[metadata:MD]-(:RawData)
    OPTIONAL MATCH (group_data:Group)-[]-&gt;(asset_data)
    RETURN group_data, asset_data, metadata","","","","false","https://stackoverflow.com/a/76466082","","0","Answer","Conditional return in cypher query","false","76466082","",,,,,
"1582",":Comment","","","","","","","","https://stackoverflow.com/questions/76464135/conditional-return-in-cypher-query#comment134825617_76464135","","0","Comment","","false","134825617","",,,,,
"1583",":Comment","","","","","","","","https://stackoverflow.com/questions/76464135/conditional-return-in-cypher-query#comment134826389_76464135","","0","Comment","","false","134826389","",,,,,
"1584",":Answer","","","[UPDATED]

This will return the number nodes for each name:

    MATCH (b:Book)
    RETURN b.Name AS name, COUNT(*) AS book_count","","","","true","https://stackoverflow.com/a/76434758","","0","Answer","count nodes per property neo4j database","false","76434758","",,,,,
"1585",":Comment","","","","","","","","https://stackoverflow.com/questions/76433557/count-nodes-per-property-neo4j-database#comment134775131_76433557","","0","Comment","","false","134775131","",,,,,
"1586",":Comment","","","","","","","","https://stackoverflow.com/questions/76433557/count-nodes-per-property-neo4j-database#comment134778115_76433557","","0","Comment","","false","134778115","",,,,,
"1587",":Comment","","","","","","","","https://stackoverflow.com/questions/76428442/why-are-neo4j-browser-returning-different-elementids-on-the-same-nodes#comment134770474_76428442","","2","Comment","","false","134770474","",,,,,
"1588",":Comment","","","","","","","","https://stackoverflow.com/questions/76428442/why-are-neo4j-browser-returning-different-elementids-on-the-same-nodes#comment134781715_76428442","","0","Comment","","false","134781715","",,,,,
"1589",":Comment","","","","","","","","https://stackoverflow.com/questions/76428442/why-are-neo4j-browser-returning-different-elementids-on-the-same-nodes#comment134783054_76428442","","0","Comment","","false","134783054","",,,,,
"1590",":Comment","","","","","","","","https://stackoverflow.com/questions/76428442/why-are-neo4j-browser-returning-different-elementids-on-the-same-nodes#comment134790508_76428442","","0","Comment","","false","134790508","",,,,,
"1591",":Answer","","","The simplest thing to do is just traverse the graph with variable path length:

```
match path = (s)-[*..9]-&gt;()--&gt;(e)
where s:X4 and s:TYPE2 and e:ROOT
with [n in nodes(path) where n &lt;&gt; e | n] as parentnodes
return parentnodes
```
Variable path length can make the query explode, especially if you have supernodes. If you have a fairly balanced tree structure like in your diagram, this may be okay.

UPDATE:
This will make it so you don&#39;t need to know the label on the root node:
```
match path = (s)-[*..9]-&gt;()--&gt;(e)
where s:X4 and S:TYPE2 and not (e)-&gt;()
with [n in nodes(path) where n &lt;&gt; e | n] as parentnodes
return parentnodes
```","","","","false","https://stackoverflow.com/a/76434142","","0","Answer","Recursively find all parent nodes for a given node in neo4j","false","76434142","",,,,,
"1592",":Answer","","","[UPDATED]

This query will return all distinct `ancestor` nodes by following all outbound relationships starting at a given `n` node, excluding any node that has no outbound relationships.

    ... // (prior Cypher providing n)

    MATCH p = (n)-[*..8]-&gt;(root)
    WHERE NOT EXISTS((root)--&gt;())
    UNWIND NODES(p)[1..-1] AS ancestor
    RETURN DISTINCT ancestor

This query also puts an upper bound on the [variable length pattern](https://neo4j.com/docs/cypher-manual/current/syntax/patterns/#cypher-pattern-varlength) to avoid taking forever or running out of memory.

The `x[1..-1]` syntax specifies a sublist of `x` consisting of its second element up to and including its next-to-last element. *(The [documentation](https://neo4j.com/docs/cypher-manual/current/values-and-types/lists/#_list_range_and_size) is a bit misleading, as it concentrates on the `range()` function, whereas specifying a sublist does not depend on using the `range()` function at all. The 2 concepts should have been covered separately.)*","","","","true","https://stackoverflow.com/a/76434660","","0","Answer","Recursively find all parent nodes for a given node in neo4j","false","76434660","",,,,,
"1593",":Comment","","","","","","","","https://stackoverflow.com/questions/76427321/recursively-find-all-parent-nodes-for-a-given-node-in-neo4j#comment134766379_76427321","","0","Comment","","false","134766379","",,,,,
"1594",":Comment","","","","","","","","https://stackoverflow.com/questions/76427321/recursively-find-all-parent-nodes-for-a-given-node-in-neo4j#comment134766828_76427321","","0","Comment","","false","134766828","",,,,,
"1595",":Comment","","","","","","","","https://stackoverflow.com/questions/76417047/issue-with-calling-graphsage-neo4j-graph-embedding-method-from-python-driver#comment134775827_76417047","","0","Comment","","false","134775827","",,,,,
"1596",":Answer","","","If I understand your question: your DB has a million nodes without any relationships and you want to provide input data to add relationships between those nodes.

Here is a simple example of how to do that.

I assume your nodes all look something like this (where the `id` is unique):

    (:Foo {id: &quot;a&quot;, x: 123, ... and so forth ...})

and you want to connect the appropriate `Foo` nodes with `BAR` relationships. In this simple example, the relationships have no properties.

I also assume your input is in a CSV file named &quot;bar_data.csv&quot; whose beginning looks like this (`start`/`end` are the the `id`s of each new `BAR` relationship&#39;s start/end nodes):

    start,end
    a,b
    b,x
    j,w
    ... and so forth ...

Here is a sample Cypher query to load the input CSV file and create the relationships (in batches of 20000 per transaction, to avoid running out of server resources). You can tweak the batch size.

    :auto // :auto line is needed when using IN TRANSACTIONS option in Neo4j Browser
    LOAD CSV WITH HEADERS FROM &#39;file:///bar_data.csv&#39; AS row
    CALL {
      WITH row
      MATCH (start:Foo), (end:Foo)
      WHERE start.id = row.start AND end.is = row.end
      CREATE (start)-[:BAR]-&gt;(end)
    } IN TRANSACTIONS OF 20000 ROWS

You will need to read the [LOAD CSV](https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/) documentation to see how to configure the server, where the file can be stored, what the file URL can look like, and so forth.

Also the query will run *much faster* if you have an [index](https://neo4j.com/docs/cypher-manual/current/indexes-for-search-performance/) or [uniqueness constraint](https://neo4j.com/docs/cypher-manual/current/constraints/) on `:Foo(id)`.","","","","false","https://stackoverflow.com/a/76416921","","0","Answer","Find graphs in DB that are subgraphs of an input graph","false","76416921","",,,,,
"1597",":Comment","","","","","","","","https://stackoverflow.com/questions/76416046/find-graphs-in-db-that-are-subgraphs-of-an-input-graph#comment134775980_76416046","","0","Comment","","false","134775980","",,,,,
"1598",":Answer","","","I think this relates to this [issue](https://github.com/spring-projects/spring-data-neo4j/issues/2728) with Spring Boot 3.1.0 and Spring Data Neo4j that is waiting for a fix release. You can add the below section of code to the configuration/SpringBootApplication class. It should be fixed once the updated release is published.

    @Bean
    public Configuration cypherDslConfiguration() {
        return Configuration.newConfig()
            .withDialect(Dialect.NEO4J_5)
            .build();
    }

*Update Jun27: The issue is actually due to a problem with the map projection returned in the custom queries. It has been resolved with a fix. More information is available in the [Github thread][1].


  [1]: https://github.com/spring-projects/spring-data-neo4j/issues/2749","","","","false","https://stackoverflow.com/a/76417428","","0","Answer","Error mapping node with custom CYPHER RETURN leaving out relations in SDN 7.1.0","false","76417428","",,,,,
"1599",":Answer","","","I had similar situation and i&#39;ve resolve to verify new names of atributes or name attibutes updates. You have there some one nodes with have values with past attributes and it&#39;s the problem.","","","","false","https://stackoverflow.com/a/77882414","","0","Answer","Error mapping node with custom CYPHER RETURN leaving out relations in SDN 7.1.0","false","77882414","",,,,,
"1600",":User","","","","","Antony Delgado","","","","","","User","","false","3665204","",,,,,
"1601",":Answer","","","You need to collect and unwind all the nodes, like this:

    MATCH(n:Prop)
    WHERE toLower(n.Type)=toLower(&quot;abc&quot;) 
    WITH n.Id AS id, n
    MATCH (new:op)
    WHERE new.Id STARTS WITH id
    WITH new,n 
    MATCH (o:`here`)-[:Property]-&gt;(new) 
    WHERE (o:Obj) 
    WITH Count(DISTINCT o) AS languages, n, new
    WITH count(n) as nodesCount, COLLECT(n.Id) as ids
    UNWIND ids as nodeId
    RETURN nodesCount, nodeId","","","","false","https://stackoverflow.com/a/76407574","","1","Answer","Not able to use COUNT properly in cypher query","false","76407574","",,,,,
"1602",":Answer","","","Swap the places of the fields in your return. The reason for that is that Cypher does implicit aggregation, so it will aggregate on each field in the list in written order. In your example, it will group first on `count(n)`, then on `id(n)`. I think you want to group on the count for each id. Updated Cypher is below.

    MATCH(n:Prop)
        WHERE toLower(n.Type)=toLower(&quot;abc&quot;) 
        WITH n.Id AS id, n
        MATCH (new:op)
        WHERE new.Id STARTS WITH id
        WITH new,n 
        MATCH (o:`here`)-[:Property]-&gt;(new) 
        WHERE (o:Obj) 
        WITH Count(DISTINCT o) AS languages,n,new
    return id(n), count(n)","","","","false","https://stackoverflow.com/a/76416593","","0","Answer","Not able to use COUNT properly in cypher query","false","76416593","",,,,,
"1603",":Answer","","","Last time I did an export like this, I used [`apoc.export.json.query`](https://neo4j.com/labs/apoc/4.3/overview/apoc.export/apoc.export.json.query/). That procedure uses results from a query and exports it as JSON. Depending on your desired JSON format, you may need to run a couple tools to remove extra escape characters and such (tr, sed, or something). I believe I ran `tr -d &#39;\&#39; file` on it to remove extra backslashes.","","","","false","https://stackoverflow.com/a/76409516","","0","Answer","Returning formatted json querying a tree with two different relationships (cypher)","false","76409516","",,,,,
"1604",":Answer","","","You should filter the users and teams, using an additional `WITH` clause. Like this:

    MATCH (u:User)
    WHERE (u.email in $userEmails)
    OPTIONAL MATCH (u)-[r:MEMBER_OF]-(t:Team)
    WITH u, r, t WHERE t IS NULL OR NOT (t.id IN $excludedTeamIds)
    RETURN r, u, t;","","","","true","https://stackoverflow.com/a/76380516","","1","Answer","Filtering out optional matches or results in cypher query","false","76380516","",,,,,
"1605",":Comment","","","","","","","","https://stackoverflow.com/questions/76379275/filtering-out-optional-matches-or-results-in-cypher-query#comment134684679_76379275","","0","Comment","","false","134684679","",,,,,
"1606",":Comment","","","","","","","","https://stackoverflow.com/questions/76379275/filtering-out-optional-matches-or-results-in-cypher-query#comment134685351_76379275","","0","Comment","","false","134685351","",,,,,
"1607",":Comment","","","","","","","","https://stackoverflow.com/questions/76379275/filtering-out-optional-matches-or-results-in-cypher-query#comment134685421_76379275","","1","Comment","","false","134685421","",,,,,
"1608",":Comment","","","","","","","","https://stackoverflow.com/questions/76379275/filtering-out-optional-matches-or-results-in-cypher-query#comment134685506_76379275","","0","Comment","","false","134685506","",,,,,
"1609",":Comment","","","","","","","","https://stackoverflow.com/questions/76379275/filtering-out-optional-matches-or-results-in-cypher-query#comment134685535_76379275","","1","Comment","","false","134685535","",,,,,
"1610",":Comment","","","","","","","","https://stackoverflow.com/questions/76379275/filtering-out-optional-matches-or-results-in-cypher-query#comment134685542_76379275","","0","Comment","","false","134685542","",,,,,
"1611",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/time-complexity","time-complexity","","Tag","","false","","",,,,,
"1612",":Answer","","","

### Example
```
MATCH (p:Person {name: &#39;Tom Hanks&#39;})
RETURN p
```

### Result
```
Planner COST

Runtime PIPELINED

Runtime version 5.8

Batch size 128

+------------------+----+------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator         | Id | Details                | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------+----+------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults  |  0 | p                      |              6 |    1 |       3 |                |                        |           |                     |
| |                +----+------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Filter          |  1 | p.name = $autostring_0 |              6 |    1 |     250 |                |                        |           |                     |
| |                +----+------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan |  2 | p:Person               |            125 |  125 |     126 |            120 |                    3/0 |     0.772 | Fused in Pipeline 0 |
+------------------+----+------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 379, total allocated memory: 184

1 row
```

As you can see, when you search a node, it will scan all nodes which mean the time complexity is O(N).

However you can create index for node that can improve search faster.

More info: [document](https://neo4j.com/docs/cypher-manual/current/query-tuning/basic-example/)","","","","true","https://stackoverflow.com/a/76378562","","1","Answer","What&#39;s the time complexity of query a node in neo4j?","false","76378562","",,,,,
"1613",":User","","","","","Xiang","","","","","","User","","false","13994829","",,,,,
"1614",":Answer","","","I guess you&#39;ll first have to fetch the relationships using the index and then apply the `MATCH`. Try this:

    MATCH (p:Person { id: $p_id })-[k1:`KNOWS`]-&gt;(person:Person)
    WHERE (// some criteria)
    CALL db.index.fulltext.queryRelationships(&quot;indexName&quot;, &quot;searchString&quot;) 
    YIELD relationship AS work
    MATCH (person)-[work]-&gt;(company:Company)
    WITH person, work
    RETURN DISTINCT person.full_name, work.title

Alternatively, you can perform a case-insensitive search using regex. Like this:

    MATCH (p:Person { id: $p_id })-[k1:`KNOWS`]-&gt;(person:Person)
    WHERE (// some criteria)
    MATCH (person)-[work:`WORKED_AT`]-&gt;(company:Company)
    WHERE (work.title =~ &#39;(?i).*Product Manager.*&#39; and work.start_date is not null)
    WITH person, work
    RETURN DISTINCT person.full_name, work.title","","","","false","https://stackoverflow.com/a/76372727","","1","Answer","How to efficiently use a fulltext index to search based on prior MATCH results in same query","false","76372727","",,,,,
"1615",":Comment","","","","","","","","https://stackoverflow.com/questions/76372597/how-to-efficiently-use-a-fulltext-index-to-search-based-on-prior-match-results-i#comment134776215_76372597","","0","Comment","","false","134776215","",,,,,
"1616",":Answer","","","from what I understood that you are looking for `bfs` traversal. On Memgraph you can check it out here: https://memgraph.com/docs/memgraph/reference-guide/built-in-graph-algorithms#breadth-first-search

For the first question (&quot;Get Node A and 3 of its children ordered by KNOWN_FOR age desc, where age &gt; 5.&quot;), this should be a query:

```
MATCH path=(n:Node {name:&quot;a&quot;})-[rels *bfs..1]-&gt;(m)
WITH n, m,  rels[0] as rel0
WHERE rel0.age &gt; 5
RETURN n.name, m.name, rel0.age
ORDER BY rel0.age DESC;
```
Basically, here, you get a node with property name &quot;a&quot;, then do `bfs` of up to max 1 step to some node `m`.  Now, in variable `rels` you will have all the relationships that `bfs` visits. In `bfs` it will visit relationships at some order, but to get data sorted on output you will need `ORDER BY` and then reference `rel0`&#39;s property `age`.
Also, I am getting different output here, I think you are missing node &quot;B&quot; with value 7.


For the second question () if I understood correctly you want to expand from node A up to 3 steps and then order by `age` property in a way that you first compare all relationships on the first expansion, and then on second. 

There are two options for that as I see it in Memgraph:
```
MATCH path=(n:Node {name:&quot;a&quot;})-[rels *bfs..3]-&gt;(m)
WITH path, n, m,  rels[0] as rel0, rels[1] as rel1, rels[2] as rel2
RETURN n.name ,m.name, rel0.age, rel1.age, rel2.age, extract(p IN nodes(path) | p.name) as nodes
ORDER BY rel0.age DESC, rel1.age DESC, rel2.age DESC;
```

and second one:
```
MATCH path=(n:Node {name:&quot;a&quot;})-[rels *bfs..3]-&gt;(m)
WITH n, m,  extract(r IN rels | r.age) as ages_list, rels
WHERE ages_list[0] &gt; 5
RETURN n.name ,m.name, ages_list
ORDER BY ages_list[0] DESC, ages_list[1] DESC;
```

The idea behind the second option is to extract properties in the list and then compare the values of the list. There is no error thrown if there is no value in the list, it will return null. Basically, it will first compare all age values on first expansion, and then on second, etc...


Let me know if you have any more questions. Also, a good tutorial on BFS can be found on Memgraph&#39;s Playground: https://playground.memgraph.com/topic/cypher-breadth-first-search.

For more docs, check Memgraph&#39;s site I linked, it should be helpful.","","","","false","https://stackoverflow.com/a/76366430","","2","Answer","Memgraph cypher recursive tree with depth and filtering query","false","76366430","",,,,,
"1617",":User","","","","","Antonio Filipovic","","","","","","User","","false","18335586","",,,,,
"1618",":Answer","","","Can you try shift-reload on your Neo4j Browser? 

Or check in the javascript console if there are any errors? 

What versions are you using? 

Sometimes it helps to upgrade to more recent versions? 

Or try to use https://browser.neo4j.io for a centrally hosted version.
Or http://browser.graphapp.io for a non-SSL version.","","","","false","https://stackoverflow.com/a/76362716","","0","Answer","Why aren&#39;t nodes displaying in neo4j graph view when they show up in Table and Text view?","false","76362716","",,,,,
"1619",":Comment","","","","","","","","https://stackoverflow.com/questions/76360295/why-arent-nodes-displaying-in-neo4j-graph-view-when-they-show-up-in-table-and-t#comment134651133_76360295","","0","Comment","","false","134651133","",,,,,
"1620",":Comment","","","","","","","","https://stackoverflow.com/questions/76360295/why-arent-nodes-displaying-in-neo4j-graph-view-when-they-show-up-in-table-and-t#comment134776512_76360295","","0","Comment","","false","134776512","",,,,,
"1621",":Answer","","","I have found the following query that works:

    MATCH p=(a)-[*1..2]-(b)
    where ID(a) = &quot;node1&quot;
    and ID(b) = &quot;node2&quot;
    return count(distinct(nodes(p)))

If there is a better way to do this I&#39;m all ears!","","","","false","https://stackoverflow.com/a/77929580","","1","Answer","cypher: Count distinct paths between two nodes disregarding link type","false","77929580","",,,,,
"1622",":Answer","","","This may be faster:

    OPTIONAL MATCH (a)--(x)--(b)
    WHERE ID(a) = 123 AND ID(b) = 456
    WITH
      COUNT(DISTINCT x) AS count2,
      CASE WHEN EXISTS((a)--(b)) THEN 1 ELSE 0 END AS count1
    RETURN count2 + count1 AS count

THE `OPTIONAL MATCH` allows the query to proceed even if there are no 2-step paths. `EXISTS((a)--(b))` returns `TRUE` as soon as any one-step relationship is found, avoiding unnecessary additional DB scanning. And `COUNT(DISTINCT x)` just counts distinct `x` nodes -- there is no need to generate path variables (`p`), extract their node lists, and compare the lists.","","","","false","https://stackoverflow.com/a/77943470","","0","Answer","cypher: Count distinct paths between two nodes disregarding link type","false","77943470","",,,,,
"1623",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/php","php","","Tag","","false","","",,,,,
"1624",":Comment","","","","","","","","https://stackoverflow.com/questions/77787297/how-to-convert-labelsc0-in-neo4j-cypher-query-to-a-php-cypher-dsl#comment137135202_77787297","","0","Comment","","false","137135202","",,,,,
"1625",":Comment","","","","","","","","https://stackoverflow.com/questions/77787297/how-to-convert-labelsc0-in-neo4j-cypher-query-to-a-php-cypher-dsl#comment137137682_77787297","","0","Comment","","false","137137682","",,,,,
"1626",":Comment","","","","","","","","https://stackoverflow.com/questions/77787297/how-to-convert-labelsc0-in-neo4j-cypher-query-to-a-php-cypher-dsl#comment137140574_77787297","","0","Comment","","false","137140574","",,,,,
"1627",":Comment","","","","","","","","https://stackoverflow.com/questions/77787297/how-to-convert-labelsc0-in-neo4j-cypher-query-to-a-php-cypher-dsl#comment137140712_77787297","","0","Comment","","false","137140712","",,,,,
"1628",":Comment","","","","","","","","https://stackoverflow.com/questions/77787297/how-to-convert-labelsc0-in-neo4j-cypher-query-to-a-php-cypher-dsl#comment137146392_77787297","","0","Comment","","false","137146392","",,,,,
"1629",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/memgraph","memgraph","","Tag","","false","","",,,,,
"1630",":Answer","","","I don&#39;t really know Memgraph, but in Neo4j I would solve it like this:

    UNWIND [&#39;London&#39;, &#39;Paris&#39;, &#39;Berlin&#39;, &#39;Rome&#39;] AS capital
    OPTIONAL MATCH (n:Captial {name: capital})
    WITH n, capital WHERE n IS NULL
    RETURN capital","","","","false","https://stackoverflow.com/a/77357354","","1","Answer","How can I list only nodes that were not found using Cypher?","false","77357354","",,,,,
"1631",":Answer","","","In Memgraph, it could be solved similarly:

    WITH [&#39;London&#39;, &#39;Paris&#39;, &#39;Berlin&#39;, &#39;Rome&#39;] AS capitals
    UNWIND capitals as capital
    OPTIONAL MATCH (c:Capital {name: capital})
    WITH capital, c
    WHERE c IS NULL
    RETURN capital

After you define your list and unwind it to get each element, you can use `OPTIONAL MATCH` (we&#39;re not using `MATCH` since `OPTIONAL` allows null) to match each item of the list to the `name` property of nodes. If there are no such nodes we return that capital as an output.","","","","true","https://stackoverflow.com/a/77357928","","1","Answer","How can I list only nodes that were not found using Cypher?","false","77357928","",,,,,
"1632",":User","","","","","MPesi","","","","","","User","","false","19994481","",,,,,
"1633",":Answer","","","You need to match on the integers 0 and 3, not the strings &quot;0&quot; and &quot;3&quot;:
```
MATCH p = (:Node {id: 0})-[*]-&gt;(:Node {id: 3})
RETURN p;
```","","","","true","https://stackoverflow.com/a/77322859","","2","Answer","Graph traversing query returns no results","false","77322859","",,,,,
"1634",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/cypherl","cypherl","","Tag","","false","","",,,,,
"1635",":Answer","","","It seems the `CYPHERL` file format is not explicitly documented anywhere (at least Google is not able to find anything).

But looking at the examples on [this Memgraph page](https://memgraph.com/docs/data-migration/cypherl), it seems a `CYPHERL` file just contains a number of opencypher statements, where each statement ends with a [semicolon](https://neo4j.com/developer/cypher/style-guide/#_semicolons). Each statement is executed as a separate query.","","","","false","https://stackoverflow.com/a/77255562","","1","Answer","How to make CYPHERL file more human readable?","false","77255562","",,,,,
"1636",":Answer","","","The `.cypherl` format is specific to Memgraph and is designed to house a series of Cypher queries to be executed sequentially. When you export data into a `.cypherl` file, Memgraph generates a series of Cypher queries, which, when run in the specified order, recreate the database&#39;s state. Memgraph utilizes the newline character to delineate the start of a new query; this means that you can&#39;t use new lines to break down single queries into multiple lines within a `.cypherl` file.

So you are not doing anything wrong. This just isn&#39;t supported at this time. You can open up an issues/feature request in [Memgraph GitHub repository][1] so that our developers can take this into consideration for future versions.

Discalimere: I work at Memgraph.


  [1]: https://github.com/memgraph/memgraph","","","","true","https://stackoverflow.com/a/77258091","","2","Answer","How to make CYPHERL file more human readable?","false","77258091","",,,,,
"1637",":User","","","","","Graph Dveler","","","","","","User","","false","22661098","",,,,,
"1638",":Answer","","","your description and your example are not exactly the same : you say &quot;previous and next node(s) of a given node&quot; and your example has two sets : next and after next

given the following nodes

    create (:Person {name:&quot;H&quot;})-[:FOLLOWS]-&gt;(:Person {name:&quot;G&quot;})-[:FOLLOWS]-&gt;(:Person {name:&quot;E&quot;})-[:FOLLOWS]-&gt;(:Person {name:&quot;D&quot;});
    match (g:Person {name:&quot;G&quot;}) merge (g)-[:FOLLOWS]-&gt;(:Person {name:&quot;F&quot;})

[![screenprint of nodes created][1]][1]

here is a possible query

    match (prev:Person)-[:FOLLOWS]-&gt;(p:Person {name:&quot;G&quot;})-[:FOLLOWS]-&gt;(next:Person)
    optional match (next)-[:FOLLOWS]-&gt;(next2:Person)
    return collect(distinct prev.name),p.name,collect(distinct next.name),collect(distinct next2.name)

[![query result][2]][2]

here is the other query

[![other query and result][3]][3]


  [1]: https://i.stack.imgur.com/IDjCk.png
  [2]: https://i.stack.imgur.com/4LmZT.png
  [3]: https://i.stack.imgur.com/AltLe.png","","","","false","https://stackoverflow.com/a/77191126","","0","Answer","Grouping Cypher query results by direct relationships","false","77191126","",,,,,
"1639",":Answer","","","From your question, there looks to be two types of solution. 

To show what I mean I&#39;ll use this slightly more complicated graph that includes a merging of `FOLLOWS` downstream from `H`:
```
                                ┌───┐
                          ┌────▶│ J │
                          │     └───┘
┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐
│ H │──▶│ G │──▶│ E │──▶│ D │──▶│ I │
└───┘   └───┘   └───┘   └───┘   └───┘
          │               ▲
          │               │
          │     ┌───┐   ┌───┐   ┌───┐
          └────▶│ F │──▶│ L │──▶│ K │
                └───┘   └───┘   └───┘
```
To group every path from `Person` with `name = &#39;H&#39;` by length, showing the same `Person` more than once (because there is more than one path from, for example, `H` to `D`), use this:
```
MATCH p = (:Person {name: &#39;H&#39;})-[:FOLLOWS*0..]-&gt;(e:Person)
WITH length(p) AS l, collect(e.name) AS people
RETURN collect(people) AS result
```
Result:
```
[[&quot;H&quot;], [&quot;G&quot;], [&quot;E&quot;, &quot;F&quot;], [&quot;D&quot;, &quot;L&quot;], [&quot;I&quot;, &quot;J&quot;, &quot;D&quot;, &quot;K&quot;], [&quot;I&quot;, &quot;J&quot;]]
```
If instead you want each person to appear once, you can use the `shortestPath` function like so:
```
MATCH p = shortestPath((:Person {name: &#39;H&#39;})-[:FOLLOWS*0..]-&gt;(e:Person))
WITH length(p) AS len, collect(e.name) AS people
RETURN collect(people) AS result
```
Result:
```
[[&quot;H&quot;], [&quot;G&quot;], [&quot;E&quot;, &quot;F&quot;], [&quot;D&quot;, &quot;L&quot;], [&quot;K&quot;, &quot;I&quot;, &quot;J&quot;]]
```","","","","true","https://stackoverflow.com/a/77191320","","0","Answer","Grouping Cypher query results by direct relationships","false","77191320","",,,,,
"1640",":Tag","","","","","","","","https://stackoverflow.com/questions/tagged/neo4jphp","neo4jphp","","Tag","","false","","",,,,,
"1641",":Answer","","","The first thing you need to do is create all the nodes that you want to match on, as well as the parameters you want to use, like so:

```php
$a = node(&quot;Resource&quot;); // (a:Resource)
$b = node(&quot;Resource&quot;); // (b:Resource)

$uri = parameter(&quot;uri&quot;); // $uri
$object = parameter(&quot;object&quot;); // $object
```

The `node` function takes as its only argument the label of the node and the `parameter` function the name of the parameter. Next, you can start to compose your query. You can start a new query using the `query` function, like so:

```php
$query = query();
```

This returns a `Query` object, which has a number of methods to add new clauses to your query, such as `match`, `set`, `where` and `create`. These correspond to the clauses that Cypher offers.

We start by matching on the nodes `$a` and `$b`:

```php
$query = query() // Start a new query
    -&gt;match([$a, $b]) // Match on both &quot;a&quot; and &quot;b&quot;
    ...
```

Next, we want to create the condition to match on. php-cypher-dsl comes with a builder pattern for creating such expressions:

```php
    ...
    -&gt;where($a-&gt;property(&quot;uri&quot;)-&gt;equals($uri)-&gt;and($b-&gt;property(&quot;uri&quot;)-&gt;equals($object))
    ...
```

Next, before we create our `CREATE` clause, we need to create a new variable `$r` that gets shared between our `CREATE` and `RETURN` clause:

```php
$r = variable(); // Create a new variable
```

To create the `CREATE` clause, we need to perform some trickery to remove the `:Resource` label from our nodes again. This part of the API still needs some improvement. We can get a new node with the same variable by using `node()-&gt;withVariable($a-&gt;getVariable())`. All together, that looks like:

```php
    ...
    -&gt;create(node()-&gt;withVariable($a-&gt;getVariable())-&gt;relationshipTo(node()-&gt;withVariable($b-&gt;getVariable()), type: $propertyUri, name: $r))
    ...
```

Finally, we can return the value we want:

```php
    ...
    -&gt;returning(Procedure::raw(&#39;type&#39;, $r)) // The &quot;type&quot; function is not implemented natively, so we use raw
    -&gt;toQuery(); // Convert the query to a string
```

All put together, the code looks like this:

```php
use WikibaseSolutions\CypherDSL\Expressions\Procedures\Procedure;
use function WikibaseSolutions\CypherDSL\node;
use function WikibaseSolutions\CypherDSL\parameter;
use function WikibaseSolutions\CypherDSL\query;
use function WikibaseSolutions\CypherDSL\variable;

$propertyUri = &quot;http://example.com&quot;;

$a = node(&quot;Resource&quot;);
$b = node(&quot;Resource&quot;);
$uri = parameter(&quot;uri&quot;);
$object = parameter(&quot;object&quot;);
$r = variable();

$query = query()
    -&gt;match([$a, $b])
    -&gt;where($a-&gt;property(&quot;uri&quot;)-&gt;equals($uri)-&gt;and($b-&gt;property(&quot;uri&quot;)-&gt;equals($object)))
    -&gt;create(node()-&gt;withVariable($a-&gt;getVariable())-&gt;relationshipTo(node()-&gt;withVariable($b-&gt;getVariable()), type: $propertyUri, name: $r))
    -&gt;returning(Procedure::raw(&#39;type&#39;, $r))
    -&gt;toQuery();
```

Which I think is much *less* readable than using a normal query with variables. If you don&#39;t require complex logic to build queries (and only use pre-created queries, such as the one in your question), I&#39;d recommend you to not use this library.","","","","true","https://stackoverflow.com/a/77208534","","1","Answer","How can I translate this Neo4j cypher query to a PHP cypher DSL?","false","77208534","",,,,,
"1642",":User","","","","","Xxmarijnw","","","","","","User","","false","7513161","",,,,,
"1643",":Comment","","","","","","","","https://stackoverflow.com/questions/77166834/how-can-i-translate-this-neo4j-cypher-query-to-a-php-cypher-dsl#comment136037442_77166834","","0","Comment","","false","136037442","",,,,,
"1644",":User","","","","","KIKO Software","","","","","","User","","false","3986005","",,,,,
"1645",":Answer","","","I see that the [commit](https://github.com/neo4j/neo4j/commit/6ffe6e48e7f3bc49ace6c1855a05ccc8a9123600) that added support for normalizing types has this comment:

&gt; **Importer normalizes property types to match Cypher**
&gt;
&gt; Effectively meaning that a type, specified in some .csv header that says that a
&gt; certain property should be of type e.g. &quot;short&quot; will be imported as
&gt; type &quot;long&quot;. Basically all integer types will be imported and stored
&gt; as long and floating point types will be imported and stored as
&gt; double.
&gt; 
&gt; This will be the default behaviour, but can be overridden for specific
&gt; scenarios by providing &quot;--normalize-types=false&quot;

I presume this means that if you do not normalize types, then any un-normalized data types will have to be converted to/from normalized types whenever you use Cypher. So, even though you may save on storage space, your Cypher queries will be slowed down.

You may want to test it both ways to see if this is true (and let us know).","","","","false","https://stackoverflow.com/a/77161264","","1","Answer","neo4j: What are the tradeoffs of --normalize-types=false?","false","77161264","",,,,,
"1646",":Answer","","","You can create [APOC triggers](https://neo4j.com/docs/apoc/current/background-operations/triggers/) to perform additional processing whenever a node or relationship is created or updated.","","","","false","https://stackoverflow.com/a/77161144","","0","Answer","Modifying cypher query with additional properties and labels","false","77161144","",,,,,
"1647",":Answer","","","If you are allowing a string to be appended to the original query string before submitting, and there is a variable declared in the node, you can use the `SET` clause:
```
CREATE (newnode:testnode {tag_str: \&quot;mytag\&quot;})
SET newnode.property1 = value1,
    newnode.property2 = value2 ...
```","","","","true","https://stackoverflow.com/a/77225280","","1","Answer","Modifying cypher query with additional properties and labels","false","77225280","",,,,,
"1648",":Comment","","","","","","","","https://stackoverflow.com/questions/77160928/modifying-cypher-query-with-additional-properties-and-labels#comment136027439_77160928","","0","Comment","","false","136027439","",,,,,
"1649",":Comment","","","","","","","","https://stackoverflow.com/questions/77160928/modifying-cypher-query-with-additional-properties-and-labels#comment136051615_77160928","","0","Comment","","false","136051615","",,,,,
"1650",":Comment","","","","","","","","https://stackoverflow.com/questions/77160928/modifying-cypher-query-with-additional-properties-and-labels#comment136052608_77160928","","0","Comment","","false","136052608","",,,,,
"1651",":Comment","","","","","","","","https://stackoverflow.com/questions/77160928/modifying-cypher-query-with-additional-properties-and-labels#comment136052787_77160928","","0","Comment","","false","136052787","",,,,,
"1652",":Answer","","","Try:
```
RETURN apoc.number.format(125.4, &#39;0000.000&#39;) as value;
```
It returns: `&quot;0125.400&quot;`

Or to match your example:
```
RETURN apoc.number.format(3, &#39;00&#39;) as value;
```
returns `&quot;03&quot;`","","","","true","https://stackoverflow.com/a/77132469","","1","Answer","Converting an integer to a fixed-length string with leading zeros","false","77132469","",,,,,
"1653",":Answer","","","The APOC function apoc.text.lpad will add &#39;0&#39; to the left of a string at a given width.

    Ref:
    https://neo4j.com/labs/apoc/4.3/overview/apoc.text/apoc.text.lpad/
    
    

&gt; apoc.text.lpad(text,count,delim) YIELD value - left pad the string to
&gt; the given width


Example:
RETURN apoc.text.lpad(&quot;3&quot;, 2, &quot;0&quot;) AS output;

    ╒════════╕
    │&quot;output&quot;│
    ╞════════╡
    │&quot;03&quot;    │
    └────────┘","","","","false","https://stackoverflow.com/a/77134173","","0","Answer","Converting an integer to a fixed-length string with leading zeros","false","77134173","",,,,,
"1654",":Answer","",""," 1. You should make sure you have an [index](https://neo4j.com/docs/cypher-manual/current/indexes-for-search-performance/) (or [uniqueness constraint](https://neo4j.com/docs/cypher-manual/current/constraints/#_implications_on_indexes), if appropriate) on the `NodeID` property of the appropriate label(s). This will greatly speed up the queries for nodes with specific `NodeID` values.

    For example, if every `Transaction` node node should have a unique `NodeID` value, create a uniqueness constraint (which will automatically create an index for you) like this:

        CREATE CONSTRAINT Transaction_NodeID FOR (t:Transaction) REQUIRE t.NodeID IS UNIQUE

 2. When you reuse an already-defined variable, just use its name instead of redefining it to any extent. This simplification can eliminate unnecessary additional work. In your query, ``(grade:`2547`:Grade:Transaction)`` should just be `(grade)`, and ``(LegalEntity:`2547`:LegalEntity:Transaction)``, should be `(LegalEntity)`.

 3. You should pass [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) for the non-static parts of your query. That way, the server will only need to compile your query once, no matter how many times you call it with different parameter values.

    This example shows how to refactor your query to use the parameters $gradeIds and $entIds, each of which must be a list of ids. In addition, this query also attempts to fix a bug in your query, where `LegalEntityDocument` was not defined. And it also fixes item #2, above.

        MATCH (grade:Grade:`2547`:Transaction)-[vGrade:Version {Status: &quot;1&quot;}]-&gt;(grade)&lt;-[:Grade {Status: &quot;1&quot;}]-(n:User:`2547`:Transaction)
        WHERE grade.NodeID IN $gradeIds
        WITH n, grade, vGrade.Document as GradeDocument
        MATCH (LegalEntity:LegalEntity:`2547`:Transaction)-[lGrade:Version {Status: &quot;1&quot;}]-&gt;(LegalEntity)&lt;-[:LegalEntity {Status: &quot;1&quot;}]-(n)
        WHERE LegalEntity.NodeID IN $entIds
        RETURN n, Grade, GradeDocument, LegalEntity, lGrade.Document AS LegalEntityDocument
","","","","false","https://stackoverflow.com/a/77123609","","0","Answer","Optimizing a Cypher query in Neo4j","false","77123609","",,,,,
"1655",":Comment","","","","","","","","https://stackoverflow.com/questions/77123006/optimizing-a-cypher-query-in-neo4j#comment135968704_77123006","","0","Comment","","false","135968704","",,,,,
,,,,,,,,,,,,,,,,,"269","268","ASKED","false","false"
,,,,,,,,,,,,,,,,,"268","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"268","825","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"271","270","ASKED","false","false"
,,,,,,,,,,,,,,,,,"270","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"270","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"827","270","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"323","827","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"828","270","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","828","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"830","270","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","830","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"273","272","ASKED","false","false"
,,,,,,,,,,,,,,,,,"272","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"272","832","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"272","833","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"275","274","ASKED","false","false"
,,,,,,,,,,,,,,,,,"274","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"274","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"274","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"274","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"274","836","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"837","274","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"829","837","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"838","274","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"275","838","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"839","274","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","839","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"840","274","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"275","840","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"277","276","ASKED","false","false"
,,,,,,,,,,,,,,,,,"276","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"276","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"841","276","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","841","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"279","278","ASKED","false","false"
,,,,,,,,,,,,,,,,,"278","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"278","843","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"278","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"844","278","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","844","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"281","280","ASKED","false","false"
,,,,,,,,,,,,,,,,,"280","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"280","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"845","280","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","845","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"283","282","ASKED","false","false"
,,,,,,,,,,,,,,,,,"282","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"282","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"846","282","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","846","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"285","284","ASKED","false","false"
,,,,,,,,,,,,,,,,,"284","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"284","847","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"284","848","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"849","284","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"850","849","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"287","286","ASKED","false","false"
,,,,,,,,,,,,,,,,,"286","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"286","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"289","288","ASKED","false","false"
,,,,,,,,,,,,,,,,,"288","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"288","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"291","290","ASKED","false","false"
,,,,,,,,,,,,,,,,,"290","851","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"290","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"290","852","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"290","853","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"293","292","ASKED","false","false"
,,,,,,,,,,,,,,,,,"292","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"292","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"854","292","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","854","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"855","292","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"856","855","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"295","294","ASKED","false","false"
,,,,,,,,,,,,,,,,,"294","857","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"294","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"294","858","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"859","294","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"860","859","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"297","296","ASKED","false","false"
,,,,,,,,,,,,,,,,,"296","861","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"296","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"296","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"296","863","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"864","296","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"865","864","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"299","298","ASKED","false","false"
,,,,,,,,,,,,,,,,,"298","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"298","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"298","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"866","298","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","866","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"283","300","ASKED","false","false"
,,,,,,,,,,,,,,,,,"300","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"300","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"867","300","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","867","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"868","300","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","868","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"302","301","ASKED","false","false"
,,,,,,,,,,,,,,,,,"301","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"869","301","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"829","869","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"870","301","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","870","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"304","303","ASKED","false","false"
,,,,,,,,,,,,,,,,,"303","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"303","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"871","303","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","871","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"306","305","ASKED","false","false"
,,,,,,,,,,,,,,,,,"305","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"305","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"872","305","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"829","872","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"873","305","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"306","873","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"874","305","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","874","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"875","305","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"306","875","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"308","307","ASKED","false","false"
,,,,,,,,,,,,,,,,,"307","876","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"307","877","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"307","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"310","309","ASKED","false","false"
,,,,,,,,,,,,,,,,,"309","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"309","878","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"309","879","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"309","880","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"881","309","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","881","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"312","311","ASKED","false","false"
,,,,,,,,,,,,,,,,,"311","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"311","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"882","311","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","882","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"310","313","ASKED","false","false"
,,,,,,,,,,,,,,,,,"313","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"313","878","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"313","879","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"313","880","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"883","313","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","883","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"315","314","ASKED","false","false"
,,,,,,,,,,,,,,,,,"314","884","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"314","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"885","314","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","885","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"886","314","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","886","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"887","314","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"315","887","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"888","314","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","888","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"291","316","ASKED","false","false"
,,,,,,,,,,,,,,,,,"316","876","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"316","889","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"316","890","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"316","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"891","316","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","891","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"892","316","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"291","892","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"893","316","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","893","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"318","317","ASKED","false","false"
,,,,,,,,,,,,,,,,,"317","876","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"317","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"317","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"894","317","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"895","894","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"896","317","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"897","896","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"320","319","ASKED","false","false"
,,,,,,,,,,,,,,,,,"319","851","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"319","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"319","898","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"319","899","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"289","321","ASKED","false","false"
,,,,,,,,,,,,,,,,,"321","890","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"321","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"321","832","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"321","900","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"321","901","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"323","322","ASKED","false","false"
,,,,,,,,,,,,,,,,,"322","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"322","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"902","322","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"897","902","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"325","324","ASKED","false","false"
,,,,,,,,,,,,,,,,,"324","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"324","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"903","324","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","903","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"904","324","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","904","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"327","326","ASKED","false","false"
,,,,,,,,,,,,,,,,,"326","905","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"326","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"326","906","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"907","326","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","907","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"908","326","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","908","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"329","328","ASKED","false","false"
,,,,,,,,,,,,,,,,,"328","909","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"328","910","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"328","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"911","328","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"865","911","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"331","330","ASKED","false","false"
,,,,,,,,,,,,,,,,,"330","890","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"330","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"330","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"912","330","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","912","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"333","332","ASKED","false","false"
,,,,,,,,,,,,,,,,,"332","913","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"332","914","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"332","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"915","332","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"333","915","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"916","332","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","916","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"917","332","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"333","917","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"918","332","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"333","918","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"919","332","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"333","919","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"920","332","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","920","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"335","334","ASKED","false","false"
,,,,,,,,,,,,,,,,,"334","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"334","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"334","921","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"337","336","ASKED","false","false"
,,,,,,,,,,,,,,,,,"336","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"336","899","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"922","336","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"923","922","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"339","338","ASKED","false","false"
,,,,,,,,,,,,,,,,,"338","924","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"338","925","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"338","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"926","338","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"927","926","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"341","340","ASKED","false","false"
,,,,,,,,,,,,,,,,,"340","905","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"340","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"340","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"928","340","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"856","928","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"343","342","ASKED","false","false"
,,,,,,,,,,,,,,,,,"342","929","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"342","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"930","342","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","930","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"931","342","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","931","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"932","342","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"933","932","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"934","342","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"343","934","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"935","342","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"343","935","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"936","342","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","936","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"345","344","ASKED","false","false"
,,,,,,,,,,,,,,,,,"344","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"344","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"344","937","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"344","938","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"939","344","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"897","939","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"310","346","ASKED","false","false"
,,,,,,,,,,,,,,,,,"346","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"346","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"346","940","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"941","346","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"897","941","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"348","347","ASKED","false","false"
,,,,,,,,,,,,,,,,,"347","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"347","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"347","942","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"347","943","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"350","349","ASKED","false","false"
,,,,,,,,,,,,,,,,,"349","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"349","900","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"349","944","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"310","351","ASKED","false","false"
,,,,,,,,,,,,,,,,,"351","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"351","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"351","940","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"945","351","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","945","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"310","352","ASKED","false","false"
,,,,,,,,,,,,,,,,,"352","913","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"352","946","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"352","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"352","947","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"948","352","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"949","948","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"354","353","ASKED","false","false"
,,,,,,,,,,,,,,,,,"353","950","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"353","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"353","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"951","353","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","951","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"952","353","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"953","952","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"356","355","ASKED","false","false"
,,,,,,,,,,,,,,,,,"355","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"954","355","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"955","954","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"956","355","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","956","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"957","355","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","957","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"358","357","ASKED","false","false"
,,,,,,,,,,,,,,,,,"357","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"357","843","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"357","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"357","958","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"959","357","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","959","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"961","357","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"358","961","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"962","357","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","962","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"360","359","ASKED","false","false"
,,,,,,,,,,,,,,,,,"359","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"359","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"963","359","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","963","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"362","361","ASKED","false","false"
,,,,,,,,,,,,,,,,,"361","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"361","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"964","361","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","964","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"965","361","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","965","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"966","361","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"933","966","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"967","361","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"362","967","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"968","361","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"362","968","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"364","363","ASKED","false","false"
,,,,,,,,,,,,,,,,,"363","876","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"363","969","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"363","890","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"363","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"363","970","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"971","363","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"972","971","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"366","365","ASKED","false","false"
,,,,,,,,,,,,,,,,,"365","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"365","861","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"365","974","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"365","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"975","365","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"366","975","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"368","367","ASKED","false","false"
,,,,,,,,,,,,,,,,,"367","976","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"367","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"367","977","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"367","978","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"979","367","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"368","979","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"980","367","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"981","980","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"370","369","ASKED","false","false"
,,,,,,,,,,,,,,,,,"369","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"982","369","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"933","982","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"983","369","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","983","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"372","371","ASKED","false","false"
,,,,,,,,,,,,,,,,,"371","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"371","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"327","373","ASKED","false","false"
,,,,,,,,,,,,,,,,,"373","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"373","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"373","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"984","373","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","984","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"985","373","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","985","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"375","374","ASKED","false","false"
,,,,,,,,,,,,,,,,,"374","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"374","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"374","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"374","986","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"987","374","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","987","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"988","374","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","988","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"989","374","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"375","989","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"990","374","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","990","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"991","374","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"375","991","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"992","374","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","992","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"327","376","ASKED","false","false"
,,,,,,,,,,,,,,,,,"376","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"376","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"993","376","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","993","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"378","377","ASKED","false","false"
,,,,,,,,,,,,,,,,,"377","974","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"377","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"377","994","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"377","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"377","995","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"996","377","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"865","996","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"327","379","ASKED","false","false"
,,,,,,,,,,,,,,,,,"379","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"997","379","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","997","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"381","380","ASKED","false","false"
,,,,,,,,,,,,,,,,,"380","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"380","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"998","380","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","998","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"999","380","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","999","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"383","382","ASKED","false","false"
,,,,,,,,,,,,,,,,,"382","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"382","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"382","1000","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1001","382","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1001","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1002","382","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"383","1002","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"385","384","ASKED","false","false"
,,,,,,,,,,,,,,,,,"384","876","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"384","913","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"384","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1003","384","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1003","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"387","386","ASKED","false","false"
,,,,,,,,,,,,,,,,,"386","1004","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"386","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"386","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"386","1005","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"386","1006","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"389","388","ASKED","false","false"
,,,,,,,,,,,,,,,,,"388","913","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"388","1007","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"388","1008","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"388","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"388","1009","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1010","388","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"389","1010","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"391","390","ASKED","false","false"
,,,,,,,,,,,,,,,,,"390","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"390","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"390","1011","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1012","390","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1012","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1013","390","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"391","1013","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"393","392","ASKED","false","false"
,,,,,,,,,,,,,,,,,"392","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"392","861","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"392","974","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"392","913","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"392","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1014","392","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1015","1014","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1016","392","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"981","1016","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1017","392","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"393","1017","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1018","392","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"981","1018","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1019","392","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"393","1019","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1020","392","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"393","1020","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1021","392","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"393","1021","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"395","394","ASKED","false","false"
,,,,,,,,,,,,,,,,,"394","1022","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"394","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"394","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1023","394","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"395","1023","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1024","394","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1024","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1025","394","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"395","1025","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1026","394","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1026","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"397","396","ASKED","false","false"
,,,,,,,,,,,,,,,,,"396","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"396","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1027","396","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"897","1027","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1028","396","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1028","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1029","396","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1030","1029","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"399","398","ASKED","false","false"
,,,,,,,,,,,,,,,,,"398","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"398","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1031","398","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"399","1031","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1032","398","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1033","1032","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"401","400","ASKED","false","false"
,,,,,,,,,,,,,,,,,"400","976","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"400","1034","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"400","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"400","1035","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"400","1036","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1037","400","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1038","1037","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1039","400","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1038","1039","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1040","400","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"401","1040","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1041","400","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1038","1041","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1042","400","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"401","1042","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"403","402","ASKED","false","false"
,,,,,,,,,,,,,,,,,"402","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"402","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"402","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1043","402","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1043","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1044","402","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"403","1044","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"405","404","ASKED","false","false"
,,,,,,,,,,,,,,,,,"404","890","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"404","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"404","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"404","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1045","404","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1045","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"407","406","ASKED","false","false"
,,,,,,,,,,,,,,,,,"406","1046","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"406","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"406","878","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"406","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1047","406","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"407","1047","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"409","408","ASKED","false","false"
,,,,,,,,,,,,,,,,,"408","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"408","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"408","1048","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1049","408","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1050","1049","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1051","408","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1051","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"411","410","ASKED","false","false"
,,,,,,,,,,,,,,,,,"410","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"410","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1052","410","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1052","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1053","410","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1054","1053","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"413","412","ASKED","false","false"
,,,,,,,,,,,,,,,,,"412","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"412","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1055","412","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1055","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1056","412","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"413","1056","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"415","414","ASKED","false","false"
,,,,,,,,,,,,,,,,,"414","1057","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"414","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"414","1058","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"414","1059","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1060","414","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1061","1060","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1062","414","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1063","1062","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"415","416","ASKED","false","false"
,,,,,,,,,,,,,,,,,"416","1064","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"416","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"416","1065","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"416","1066","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"416","1059","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1067","416","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1061","1067","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"418","417","ASKED","false","false"
,,,,,,,,,,,,,,,,,"417","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"417","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1068","417","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1069","1068","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"383","419","ASKED","false","false"
,,,,,,,,,,,,,,,,,"419","1022","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"419","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"419","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1070","419","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1070","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"421","420","ASKED","false","false"
,,,,,,,,,,,,,,,,,"420","1046","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"420","1071","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"420","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"420","878","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"423","422","ASKED","false","false"
,,,,,,,,,,,,,,,,,"422","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"422","1072","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1073","422","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1073","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"425","424","ASKED","false","false"
,,,,,,,,,,,,,,,,,"424","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"424","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1074","424","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"425","1074","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"427","426","ASKED","false","false"
,,,,,,,,,,,,,,,,,"426","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"426","1075","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1076","426","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"856","1076","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1077","426","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1077","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1078","426","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1054","1078","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"429","428","ASKED","false","false"
,,,,,,,,,,,,,,,,,"428","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"428","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"428","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"428","836","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1079","428","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1080","1079","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"431","430","ASKED","false","false"
,,,,,,,,,,,,,,,,,"430","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"430","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"430","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"430","1048","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"433","432","ASKED","false","false"
,,,,,,,,,,,,,,,,,"432","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"432","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1081","432","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1081","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1082","432","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1082","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"435","434","ASKED","false","false"
,,,,,,,,,,,,,,,,,"434","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"434","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"434","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"434","1083","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"434","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1084","434","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1084","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1085","434","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1085","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"437","436","ASKED","false","false"
,,,,,,,,,,,,,,,,,"436","890","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"436","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"436","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1086","436","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1086","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1087","436","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"829","1087","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"327","438","ASKED","false","false"
,,,,,,,,,,,,,,,,,"438","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"438","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1088","438","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1088","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1089","438","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1090","1089","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1091","438","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1091","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1092","438","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"327","1092","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1093","438","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"327","1093","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"440","439","ASKED","false","false"
,,,,,,,,,,,,,,,,,"439","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"439","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1094","439","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"440","1094","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1095","439","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1095","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1096","439","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1080","1096","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"442","441","ASKED","false","false"
,,,,,,,,,,,,,,,,,"441","861","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"441","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1097","441","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"471","1097","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"444","443","ASKED","false","false"
,,,,,,,,,,,,,,,,,"443","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"443","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1098","443","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1098","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1099","443","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1099","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1100","443","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"444","1100","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1101","443","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1101","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"446","445","ASKED","false","false"
,,,,,,,,,,,,,,,,,"445","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1102","445","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1054","1102","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1103","445","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1054","1103","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"448","447","ASKED","false","false"
,,,,,,,,,,,,,,,,,"447","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"447","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1104","447","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1105","1104","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1106","447","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1106","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1107","447","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1108","1107","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"450","449","ASKED","false","false"
,,,,,,,,,,,,,,,,,"449","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"449","861","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"449","974","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"449","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"449","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1109","449","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1109","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"452","451","ASKED","false","false"
,,,,,,,,,,,,,,,,,"451","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"451","853","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"310","453","ASKED","false","false"
,,,,,,,,,,,,,,,,,"453","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"453","1110","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"453","1111","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"453","944","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"455","454","ASKED","false","false"
,,,,,,,,,,,,,,,,,"454","889","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"454","1112","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"454","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"454","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"454","1072","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1113","454","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"455","1113","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"457","456","ASKED","false","false"
,,,,,,,,,,,,,,,,,"456","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"456","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1114","456","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1054","1114","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1115","456","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1115","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1116","456","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1054","1116","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1117","456","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"457","1117","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"459","458","ASKED","false","false"
,,,,,,,,,,,,,,,,,"458","913","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"458","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"461","460","ASKED","false","false"
,,,,,,,,,,,,,,,,,"460","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"460","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"460","1118","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"463","462","ASKED","false","false"
,,,,,,,,,,,,,,,,,"462","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"462","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1119","462","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1080","1119","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1120","462","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"829","1120","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1121","462","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"463","1121","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1122","462","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"463","1122","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1123","462","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"829","1123","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1124","462","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"463","1124","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1125","462","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"829","1125","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"450","464","ASKED","false","false"
,,,,,,,,,,,,,,,,,"464","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"464","861","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"464","974","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"464","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"464","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1126","464","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"310","1126","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"466","465","ASKED","false","false"
,,,,,,,,,,,,,,,,,"465","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1127","465","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1030","1127","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"310","467","ASKED","false","false"
,,,,,,,,,,,,,,,,,"467","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"467","940","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1128","467","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1129","1128","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"469","468","ASKED","false","false"
,,,,,,,,,,,,,,,,,"468","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"468","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1130","468","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"856","1130","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"471","470","ASKED","false","false"
,,,,,,,,,,,,,,,,,"470","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"470","1131","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"310","472","ASKED","false","false"
,,,,,,,,,,,,,,,,,"472","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"472","1132","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"472","1133","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"472","940","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1134","472","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"897","1134","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"469","473","ASKED","false","false"
,,,,,,,,,,,,,,,,,"473","1135","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"473","890","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"473","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"473","1136","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"473","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1137","473","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1137","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1138","473","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1138","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"469","474","ASKED","false","false"
,,,,,,,,,,,,,,,,,"474","1135","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"474","890","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"474","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"474","1136","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"474","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1139","474","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1139","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"476","475","ASKED","false","false"
,,,,,,,,,,,,,,,,,"475","1140","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"475","1141","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"475","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1142","475","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1143","1142","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"478","477","ASKED","false","false"
,,,,,,,,,,,,,,,,,"477","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"477","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"477","832","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1144","477","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1144","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1145","477","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1145","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"450","479","ASKED","false","false"
,,,,,,,,,,,,,,,,,"479","861","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"479","974","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"479","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"479","1146","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"479","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1147","479","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"865","1147","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"481","480","ASKED","false","false"
,,,,,,,,,,,,,,,,,"480","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"480","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1148","480","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"856","1148","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1149","480","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1149","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"483","482","ASKED","false","false"
,,,,,,,,,,,,,,,,,"482","1150","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"482","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"482","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1151","482","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1151","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1152","482","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"829","1152","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1153","482","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"933","1153","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"485","484","ASKED","false","false"
,,,,,,,,,,,,,,,,,"484","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"484","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"484","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1154","484","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1154","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1155","484","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1155","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"310","486","ASKED","false","false"
,,,,,,,,,,,,,,,,,"486","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"486","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"486","1156","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1157","486","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1157","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1158","486","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1080","1158","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1159","486","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"310","1159","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1160","486","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1160","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"488","487","ASKED","false","false"
,,,,,,,,,,,,,,,,,"487","1161","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"487","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1162","487","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1162","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"490","489","ASKED","false","false"
,,,,,,,,,,,,,,,,,"489","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"489","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1163","489","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1163","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"471","491","ASKED","false","false"
,,,,,,,,,,,,,,,,,"491","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"491","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"491","1146","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"491","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"491","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1164","491","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1080","1164","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1165","491","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1166","1165","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1167","491","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"471","1167","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1168","491","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1080","1168","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1169","491","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"471","1169","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"493","492","ASKED","false","false"
,,,,,,,,,,,,,,,,,"492","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"492","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1170","492","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"493","1170","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1171","492","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1080","1171","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1172","492","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1172","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"495","494","ASKED","false","false"
,,,,,,,,,,,,,,,,,"494","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"494","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1173","494","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1173","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1174","494","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1080","1174","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1175","494","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"829","1175","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1176","494","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1177","1176","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1178","494","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1178","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"497","496","ASKED","false","false"
,,,,,,,,,,,,,,,,,"496","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"496","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1179","496","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"471","1179","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"499","498","ASKED","false","false"
,,,,,,,,,,,,,,,,,"498","909","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"498","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"498","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1180","498","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"499","1180","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"501","500","ASKED","false","false"
,,,,,,,,,,,,,,,,,"500","1181","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"500","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"500","1182","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1183","500","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"501","1183","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1184","500","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1185","1184","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"503","502","ASKED","false","false"
,,,,,,,,,,,,,,,,,"502","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"502","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"502","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1186","502","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1186","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1187","502","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1187","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"505","504","ASKED","false","false"
,,,,,,,,,,,,,,,,,"504","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"504","861","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"504","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"504","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"504","1188","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1189","504","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1189","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"507","506","ASKED","false","false"
,,,,,,,,,,,,,,,,,"506","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"506","1190","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1191","506","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1105","1191","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1192","506","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1193","1192","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1194","506","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"507","1194","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"463","508","ASKED","false","false"
,,,,,,,,,,,,,,,,,"508","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"508","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1195","508","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1195","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1196","508","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1196","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"510","509","ASKED","false","false"
,,,,,,,,,,,,,,,,,"509","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"509","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1197","509","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1197","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"512","511","ASKED","false","false"
,,,,,,,,,,,,,,,,,"511","1181","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"511","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"511","1198","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1199","511","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1199","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1200","511","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1200","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1201","511","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"512","1201","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"510","513","ASKED","false","false"
,,,,,,,,,,,,,,,,,"513","913","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"513","914","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"513","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1202","513","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"981","1202","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"515","514","ASKED","false","false"
,,,,,,,,,,,,,,,,,"514","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"514","1203","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"514","1204","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1205","514","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1206","1205","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"315","516","ASKED","false","false"
,,,,,,,,,,,,,,,,,"516","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"516","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"516","1207","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"516","832","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1208","516","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"345","1208","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1209","516","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1209","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1210","516","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"315","1210","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1211","516","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1211","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1212","516","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"315","1212","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"518","517","ASKED","false","false"
,,,,,,,,,,,,,,,,,"517","890","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"517","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"517","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"517","836","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1213","517","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1213","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"520","519","ASKED","false","false"
,,,,,,,,,,,,,,,,,"519","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"519","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1214","519","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"897","1214","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"522","521","ASKED","false","false"
,,,,,,,,,,,,,,,,,"521","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"521","921","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1215","521","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1215","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"524","523","ASKED","false","false"
,,,,,,,,,,,,,,,,,"523","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"523","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1216","523","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1217","1216","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1218","523","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1218","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"526","525","ASKED","false","false"
,,,,,,,,,,,,,,,,,"525","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"525","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"525","836","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1219","525","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"413","1219","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"528","527","ASKED","false","false"
,,,,,,,,,,,,,,,,,"527","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"527","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1220","527","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1220","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1221","527","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1222","1221","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"469","529","ASKED","false","false"
,,,,,,,,,,,,,,,,,"529","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"529","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1223","529","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1223","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"531","530","ASKED","false","false"
,,,,,,,,,,,,,,,,,"530","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"530","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"530","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"533","532","ASKED","false","false"
,,,,,,,,,,,,,,,,,"532","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"532","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1224","532","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1224","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"535","534","ASKED","false","false"
,,,,,,,,,,,,,,,,,"534","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"534","1225","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"534","1226","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1227","534","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"535","1227","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"537","536","ASKED","false","false"
,,,,,,,,,,,,,,,,,"536","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"536","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1228","536","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1228","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1229","536","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1229","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1230","536","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1230","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1231","536","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"537","1231","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1232","536","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1232","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"539","538","ASKED","false","false"
,,,,,,,,,,,,,,,,,"538","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"538","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"538","1233","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1234","538","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1235","1234","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1236","538","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"539","1236","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1237","538","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"413","1237","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"541","540","ASKED","false","false"
,,,,,,,,,,,,,,,,,"540","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1238","540","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1239","1238","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"543","542","ASKED","false","false"
,,,,,,,,,,,,,,,,,"542","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"542","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"542","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1240","542","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1240","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"545","544","ASKED","false","false"
,,,,,,,,,,,,,,,,,"544","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"544","879","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1241","544","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1241","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1242","544","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1242","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"547","546","ASKED","false","false"
,,,,,,,,,,,,,,,,,"546","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"546","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"549","548","ASKED","false","false"
,,,,,,,,,,,,,,,,,"548","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"548","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"548","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1243","548","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1244","1243","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1245","548","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1245","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"510","550","ASKED","false","false"
,,,,,,,,,,,,,,,,,"550","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"550","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1246","550","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1246","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1247","550","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1069","1247","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"552","551","ASKED","false","false"
,,,,,,,,,,,,,,,,,"551","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1248","551","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1069","1248","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1249","551","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1249","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"554","553","ASKED","false","false"
,,,,,,,,,,,,,,,,,"553","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"553","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"553","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1250","553","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1250","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1251","553","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"554","1251","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1252","553","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1252","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1253","553","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1253","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"524","555","ASKED","false","false"
,,,,,,,,,,,,,,,,,"555","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"555","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"555","1188","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1254","555","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1254","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1255","555","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1256","1255","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"557","556","ASKED","false","false"
,,,,,,,,,,,,,,,,,"556","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"556","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1257","556","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1257","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"450","558","ASKED","false","false"
,,,,,,,,,,,,,,,,,"558","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"558","861","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"558","1258","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"558","1259","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"558","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"560","559","ASKED","false","false"
,,,,,,,,,,,,,,,,,"559","1260","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"559","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1261","559","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1261","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"562","561","ASKED","false","false"
,,,,,,,,,,,,,,,,,"561","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"561","913","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"561","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1262","561","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1262","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1263","561","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1264","1263","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1265","561","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"562","1265","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"564","563","ASKED","false","false"
,,,,,,,,,,,,,,,,,"563","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"563","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1266","563","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1266","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1267","563","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1267","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1268","563","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1269","1268","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1270","563","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1270","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"566","565","ASKED","false","false"
,,,,,,,,,,,,,,,,,"565","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"565","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1271","565","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1271","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1272","565","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1272","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1273","565","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1273","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1274","565","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1274","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1275","565","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"566","1275","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1276","565","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"566","1276","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1277","565","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1277","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1278","565","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1278","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"310","567","ASKED","false","false"
,,,,,,,,,,,,,,,,,"567","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"567","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1279","567","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1279","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"569","568","ASKED","false","false"
,,,,,,,,,,,,,,,,,"568","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"568","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1280","568","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1280","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"571","570","ASKED","false","false"
,,,,,,,,,,,,,,,,,"570","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"570","1203","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"570","1281","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1282","570","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1269","1282","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1283","570","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1283","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1284","570","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"571","1284","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"573","572","ASKED","false","false"
,,,,,,,,,,,,,,,,,"572","1285","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"572","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"572","1286","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1287","572","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1288","1287","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1289","572","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1288","1289","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1290","572","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"573","1290","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1291","572","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1288","1291","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"575","574","ASKED","false","false"
,,,,,,,,,,,,,,,,,"574","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"574","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1292","574","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1293","1292","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1294","574","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"575","1294","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"389","576","ASKED","false","false"
,,,,,,,,,,,,,,,,,"576","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"576","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1295","576","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1295","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1296","576","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1030","1296","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1297","576","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"955","1297","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"578","577","ASKED","false","false"
,,,,,,,,,,,,,,,,,"577","884","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"577","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1298","577","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"578","1298","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1299","577","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1299","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"580","579","ASKED","false","false"
,,,,,,,,,,,,,,,,,"579","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1300","579","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"955","1300","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1301","579","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1301","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"582","581","ASKED","false","false"
,,,,,,,,,,,,,,,,,"581","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"581","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1302","581","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1302","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1303","581","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1030","1303","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1304","581","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1304","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"584","583","ASKED","false","false"
,,,,,,,,,,,,,,,,,"583","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"583","1305","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"583","1306","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"583","942","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1307","583","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1269","1307","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1308","583","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1269","1308","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1309","583","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"584","1309","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"586","585","ASKED","false","false"
,,,,,,,,,,,,,,,,,"585","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"585","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"585","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"585","958","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1310","585","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1311","1310","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1312","585","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1313","1312","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"588","587","ASKED","false","false"
,,,,,,,,,,,,,,,,,"587","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"587","878","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"587","1314","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"587","942","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1315","587","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1316","1315","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"582","589","ASKED","false","false"
,,,,,,,,,,,,,,,,,"589","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"589","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1317","589","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1317","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"591","590","ASKED","false","false"
,,,,,,,,,,,,,,,,,"590","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"590","913","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"590","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1318","590","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1318","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"593","592","ASKED","false","false"
,,,,,,,,,,,,,,,,,"592","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"592","1319","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"592","1320","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1321","592","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1321","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"595","594","ASKED","false","false"
,,,,,,,,,,,,,,,,,"594","1135","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"594","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"594","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1322","594","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1322","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"597","596","ASKED","false","false"
,,,,,,,,,,,,,,,,,"596","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"596","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1323","596","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1323","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1324","596","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"597","1324","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1325","596","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1325","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1326","596","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"597","1326","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1327","596","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1327","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"599","598","ASKED","false","false"
,,,,,,,,,,,,,,,,,"598","1071","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"598","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"598","995","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"598","1328","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"598","1329","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1330","598","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"599","1330","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"601","600","ASKED","false","false"
,,,,,,,,,,,,,,,,,"600","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"600","832","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"603","602","ASKED","false","false"
,,,,,,,,,,,,,,,,,"602","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"578","604","ASKED","false","false"
,,,,,,,,,,,,,,,,,"604","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"604","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1331","604","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1331","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1332","604","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"578","1332","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"606","605","ASKED","false","false"
,,,,,,,,,,,,,,,,,"605","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"605","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1333","605","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1333","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"539","607","ASKED","false","false"
,,,,,,,,,,,,,,,,,"607","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"607","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1334","607","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"949","1334","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1335","607","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1335","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"609","608","ASKED","false","false"
,,,,,,,,,,,,,,,,,"608","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"608","1258","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"608","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"608","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"608","1111","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1336","608","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1336","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"611","610","ASKED","false","false"
,,,,,,,,,,,,,,,,,"610","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"610","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1337","610","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1337","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1338","610","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1339","1338","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1340","610","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1340","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"613","612","ASKED","false","false"
,,,,,,,,,,,,,,,,,"612","913","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"612","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1341","612","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1341","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1342","612","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"613","1342","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"613","614","ASKED","false","false"
,,,,,,,,,,,,,,,,,"614","913","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"614","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1343","614","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1343","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"616","615","ASKED","false","false"
,,,,,,,,,,,,,,,,,"615","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1344","615","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"616","1344","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1345","615","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1235","1345","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1346","615","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1346","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1347","615","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"616","1347","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"618","617","ASKED","false","false"
,,,,,,,,,,,,,,,,,"617","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"617","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1348","617","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1348","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1349","617","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"829","1349","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1350","617","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"618","1350","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"620","619","ASKED","false","false"
,,,,,,,,,,,,,,,,,"619","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"619","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"619","1351","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1352","619","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1352","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1353","619","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"897","1353","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"622","621","ASKED","false","false"
,,,,,,,,,,,,,,,,,"621","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"621","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1354","621","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1355","1354","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"310","623","ASKED","false","false"
,,,,,,,,,,,,,,,,,"623","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"623","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"623","1156","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1356","623","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1054","1356","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"625","624","ASKED","false","false"
,,,,,,,,,,,,,,,,,"624","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"448","626","ASKED","false","false"
,,,,,,,,,,,,,,,,,"626","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"626","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"626","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1357","626","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1357","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1358","626","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1358","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1359","626","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1105","1359","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"628","627","ASKED","false","false"
,,,,,,,,,,,,,,,,,"627","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"627","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"627","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"627","1111","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1360","627","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1355","1360","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1361","627","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"628","1361","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"630","629","ASKED","false","false"
,,,,,,,,,,,,,,,,,"629","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"629","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"629","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"629","836","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1362","629","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1363","1362","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1364","629","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"955","1364","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1365","629","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1365","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1366","629","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1366","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1367","629","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"630","1367","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1368","629","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1368","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"310","631","ASKED","false","false"
,,,,,,,,,,,,,,,,,"631","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"631","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"631","1156","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1369","631","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1369","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"633","632","ASKED","false","false"
,,,,,,,,,,,,,,,,,"632","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"632","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"632","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1370","632","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1370","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"635","634","ASKED","false","false"
,,,,,,,,,,,,,,,,,"634","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"634","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"634","943","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1371","634","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"323","1371","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"637","636","ASKED","false","false"
,,,,,,,,,,,,,,,,,"636","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"636","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1372","636","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1373","1372","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"639","638","ASKED","false","false"
,,,,,,,,,,,,,,,,,"638","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"638","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1374","638","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"323","1374","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1375","638","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1375","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1376","638","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1376","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"637","640","ASKED","false","false"
,,,,,,,,,,,,,,,,,"640","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"640","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1377","640","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1377","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1378","640","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1378","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"642","641","ASKED","false","false"
,,,,,,,,,,,,,,,,,"641","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"641","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"641","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"641","825","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1379","641","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1379","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1380","641","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1380","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"469","643","ASKED","false","false"
,,,,,,,,,,,,,,,,,"643","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"643","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1381","643","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"897","1381","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1382","643","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"323","1382","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1383","643","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"469","1383","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1384","643","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1384","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"537","644","ASKED","false","false"
,,,,,,,,,,,,,,,,,"644","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"644","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1385","644","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1385","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1386","644","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"933","1386","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1387","644","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"537","1387","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1388","644","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1388","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"646","645","ASKED","false","false"
,,,,,,,,,,,,,,,,,"645","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"645","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1389","645","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1389","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"310","647","ASKED","false","false"
,,,,,,,,,,,,,,,,,"647","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"647","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"647","1390","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"647","1111","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1391","647","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1392","1391","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1393","647","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"310","1393","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"649","648","ASKED","false","false"
,,,,,,,,,,,,,,,,,"648","1394","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"648","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"648","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1395","648","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"856","1395","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"310","650","ASKED","false","false"
,,,,,,,,,,,,,,,,,"650","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"650","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"650","1390","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"650","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"652","651","ASKED","false","false"
,,,,,,,,,,,,,,,,,"651","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"651","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"651","1396","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"651","1083","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1397","651","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1397","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1398","651","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"652","1398","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"654","653","ASKED","false","false"
,,,,,,,,,,,,,,,,,"653","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"653","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"653","836","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1399","653","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"955","1399","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1400","653","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1400","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1401","653","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"654","1401","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1402","653","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1402","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1403","653","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"654","1403","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1404","653","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1404","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"656","655","ASKED","false","false"
,,,,,,,,,,,,,,,,,"655","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"655","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1405","655","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1269","1405","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1406","655","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1406","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"310","657","ASKED","false","false"
,,,,,,,,,,,,,,,,,"657","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"657","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1407","657","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1407","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"310","658","ASKED","false","false"
,,,,,,,,,,,,,,,,,"658","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"658","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1408","658","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1408","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1409","658","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1409","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1410","658","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"310","1410","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"660","659","ASKED","false","false"
,,,,,,,,,,,,,,,,,"659","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"659","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1411","659","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1355","1411","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1412","659","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1412","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"662","661","ASKED","false","false"
,,,,,,,,,,,,,,,,,"661","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"661","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1413","661","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"323","1413","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"664","663","ASKED","false","false"
,,,,,,,,,,,,,,,,,"663","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"663","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1414","663","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"323","1414","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"343","665","ASKED","false","false"
,,,,,,,,,,,,,,,,,"665","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"665","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1415","665","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"897","1415","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"667","666","ASKED","false","false"
,,,,,,,,,,,,,,,,,"666","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"666","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1416","666","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"323","1416","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1417","666","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1417","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1418","666","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1419","1418","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1420","666","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"667","1420","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1421","666","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"323","1421","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"669","668","ASKED","false","false"
,,,,,,,,,,,,,,,,,"668","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"668","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1422","668","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1422","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1423","668","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1424","1423","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1425","668","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1425","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1426","668","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1426","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1427","668","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"669","1427","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"671","670","ASKED","false","false"
,,,,,,,,,,,,,,,,,"670","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"670","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1428","670","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"671","1428","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1429","670","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1429","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"537","672","ASKED","false","false"
,,,,,,,,,,,,,,,,,"672","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"672","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1430","672","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1054","1430","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1431","672","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1431","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1432","672","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"537","1432","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"674","673","ASKED","false","false"
,,,,,,,,,,,,,,,,,"673","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"673","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1433","673","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1434","1433","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"554","675","ASKED","false","false"
,,,,,,,,,,,,,,,,,"675","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"675","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"675","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1435","675","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1435","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"403","676","ASKED","false","false"
,,,,,,,,,,,,,,,,,"676","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"676","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"676","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1436","676","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1436","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"678","677","ASKED","false","false"
,,,,,,,,,,,,,,,,,"677","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"677","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1437","677","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1438","1437","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1439","677","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1439","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"680","679","ASKED","false","false"
,,,,,,,,,,,,,,,,,"679","857","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"679","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"679","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"679","1319","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"584","681","ASKED","false","false"
,,,,,,,,,,,,,,,,,"681","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"681","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1440","681","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1440","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"683","682","ASKED","false","false"
,,,,,,,,,,,,,,,,,"682","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"682","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"682","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1441","682","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1438","1441","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1442","682","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1030","1442","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1443","682","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1235","1443","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"664","684","ASKED","false","false"
,,,,,,,,,,,,,,,,,"684","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"684","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"684","958","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1444","684","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1444","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"686","685","ASKED","false","false"
,,,,,,,,,,,,,,,,,"685","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"685","974","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"685","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"685","1445","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1446","685","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1447","1446","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"688","687","ASKED","false","false"
,,,,,,,,,,,,,,,,,"687","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"687","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1448","687","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1448","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1449","687","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1449","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1450","687","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"688","1450","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1451","687","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1451","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1452","687","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1452","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1453","687","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1453","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"690","689","ASKED","false","false"
,,,,,,,,,,,,,,,,,"689","1454","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"689","878","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"689","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"689","1455","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"689","1456","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"692","691","ASKED","false","false"
,,,,,,,,,,,,,,,,,"691","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"691","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1457","691","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1457","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"694","693","ASKED","false","false"
,,,,,,,,,,,,,,,,,"693","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"693","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1458","693","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1269","1458","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1459","693","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1459","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"696","695","ASKED","false","false"
,,,,,,,,,,,,,,,,,"695","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"695","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1460","695","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1460","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1461","695","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1461","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"698","697","ASKED","false","false"
,,,,,,,,,,,,,,,,,"697","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"697","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"697","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"697","1462","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"697","836","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1463","697","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1463","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"686","699","ASKED","false","false"
,,,,,,,,,,,,,,,,,"699","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"699","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"699","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"699","1445","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1464","699","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"686","1464","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1465","699","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1465","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1466","699","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"686","1466","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1467","699","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1447","1467","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1468","699","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"686","1468","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"701","700","ASKED","false","false"
,,,,,,,,,,,,,,,,,"700","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"700","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"700","1469","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"700","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"700","958","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1470","700","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1470","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"703","702","ASKED","false","false"
,,,,,,,,,,,,,,,,,"702","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"702","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"702","1471","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"702","1472","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"705","704","ASKED","false","false"
,,,,,,,,,,,,,,,,,"704","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"704","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1473","704","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"323","1473","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1474","704","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1474","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"707","706","ASKED","false","false"
,,,,,,,,,,,,,,,,,"706","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"706","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1475","706","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1475","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1476","706","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1476","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1477","706","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1477","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"709","708","ASKED","false","false"
,,,,,,,,,,,,,,,,,"708","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"708","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"708","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"708","995","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"708","1478","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1479","708","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"709","1479","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1480","708","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1480","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1481","708","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"709","1481","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"711","710","ASKED","false","false"
,,,,,,,,,,,,,,,,,"710","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"710","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1482","710","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1373","1482","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1483","710","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1483","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1484","710","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"711","1484","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"713","712","ASKED","false","false"
,,,,,,,,,,,,,,,,,"712","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"712","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1485","712","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1485","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"715","714","ASKED","false","false"
,,,,,,,,,,,,,,,,,"714","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"714","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1486","714","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1487","1486","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1488","714","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1488","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"717","716","ASKED","false","false"
,,,,,,,,,,,,,,,,,"716","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"716","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1489","716","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"949","1489","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1490","716","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1490","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1491","716","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1491","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"719","718","ASKED","false","false"
,,,,,,,,,,,,,,,,,"718","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"718","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1492","718","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1492","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1493","718","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1493","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"721","720","ASKED","false","false"
,,,,,,,,,,,,,,,,,"720","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"720","1494","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"720","1478","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1495","720","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1496","1495","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1497","720","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1496","1497","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1498","720","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"721","1498","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1499","720","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1496","1499","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"723","722","ASKED","false","false"
,,,,,,,,,,,,,,,,,"722","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"722","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1500","722","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"323","1500","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1501","722","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1501","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"725","724","ASKED","false","false"
,,,,,,,,,,,,,,,,,"724","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"724","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1502","724","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1069","1502","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1503","724","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1503","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"725","726","ASKED","false","false"
,,,,,,,,,,,,,,,,,"726","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"726","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1504","726","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1504","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1505","726","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1505","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"728","727","ASKED","false","false"
,,,,,,,,,,,,,,,,,"727","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"727","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1506","727","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1507","1506","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"728","729","ASKED","false","false"
,,,,,,,,,,,,,,,,,"729","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"729","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1508","729","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1507","1508","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1509","729","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1030","1509","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1510","729","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1510","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"707","730","ASKED","false","false"
,,,,,,,,,,,,,,,,,"730","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"730","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1511","730","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1507","1511","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"732","731","ASKED","false","false"
,,,,,,,,,,,,,,,,,"731","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"731","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"731","1512","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1513","731","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1030","1513","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"734","733","ASKED","false","false"
,,,,,,,,,,,,,,,,,"733","1514","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"733","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"733","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1515","733","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1438","1515","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1516","733","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1177","1516","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"736","735","ASKED","false","false"
,,,,,,,,,,,,,,,,,"735","1517","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"735","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"735","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1518","735","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1177","1518","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1519","735","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1519","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"310","737","ASKED","false","false"
,,,,,,,,,,,,,,,,,"737","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"737","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1520","737","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1054","1520","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1521","737","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1521","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"739","738","ASKED","false","false"
,,,,,,,,,,,,,,,,,"738","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"738","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1522","738","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1522","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1523","738","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1373","1523","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1524","738","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1524","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"728","740","ASKED","false","false"
,,,,,,,,,,,,,,,,,"740","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"740","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1525","740","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1177","1525","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1526","740","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1526","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"715","741","ASKED","false","false"
,,,,,,,,,,,,,,,,,"741","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"741","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1527","741","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1527","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1528","741","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1054","1528","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1529","741","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"715","1529","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"743","742","ASKED","false","false"
,,,,,,,,,,,,,,,,,"742","876","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"742","1260","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"742","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"742","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"742","1530","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1531","742","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1532","1531","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"745","744","ASKED","false","false"
,,,,,,,,,,,,,,,,,"744","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"744","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1533","744","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"413","1533","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1534","744","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1293","1534","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1535","744","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"745","1535","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1536","744","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1293","1536","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1537","744","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"745","1537","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1538","744","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1293","1538","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"739","746","ASKED","false","false"
,,,,,,,,,,,,,,,,,"746","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"746","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"746","1478","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1539","746","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1539","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1540","746","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1540","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"748","747","ASKED","false","false"
,,,,,,,,,,,,,,,,,"747","1022","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"747","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"747","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1541","747","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1541","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1542","747","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1269","1542","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1543","747","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"748","1543","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"750","749","ASKED","false","false"
,,,,,,,,,,,,,,,,,"749","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"749","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"749","1544","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1545","749","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1545","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1546","749","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"750","1546","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1547","749","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1547","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"752","751","ASKED","false","false"
,,,,,,,,,,,,,,,,,"751","1022","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"751","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"751","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1548","751","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1548","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1549","751","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"752","1549","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1550","751","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1269","1550","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"754","753","ASKED","false","false"
,,,,,,,,,,,,,,,,,"753","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"753","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"753","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"753","1111","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1551","753","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1551","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"739","755","ASKED","false","false"
,,,,,,,,,,,,,,,,,"755","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"755","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"755","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"755","1478","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1552","755","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1269","1552","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"748","756","ASKED","false","false"
,,,,,,,,,,,,,,,,,"756","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"756","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"756","1553","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1554","756","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1269","1554","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"758","757","ASKED","false","false"
,,,,,,,,,,,,,,,,,"757","876","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"757","890","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"757","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"757","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"757","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1555","757","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1555","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1556","757","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1556","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"725","759","ASKED","false","false"
,,,,,,,,,,,,,,,,,"759","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"759","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1557","759","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1293","1557","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1558","759","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1293","1558","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1559","759","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"725","1559","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"761","760","ASKED","false","false"
,,,,,,,,,,,,,,,,,"760","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"760","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"760","1560","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"760","1561","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"760","1562","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1563","760","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1563","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1564","760","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1564","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"763","762","ASKED","false","false"
,,,,,,,,,,,,,,,,,"762","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"762","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1565","762","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1565","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"765","764","ASKED","false","false"
,,,,,,,,,,,,,,,,,"764","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"764","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1566","764","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1355","1566","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1567","764","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1567","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1568","764","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1568","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1569","764","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"765","1569","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1570","764","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1570","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"767","766","ASKED","false","false"
,,,,,,,,,,,,,,,,,"766","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"766","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1571","766","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1571","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1572","766","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1572","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"769","768","ASKED","false","false"
,,,,,,,,,,,,,,,,,"768","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"768","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1573","768","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1269","1573","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1574","768","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1574","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1575","768","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"769","1575","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"771","770","ASKED","false","false"
,,,,,,,,,,,,,,,,,"770","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"770","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1576","770","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1576","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1577","770","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1577","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"773","772","ASKED","false","false"
,,,,,,,,,,,,,,,,,"772","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"772","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1578","772","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1269","1578","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"775","774","ASKED","false","false"
,,,,,,,,,,,,,,,,,"774","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"774","1478","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"774","1579","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1580","774","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1580","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"777","776","ASKED","false","false"
,,,,,,,,,,,,,,,,,"776","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"776","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1581","776","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1293","1581","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1582","776","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1293","1582","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1583","776","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"777","1583","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"779","778","ASKED","false","false"
,,,,,,,,,,,,,,,,,"778","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"778","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1584","778","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1584","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1585","778","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1585","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1586","778","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"779","1586","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"781","780","ASKED","false","false"
,,,,,,,,,,,,,,,,,"780","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"780","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1587","780","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1269","1587","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1588","780","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"781","1588","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1589","780","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1293","1589","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1590","780","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"781","1590","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"783","782","ASKED","false","false"
,,,,,,,,,,,,,,,,,"782","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"782","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1591","782","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1080","1591","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1592","782","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1592","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1593","782","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1593","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1594","782","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"783","1594","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"785","784","ASKED","false","false"
,,,,,,,,,,,,,,,,,"784","842","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"784","973","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"784","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"784","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1595","784","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1080","1595","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"787","786","ASKED","false","false"
,,,,,,,,,,,,,,,,,"786","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"786","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1596","786","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1596","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1597","786","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1080","1597","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"789","788","ASKED","false","false"
,,,,,,,,,,,,,,,,,"788","974","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"788","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"788","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"788","862","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1598","788","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1373","1598","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1599","788","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1600","1599","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"734","790","ASKED","false","false"
,,,,,,,,,,,,,,,,,"790","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"790","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1601","790","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1293","1601","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1602","790","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1373","1602","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"792","791","ASKED","false","false"
,,,,,,,,,,,,,,,,,"791","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"791","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"791","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1603","791","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1373","1603","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"794","793","ASKED","false","false"
,,,,,,,,,,,,,,,,,"793","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"793","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"793","834","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1604","793","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1293","1604","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1605","793","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1293","1605","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1606","793","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"794","1606","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1607","793","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1293","1607","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1608","793","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"794","1608","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1609","793","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1293","1609","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1610","793","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"794","1610","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"796","795","ASKED","false","false"
,,,,,,,,,,,,,,,,,"795","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"795","1611","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"795","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1612","795","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1613","1612","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"798","797","ASKED","false","false"
,,,,,,,,,,,,,,,,,"797","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"797","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1614","797","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1293","1614","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1615","797","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1080","1615","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"800","799","ASKED","false","false"
,,,,,,,,,,,,,,,,,"799","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"799","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"799","1188","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"799","1478","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1616","799","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1617","1616","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"802","801","ASKED","false","false"
,,,,,,,,,,,,,,,,,"801","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"801","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1618","801","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1239","1618","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1619","801","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"802","1619","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1620","801","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1080","1620","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"804","803","ASKED","false","false"
,,,,,,,,,,,,,,,,,"803","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1621","803","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"804","1621","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1622","803","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1622","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"806","805","ASKED","false","false"
,,,,,,,,,,,,,,,,,"805","1623","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"805","890","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"805","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1624","805","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1624","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1625","805","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1625","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1626","805","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"806","1626","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1627","805","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"806","1627","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1628","805","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1628","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"808","807","ASKED","false","false"
,,,,,,,,,,,,,,,,,"807","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"807","1188","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"807","1478","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"807","1629","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1630","807","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"897","1630","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1631","807","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1632","1631","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"810","809","ASKED","false","false"
,,,,,,,,,,,,,,,,,"809","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"809","1188","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"809","1478","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1633","809","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1633","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"812","811","ASKED","false","false"
,,,,,,,,,,,,,,,,,"811","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"811","1188","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"811","1478","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"811","1634","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1635","811","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1635","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1636","811","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1637","1636","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"814","813","ASKED","false","false"
,,,,,,,,,,,,,,,,,"813","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"813","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1638","813","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1355","1638","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1639","813","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1639","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"816","815","ASKED","false","false"
,,,,,,,,,,,,,,,,,"815","1623","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"815","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"815","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"815","1640","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1641","815","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"1642","1641","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1643","815","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"1644","1643","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"818","817","ASKED","false","false"
,,,,,,,,,,,,,,,,,"817","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"817","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1645","817","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1645","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"820","819","ASKED","false","false"
,,,,,,,,,,,,,,,,,"819","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"819","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1646","819","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1646","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1647","819","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"829","1647","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1648","819","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"960","1648","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1649","819","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"820","1649","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1650","819","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"831","1650","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"1651","819","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"820","1651","COMMENTED","false","false"
,,,,,,,,,,,,,,,,,"822","821","ASKED","false","false"
,,,,,,,,,,,,,,,,,"821","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"821","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"821","835","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"821","1111","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1652","821","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"323","1652","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1653","821","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"960","1653","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"566","823","ASKED","false","false"
,,,,,,,,,,,,,,,,,"823","824","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"823","826","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"823","1156","TAGGED","false","false"
,,,,,,,,,,,,,,,,,"1654","823","ANSWERED","false","false"
,,,,,,,,,,,,,,,,,"831","1654","PROVIDED","false","false"
,,,,,,,,,,,,,,,,,"1655","823","COMMENTED_ON","false","false"
,,,,,,,,,,,,,,,,,"933","1655","COMMENTED","false","false"
